<!DOCTYPE html>
<html>
<head>
  <title>Paint Artifact Visualizer (Pre-Layerization)</title>
  <script src="https://unpkg.com/canvaskit-wasm@0.39.1/bin/canvaskit.js"></script>
  <style>
    body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif; display: flex; flex-direction: column; align-items: center; padding: 20px; background: #f0f2f5; margin: 0; }
    h2 { color: #1a1a1a; margin-bottom: 5px; }
    .subtitle { color: #666; margin-bottom: 20px; font-size: 0.9em; }
    #canvas-container { box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06); border-radius: 8px; overflow: hidden; background: white; }
    canvas { display: block; }
    .controls { margin: 20px; display: flex; align-items: center; gap: 15px; background: white; padding: 10px 20px; border-radius: 50px; box-shadow: 0 2px 4px rgba(0,0,0,0.05); }
    .layer-info { margin-top: 20px; background: white; padding: 20px; border-radius: 8px; font-size: 13px; width: 100%; max-width: 800px; box-shadow: 0 1px 3px rgba(0,0,0,0.1); }
    .layer-info h3 { margin-top: 0; border-bottom: 1px solid #eee; padding-bottom: 10px; }
    pre { background: #f8f9fa; padding: 10px; border-radius: 4px; overflow-x: auto; white-space: pre-wrap; font-family: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, monospace; max-height: 400px; overflow-y: auto; }
    .error { color: #d32f2f; background: #ffebee; padding: 10px; border-radius: 4px; }
    .badge { display: inline-block; background: #fff3e0; color: #e65100; padding: 2px 8px; border-radius: 4px; font-size: 0.8em; margin-left: 10px; }
  </style>
</head>
<body>
  <h2>Paint Artifact Visualizer <span class="badge">Pre-Layerization</span></h2>
  <div class="subtitle">Rendering paint ops from paint_artifact.json (raw PaintChunks before layerization)</div>

  <div id="canvas-container">
    <canvas id="skcanvas" width="2000" height="20000"></canvas>
  </div>

  <div class="controls">
    <label><input type="checkbox" id="chkBounds"> Show Chunk Bounds</label>
    <label><input type="checkbox" id="chkDebug"> Debug Mode</label>
  </div>

  <div class="layer-info">
    <h3>Status Log</h3>
    <pre id="status">Initializing CanvasKit...</pre>
    <h3>Paint Chunks</h3>
    <pre id="layerList">Waiting for data...</pre>
  </div>

<script type="module">
// ============================================
// Property Trees Parser (same format as blink_property_trees)
// ============================================

class PropertyTrees {
    constructor(data, CanvasKit) {
        this.CK = CanvasKit;
        this.transformNodes = new Map();
        this.effectNodes = new Map();
        this.clipNodes = new Map();

        if (data.transform_tree && data.transform_tree.nodes) {
            data.transform_tree.nodes.forEach(n => this.transformNodes.set(n.id, n));
        }
        if (data.effect_tree && data.effect_tree.nodes) {
            data.effect_tree.nodes.forEach(n => this.effectNodes.set(n.id, n));
        }
        if (data.clip_tree && data.clip_tree.nodes) {
            data.clip_tree.nodes.forEach(n => this.clipNodes.set(n.id, n));
        }
    }

    // Get accumulated transform matrix for a given node ID
    getTransformMatrix(nodeId) {
        let chain = [];
        let currentId = nodeId;

        while(currentId !== -1 && this.transformNodes.has(currentId)) {
            chain.push(this.transformNodes.get(currentId));
            currentId = chain[chain.length-1].parent_id;
        }

        let result = this.CK.M44.identity();

        // Apply transformations Root -> Leaf
        for (let i = chain.length - 1; i >= 0; i--) {
            const node = chain[i];

            // Check for matrix (16-element array) - from serializer
            // Both the serializer and CanvasKit use row-major format
            // So no transpose is needed
            if (node.matrix && node.matrix.length === 16) {
                result = this.CK.M44.multiply(result, node.matrix);
            }
            // Also check for 'local' for backwards compatibility
            else if (node.local && node.local.length === 16) {
                result = this.CK.M44.multiply(result, node.local);
            }
            // Check for translation2d
            // Row-major format: translation in column 4 (positions 3, 7, 11)
            else if (node.translation2d && node.translation2d.length === 2) {
                const tx = node.translation2d[0];
                const ty = node.translation2d[1];
                const translateMatrix = [
                    1, 0, 0, tx,
                    0, 1, 0, ty,
                    0, 0, 1, 0,
                    0, 0, 0, 1
                ];
                result = this.CK.M44.multiply(result, translateMatrix);
            }
        }
        return result;
    }

    getEffect(index) {
        return this.effectNodes.get(index) || { opacity: 1.0, blend_mode: 'SrcOver' };
    }

    getClip(index) {
        return this.clipNodes.get(index) || null;
    }
}

// ============================================
// Paint Op Renderer - Interprets paint operations
// ============================================

class PaintOpRenderer {
    constructor(canvasKit, fontMgr) {
        this.ck = canvasKit;
        this.fontMgr = fontMgr;
        this.debug = false;
        this.opLog = [];
    }

    log(msg) {
        this.opLog.push(msg);
    }

    // Render a list of paint operations to the canvas
    renderOps(canvas, ops) {
        if (!ops) return;

        for (const op of ops) {
            this.renderOp(canvas, op);
        }
    }

    renderOp(canvas, op) {
        if (!op || !op.type) return;

        switch (op.type) {
            case 'SaveOp':
                canvas.save();
                break;

            case 'RestoreOp':
                canvas.restore();
                break;

            case 'TranslateOp':
                canvas.translate(op.dx || 0, op.dy || 0);
                if (this.debug) this.log(`Translate(${op.dx}, ${op.dy})`);
                break;

            case 'ScaleOp':
                canvas.scale(op.sx || 1, op.sy || 1);
                if (this.debug) this.log(`Scale(${op.sx}, ${op.sy})`);
                break;

            case 'RotateOp':
                canvas.rotate(op.degrees || 0, 0, 0);
                if (this.debug) this.log(`Rotate(${op.degrees})`);
                break;

            case 'ConcatOp':
            case 'SetMatrixOp':
                if (op.matrix && op.matrix.length === 16) {
                    canvas.concat(op.matrix);
                    if (this.debug) {
                        this.log(`${op.type} matrix`);
                    }
                }
                break;

            case 'ClipRectOp':
                if (op.rect && op.rect.length === 4) {
                    const rect = this.ck.LTRBRect(op.rect[0], op.rect[1], op.rect[2], op.rect[3]);
                    canvas.clipRect(rect, this.ck.ClipOp.Intersect, op.antiAlias !== false);
                }
                break;

            case 'ClipRRectOp':
                if (op.rect && op.radii) {
                    const rect = this.ck.LTRBRect(op.rect[0], op.rect[1], op.rect[2], op.rect[3]);
                    const rrect = this.ck.RRectXY(rect, op.radii[0] || 0, op.radii[1] || 0);
                    canvas.clipRRect(rrect, this.ck.ClipOp.Intersect, op.antiAlias !== false);
                }
                break;

            case 'ClipPathOp':
                if (op.path) {
                    const path = this.ck.Path.MakeFromSVGString(op.path);
                    if (path) {
                        canvas.clipPath(path, this.ck.ClipOp.Intersect, op.antiAlias !== false);
                        path.delete();
                    }
                }
                break;

            case 'DrawRectOp':
                this.drawRect(canvas, op);
                break;

            case 'DrawRRectOp':
                this.drawRRect(canvas, op);
                break;

            case 'DrawColorOp':
                if (op.r !== undefined) {
                    const color = this.ck.Color4f(op.r, op.g, op.b, op.a || 1);
                    canvas.drawColorInt(color, this.ck.BlendMode.SrcOver);
                }
                break;

            case 'DrawTextBlobOp':
                this.drawTextBlob(canvas, op);
                break;

            case 'DrawRecordOp':
                if (op.record && Array.isArray(op.record)) {
                    this.renderOps(canvas, op.record);
                }
                break;

            case 'DrawPathOp':
                this.drawPath(canvas, op);
                break;

            case 'DrawImageRectOp':
                if (this.debug) this.log('DrawImageRectOp (skipped - no image data)');
                break;

            case 'SaveLayerOp':
                this.saveLayer(canvas, op);
                break;

            case 'SaveLayerAlphaOp':
                {
                    const paint = new this.ck.Paint();
                    paint.setAlphaf(op.alpha !== undefined ? op.alpha : 1);

                    if (op.bounds && op.bounds.length === 4) {
                        const bounds = this.ck.LTRBRect(op.bounds[0], op.bounds[1], op.bounds[2], op.bounds[3]);
                        canvas.saveLayer(paint, bounds);
                    } else {
                        canvas.saveLayer(paint);
                    }
                    paint.delete();
                }
                if (this.debug) this.log(`SaveLayerAlpha(alpha=${op.alpha})`);
                break;

            case 'NoopOp':
                break;

            default:
                if (this.debug) this.log(`Unknown op: ${op.type}`);
        }
    }

    drawRect(canvas, op) {
        if (!op.rect || op.rect.length !== 4) return;

        const paint = new this.ck.Paint();
        paint.setAntiAlias(true);

        if (op.flags && op.flags.shaderType && op.flags.gradientColors) {
            const colors = op.flags.gradientColors.map(c =>
                this.ck.Color4f(c.r || 0, c.g || 0, c.b || 0, c.a || 1)
            );
            const positions = op.flags.gradientPositions || null;

            if (op.flags.shaderType === 'kLinearGradient' || op.flags.shaderType === 'LinearGradient') {
                const startPt = op.flags.startPoint || [0, 0];
                const endPt = op.flags.endPoint || [op.rect[2] - op.rect[0], op.rect[3] - op.rect[1]];
                const shader = this.ck.Shader.MakeLinearGradient(
                    startPt, endPt, colors, positions, this.ck.TileMode.Clamp
                );
                paint.setShader(shader);
            } else if (op.flags.shaderType === 'kRadialGradient' || op.flags.shaderType === 'RadialGradient') {
                const center = op.flags.center || [
                    (op.rect[0] + op.rect[2]) / 2,
                    (op.rect[1] + op.rect[3]) / 2
                ];
                const radius = op.flags.radius || Math.max(
                    op.rect[2] - op.rect[0],
                    op.rect[3] - op.rect[1]
                ) / 2;
                const shader = this.ck.Shader.MakeRadialGradient(
                    center, radius, colors, positions, this.ck.TileMode.Clamp
                );
                paint.setShader(shader);
            }
        } else if (op.flags) {
            const c = op.flags;
            paint.setColor(this.ck.Color4f(c.r || 0, c.g || 0, c.b || 0, c.a || 1));
        } else {
            paint.setColor(this.ck.Color4f(0.5, 0.5, 0.5, 1));
        }

        paint.setStyle(this.ck.PaintStyle.Fill);

        const rect = this.ck.LTRBRect(op.rect[0], op.rect[1], op.rect[2], op.rect[3]);
        canvas.drawRect(rect, paint);

        if (this.debug) {
            const shaderInfo = op.flags?.shaderType ? ` shader=${op.flags.shaderType}` : '';
            this.log(`DrawRect [${op.rect.join(', ')}]${shaderInfo}`);
        }

        paint.delete();
    }

    drawRRect(canvas, op) {
        if (!op.rect) return;

        const paint = new this.ck.Paint();
        paint.setAntiAlias(true);

        if (op.flags && op.flags.shaderType && op.flags.gradientColors) {
            const colors = op.flags.gradientColors.map(c =>
                this.ck.Color4f(c.r || 0, c.g || 0, c.b || 0, c.a || 1)
            );
            const positions = op.flags.gradientPositions || null;

            if (op.flags.shaderType === 'kLinearGradient' || op.flags.shaderType === 'LinearGradient') {
                const startPt = op.flags.startPoint || [op.rect[0], op.rect[1]];
                const endPt = op.flags.endPoint || [op.rect[2], op.rect[3]];
                const shader = this.ck.Shader.MakeLinearGradient(
                    startPt, endPt, colors, positions, this.ck.TileMode.Clamp
                );
                paint.setShader(shader);
            } else if (op.flags.shaderType === 'kRadialGradient' || op.flags.shaderType === 'RadialGradient') {
                const center = op.flags.center || [
                    (op.rect[0] + op.rect[2]) / 2,
                    (op.rect[1] + op.rect[3]) / 2
                ];
                const radius = op.flags.radius || Math.max(
                    op.rect[2] - op.rect[0],
                    op.rect[3] - op.rect[1]
                ) / 2;
                const shader = this.ck.Shader.MakeRadialGradient(
                    center, radius, colors, positions, this.ck.TileMode.Clamp
                );
                paint.setShader(shader);
            }
        } else if (op.flags) {
            const c = op.flags;
            paint.setColor(this.ck.Color4f(c.r || 0, c.g || 0, c.b || 0, c.a || 1));

            if (c.style === 1) {
                paint.setStyle(this.ck.PaintStyle.Stroke);
                paint.setStrokeWidth(c.strokeWidth || 1);
            } else {
                paint.setStyle(this.ck.PaintStyle.Fill);
            }
        } else {
            paint.setStyle(this.ck.PaintStyle.Fill);
        }

        const rect = this.ck.LTRBRect(op.rect[0], op.rect[1], op.rect[2], op.rect[3]);
        const rx = op.radii ? op.radii[0] : 0;
        const ry = op.radii ? op.radii[1] : 0;
        const rrect = this.ck.RRectXY(rect, rx, ry);
        canvas.drawRRect(rrect, paint);

        if (this.debug && op.flags?.shaderType) {
            this.log(`DrawRRect [${op.rect.join(', ')}] shader=${op.flags.shaderType}`);
        }

        paint.delete();
    }

    drawPath(canvas, op) {
        if (!op.path) {
            if (this.debug) this.log('DrawPathOp (skipped - no path data)');
            return;
        }

        const path = this.ck.Path.MakeFromSVGString(op.path);
        if (!path) return;

        if (op.fillType !== undefined) {
            const fillTypes = [
                this.ck.FillType.Winding,
                this.ck.FillType.EvenOdd,
                this.ck.FillType.InverseWinding,
                this.ck.FillType.InverseEvenOdd
            ];
            if (fillTypes[op.fillType]) {
                path.setFillType(fillTypes[op.fillType]);
            }
        }

        const paint = new this.ck.Paint();
        if (op.flags) {
            const r = op.flags.r !== undefined ? op.flags.r : 0;
            const g = op.flags.g !== undefined ? op.flags.g : 0;
            const b = op.flags.b !== undefined ? op.flags.b : 0;
            const a = op.flags.a !== undefined ? op.flags.a : 1;
            paint.setColor(this.ck.Color4f(r, g, b, a));

            if (op.flags.style === 1) {
                paint.setStyle(this.ck.PaintStyle.Stroke);
            } else {
                paint.setStyle(this.ck.PaintStyle.Fill);
            }
            if (op.flags.strokeWidth !== undefined) {
                paint.setStrokeWidth(op.flags.strokeWidth);
            }
        }
        paint.setAntiAlias(true);
        canvas.drawPath(path, paint);
        paint.delete();
        path.delete();

        if (this.debug) this.log(`DrawPath(fillType=${op.fillType})`);
    }

    saveLayer(canvas, op) {
        const paint = new this.ck.Paint();
        paint.setAntiAlias(true);

        if (op.flags) {
            const c = op.flags;
            if (c.a !== undefined) {
                paint.setAlphaf(c.a);
            }

            if (c.imageFilter) {
                const filter = c.imageFilter;
                if (filter.filterName === 'blur' && filter.sigmaX !== undefined) {
                    const blurFilter = this.ck.ImageFilter.MakeBlur(
                        filter.sigmaX,
                        filter.sigmaY || filter.sigmaX,
                        this.ck.TileMode.Clamp,
                        null
                    );
                    paint.setImageFilter(blurFilter);
                } else if (filter.filterName === 'dropShadow' && filter.shadowColor) {
                    const sc = filter.shadowColor;
                    const shadowColor = this.ck.Color4f(sc.r || 0, sc.g || 0, sc.b || 0, sc.a || 1);
                    const dropShadowFilter = this.ck.ImageFilter.MakeDropShadow(
                        filter.dx || 0,
                        filter.dy || 0,
                        filter.sigmaX || 0,
                        filter.sigmaY || filter.sigmaX || 0,
                        shadowColor,
                        null
                    );
                    paint.setImageFilter(dropShadowFilter);
                }
            }
        }

        if (op.bounds && op.bounds.length === 4) {
            const bounds = this.ck.LTRBRect(op.bounds[0], op.bounds[1], op.bounds[2], op.bounds[3]);
            canvas.saveLayer(paint, bounds);
        } else {
            canvas.saveLayer(paint);
        }
        paint.delete();
    }

    drawTextBlob(canvas, op) {
        // New format: runs array with glyphs, positions, and font info
        if (op.runs && op.runs.length > 0) {
            this.drawTextBlobWithRuns(canvas, op);
            return;
        }

        // Fallback for old format without glyph data
        if (this.debug) this.log(`DrawTextBlobOp at (${op.x}, ${op.y}) - no glyph data`);
    }

    drawTextBlobWithRuns(canvas, op) {
        const paint = new this.ck.Paint();
        paint.setAntiAlias(true);

        // Get text color from flags
        if (op.flags) {
            const c = op.flags;
            paint.setColor(this.ck.Color4f(c.r || 0, c.g || 0, c.b || 0, c.a || 1));
        } else {
            paint.setColor(this.ck.BLACK);
        }

        // Positioning type constants from Skia
        const POSITIONING_DEFAULT = 0;    // No positions, uses font metrics
        const POSITIONING_HORIZONTAL = 1; // X positions only
        const POSITIONING_FULL = 2;       // X,Y positions
        const POSITIONING_RSXFORM = 3;    // RSXform (4 values per glyph)

        for (const run of op.runs) {
            if (!run.glyphs || run.glyphCount <= 0) continue;

            const glyphCount = run.glyphCount;
            const positioning = run.positioning !== undefined ? run.positioning : POSITIONING_FULL;

            // Get font info from the run
            const fontInfo = run.font || {};
            const fontSize = fontInfo.size || 16;
            const fontWeight = fontInfo.weight || 400;

            // Create font with correct size for this run
            const font = new window.CanvasKit.Font(window.typeface, fontSize);

            // Enable antialiasing and subpixel rendering for better text quality
            font.setHinting(window.CanvasKit.FontHinting.Normal);
            font.setSubpixel(true);
            font.setEdging(window.CanvasKit.FontEdging.SubpixelAntiAlias);

            // Simulate bold text if weight >= 600
            if (fontWeight >= 600 || fontInfo.embolden) {
                font.setEmbolden(true);
            }

            // Convert glyph IDs to Uint16Array
            const glyphs = new Uint16Array(glyphCount);
            for (let i = 0; i < glyphCount && i < run.glyphs.length; i++) {
                glyphs[i] = run.glyphs[i];
            }

            // Build RSXform array based on positioning type
            const rsxforms = new Float32Array(glyphCount * 4);

            if (positioning === POSITIONING_RSXFORM && run.rsxforms) {
                // RSXform positioning - use the provided transforms directly
                for (let i = 0; i < glyphCount && i < run.rsxforms.length; i++) {
                    const xf = run.rsxforms[i];
                    rsxforms[i * 4]     = xf.scos || 1.0;
                    rsxforms[i * 4 + 1] = xf.ssin || 0.0;
                    rsxforms[i * 4 + 2] = xf.tx || 0;
                    rsxforms[i * 4 + 3] = xf.ty || 0;
                }
            } else if (positioning === POSITIONING_FULL && run.positions) {
                // Full positioning - x,y pairs
                for (let i = 0; i < glyphCount && i < run.positions.length; i++) {
                    const pos = run.positions[i];
                    rsxforms[i * 4]     = 1.0;
                    rsxforms[i * 4 + 1] = 0.0;
                    rsxforms[i * 4 + 2] = pos.x || 0;
                    rsxforms[i * 4 + 3] = pos.y || 0;
                }
            } else if (positioning === POSITIONING_HORIZONTAL && run.positions) {
                // Horizontal positioning - x values only, y=0 relative to baseline
                // The baseline (offsetY) is already included in the draw position
                for (let i = 0; i < glyphCount && i < run.positions.length; i++) {
                    // run.positions[i] is just a number (x value) for horizontal positioning
                    rsxforms[i * 4]     = 1.0;
                    rsxforms[i * 4 + 1] = 0.0;
                    rsxforms[i * 4 + 2] = run.positions[i] || 0;
                    rsxforms[i * 4 + 3] = 0;  // y is always 0 for horizontal runs
                }
                if (this.debug) {
                    this.log(`  -> Horizontal positioning: ${glyphCount} glyphs with x-only positions`);
                }
            } else {
                // Default positioning or no position data - place at origin
                for (let i = 0; i < glyphCount; i++) {
                    rsxforms[i * 4]     = 1.0;
                    rsxforms[i * 4 + 1] = 0.0;
                    rsxforms[i * 4 + 2] = 0;
                    rsxforms[i * 4 + 3] = 0;
                }
            }

            // Create TextBlob from RSXform glyphs and draw it
            // For horizontal runs, we add offsetY to the draw position
            const blob = CanvasKit.TextBlob.MakeFromRSXformGlyphs(glyphs, rsxforms, font);
            if (blob) {
                const drawX = (op.x || 0) + (run.offsetX || 0);
                const drawY = (op.y || 0) + (run.offsetY || 0);
                canvas.drawTextBlob(blob, drawX, drawY, paint);
                blob.delete();
            }

            if (this.debug) {
                const family = fontInfo.family || 'unknown';
                const posType = ['default', 'horizontal', 'full', 'rsxform'][positioning] || 'unknown';
                this.log(`DrawTextBlob at (${op.x}, ${op.y}): ${glyphCount} glyphs, ${fontSize}px ${family}, positioning=${posType}`);
            }

            font.delete();
        }

        paint.delete();
    }
}

// ============================================
// Paint Artifact Compositor (renders raw PaintChunks)
// ============================================

class PaintArtifactCompositor {
    constructor(canvasKit, surface, fontMgr) {
        this.ck = canvasKit;
        this.surface = surface;
        this.renderer = new PaintOpRenderer(canvasKit, fontMgr);
        this.showBounds = false;
        this.debug = false;
    }

    drawFrame(chunks, trees) {
        const canvas = this.surface.getCanvas();
        canvas.clear(this.ck.WHITE);

        this.renderer.debug = this.debug;
        this.renderer.opLog = [];

        // Sort chunks by chunk_id to ensure correct drawing order
        const sortedChunks = [...chunks].sort((a, b) => a.chunk_id - b.chunk_id);

        for (const chunk of sortedChunks) {
            this.compositeChunk(canvas, chunk, trees);
        }

        this.surface.flush();
        return this.renderer.opLog;
    }

    compositeChunk(canvas, chunk, trees) {
        canvas.save();

        // Get transform from property tree state
        const transformId = chunk.property_tree_state?.transform_id;
        if (transformId !== undefined) {
            const chunkMatrix = trees.getTransformMatrix(transformId);
            canvas.concat(chunkMatrix);

            // Debug: log transforms for chunks with non-trivial transforms
            if (transformId > 6) {
                console.log(`Chunk ${chunk.chunk_id}: transform_id=${transformId}, bounds=${JSON.stringify(chunk.bounds)}, matrix=`, chunkMatrix);
            }
        }

        // Apply effect opacity
        const effectId = chunk.property_tree_state?.effect_id;
        const effect = effectId !== undefined ? trees.getEffect(effectId) : { opacity: 1.0 };
        const alpha = effect.opacity !== undefined ? effect.opacity : 1.0;

        // Debug: log opacity for chunks with non-1.0 opacity
        if (alpha < 1.0) {
            console.log(`Chunk ${chunk.chunk_id}: effect_id=${effectId}, opacity=${alpha}, bounds=${JSON.stringify(chunk.bounds)}`);
        }

        if (alpha < 1.0) {
            const layerPaint = new this.ck.Paint();
            layerPaint.setAlphaf(alpha);
            canvas.saveLayer(layerPaint);
            layerPaint.delete();
        }

        // Render paint operations
        if (chunk.paint_ops && chunk.paint_ops.length > 0) {
            this.renderer.renderOps(canvas, chunk.paint_ops);
        }

        if (alpha < 1.0) {
            canvas.restore();
        }

        // Draw bounds overlay if enabled
        if (this.showBounds && chunk.bounds) {
            const paint = new this.ck.Paint();
            // Use different colors for different chunks
            const hue = (chunk.chunk_id * 37) % 360;
            const color = this.hslToRgb(hue / 360, 0.7, 0.5);
            paint.setColor(this.ck.Color4f(color[0], color[1], color[2], 0.2));
            paint.setStyle(this.ck.PaintStyle.Fill);

            // bounds is [x, y, width, height] from the serializer
            const rect = this.ck.XYWHRect(
                chunk.bounds[0], chunk.bounds[1],
                chunk.bounds[2], chunk.bounds[3]
            );
            canvas.drawRect(rect, paint);

            // Draw border
            paint.setStyle(this.ck.PaintStyle.Stroke);
            paint.setStrokeWidth(1);
            paint.setColor(this.ck.Color4f(color[0], color[1], color[2], 0.8));
            canvas.drawRect(rect, paint);

            paint.delete();
        }

        canvas.restore();
    }

    // Helper: HSL to RGB
    hslToRgb(h, s, l) {
        let r, g, b;
        if (s === 0) {
            r = g = b = l;
        } else {
            const hue2rgb = (p, q, t) => {
                if (t < 0) t += 1;
                if (t > 1) t -= 1;
                if (t < 1/6) return p + (q - p) * 6 * t;
                if (t < 1/2) return q;
                if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                return p;
            };
            const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
            const p = 2 * l - q;
            r = hue2rgb(p, q, h + 1/3);
            g = hue2rgb(p, q, h);
            b = hue2rgb(p, q, h - 1/3);
        }
        return [r, g, b];
    }
}

// ============================================
// Main
// ============================================

async function main() {
    const statusEl = document.getElementById('status');
    const layerListEl = document.getElementById('layerList');

    try {
        // 1. Initialize CanvasKit
        const CanvasKit = await CanvasKitInit({
            locateFile: (file) => `https://unpkg.com/canvaskit-wasm@0.39.1/bin/${file}`,
        });
        statusEl.textContent = "CanvasKit loaded. Fetching paint artifact data...";

        // 2. Fetch Paint Artifact Data (pre-layerization)
        const [artifactRes, treeRes] = await Promise.all([
            fetch('paint_artifact.json'),
            fetch('paint_artifact_property_trees.json')
        ]);

        if (!artifactRes.ok || !treeRes.ok) {
            throw new Error(`HTTP Error: Artifact(${artifactRes.status}) Trees(${treeRes.status})`);
        }

        const artifactData = await artifactRes.json();
        const treesData = await treeRes.json();

        statusEl.textContent = "Paint artifact data loaded. Setting up canvas...";

        // 3. Setup Surface
        const canvasEl = document.getElementById('skcanvas');

        // Resize canvas based on chunk bounds (accounting for transforms)
        const chunks = artifactData["PaintChunks"] || [];

        // First pass: simple bounds
        let maxW = 320, maxH = 148;
        for (const chunk of chunks) {
            if (chunk.bounds && chunk.bounds.length === 4) {
                // bounds is [x, y, width, height] (XYWH format from serializer)
                const right = chunk.bounds[0] + chunk.bounds[2];
                const bottom = chunk.bounds[1] + chunk.bounds[3];
                maxW = Math.max(maxW, right);
                maxH = Math.max(maxH, bottom);
            }
        }

        // Second pass: account for translations in transform tree
        // For chunks with transforms, add the translation offset to their bounds
        const transformNodes = new Map();
        if (treesData.transform_tree && treesData.transform_tree.nodes) {
            treesData.transform_tree.nodes.forEach(n => transformNodes.set(n.id, n));
        }

        function getTranslation(nodeId) {
            let tx = 0, ty = 0;
            let currentId = nodeId;
            while (currentId !== -1 && transformNodes.has(currentId)) {
                const node = transformNodes.get(currentId);
                if (node.translation2d && node.translation2d.length === 2) {
                    tx += node.translation2d[0];
                    ty += node.translation2d[1];
                }
                currentId = node.parent_id;
            }
            return { tx, ty };
        }

        for (const chunk of chunks) {
            if (chunk.bounds && chunk.bounds.length === 4) {
                const transformId = chunk.property_tree_state?.transform_id;
                if (transformId !== undefined) {
                    const { tx, ty } = getTranslation(transformId);
                    const right = chunk.bounds[0] + chunk.bounds[2] + tx;
                    const bottom = chunk.bounds[1] + chunk.bounds[3] + ty;
                    maxW = Math.max(maxW, right);
                    maxH = Math.max(maxH, bottom);
                }
            }
        }

        console.log(`Canvas size: ${maxW}x${maxH}`);
        canvasEl.width = Math.min(maxW + 100, 3000);  // Add some padding
        canvasEl.height = Math.min(maxH + 100, 25000);

        // Load font
        const fontResp = await fetch("Arial.ttf");
        const fontData = await fontResp.arrayBuffer();
        const typeface = CanvasKit.Typeface.MakeFreeTypeFaceFromData(fontData);

        if (!typeface) {
          console.error("Failed to load typeface");
          statusEl.innerHTML = `<span class="error">Failed to load Arial.ttf font file</span>`;
          return;
        }

        // Store typeface globally
        window.typeface = typeface;
        window.CanvasKit = CanvasKit;

        const surface = CanvasKit.MakeCanvasSurface('skcanvas');
        if (!surface) throw new Error("Could not create Skia surface");

        // 4. Initialize compositor with property trees
        const propertyTrees = new PropertyTrees(treesData, CanvasKit);
        const compositor = new PaintArtifactCompositor(CanvasKit, surface, null);

        // 5. Render function
        const redraw = () => {
            compositor.showBounds = document.getElementById('chkBounds').checked;
            compositor.debug = document.getElementById('chkDebug').checked;

            const log = compositor.drawFrame(chunks, propertyTrees);

            // Show chunk info
            // Summary of chunks with special properties
            const chunksWithOpacity = chunks.filter(c => {
                const effectId = c.property_tree_state?.effect_id;
                const effect = propertyTrees.getEffect(effectId);
                return effect && effect.opacity < 1.0;
            });
            const chunksWithTransform = chunks.filter(c => {
                const tid = c.property_tree_state?.transform_id;
                return tid !== undefined && tid > 5; // Non-trivial transform
            });

            let chunkInfo = `Total PaintChunks: ${chunks.length} (before layerization)\n`;
            chunkInfo += `Chunks with opacity < 1.0: ${chunksWithOpacity.length}\n`;
            chunkInfo += `Chunks with transforms (id > 5): ${chunksWithTransform.length}\n\n`;

            // Show chunks with opacity
            if (chunksWithOpacity.length > 0) {
                chunkInfo += `--- Chunks with Opacity Effects ---\n`;
                for (const chunk of chunksWithOpacity) {
                    const effectId = chunk.property_tree_state?.effect_id;
                    const effect = propertyTrees.getEffect(effectId);
                    chunkInfo += `  Chunk ${chunk.chunk_id}: effect_id=${effectId}, opacity=${effect?.opacity}\n`;
                }
                chunkInfo += `\n`;
            }

            // Show chunks with transforms
            if (chunksWithTransform.length > 0) {
                chunkInfo += `--- Chunks with Transforms ---\n`;
                for (const chunk of chunksWithTransform.slice(0, 10)) {
                    const tid = chunk.property_tree_state?.transform_id;
                    chunkInfo += `  Chunk ${chunk.chunk_id}: transform_id=${tid}, bounds=${JSON.stringify(chunk.bounds)}\n`;
                }
                if (chunksWithTransform.length > 10) {
                    chunkInfo += `  ... and ${chunksWithTransform.length - 10} more\n`;
                }
                chunkInfo += `\n`;
            }

            chunkInfo += `--- All Chunks ---\n`;
            for (const chunk of chunks) {
                const opCount = chunk.paint_ops ? chunk.paint_ops.length : 0;
                const boundsStr = chunk.bounds
                    ? `[${chunk.bounds[0]}, ${chunk.bounds[1]}, ${chunk.bounds[2]}, ${chunk.bounds[3]}]`
                    : 'N/A';
                chunkInfo += `Chunk ${chunk.chunk_id}: "${chunk.debug_name || 'unnamed'}"\n`;
                chunkInfo += `  bounds: ${boundsStr}\n`;
                chunkInfo += `  paint_ops: ${opCount}\n`;
                chunkInfo += `  transform_id: ${chunk.property_tree_state?.transform_id}, `;
                chunkInfo += `effect_id: ${chunk.property_tree_state?.effect_id}, `;
                chunkInfo += `clip_id: ${chunk.property_tree_state?.clip_id}\n\n`;
            }

            if (log.length > 0) {
                chunkInfo += `\nDebug log:\n${log.join('\n')}`;
            }

            layerListEl.textContent = chunkInfo;
        };

        redraw();
        statusEl.textContent = `Rendered ${chunks.length} PaintChunks successfully (pre-layerization data).`;

        // 6. Bind controls
        document.querySelectorAll('input').forEach(el => {
            el.addEventListener('change', redraw);
        });

    } catch (e) {
        console.error(e);
        statusEl.innerHTML = `<span class="error">${e.message}</span><br><br>Make sure <b>paint_artifact.json</b> and <b>paint_artifact_property_trees.json</b> exist in the same folder.`;
    }
}

main();

</script>
</body>
</html>
