<!DOCTYPE html>
<html>
<head>
  <title>Skia Commands Viewer</title>
  <script src="https://unpkg.com/canvaskit-wasm@0.39.1/bin/canvaskit.js"></script>
  <style>
    body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif; display: flex; flex-direction: column; align-items: center; padding: 20px; background: #f0f2f5; margin: 0; }
    h2 { color: #1a1a1a; margin-bottom: 20px; }
    .controls { display: flex; gap: 20px; margin-bottom: 20px; background: white; padding: 15px 20px; border-radius: 8px; box-shadow: 0 1px 3px rgba(0,0,0,0.1); align-items: center; flex-wrap: wrap; }
    .control-group { display: flex; align-items: center; gap: 8px; }
    .control-group label { font-weight: 500; color: #555; }
    select, input[type="number"] { padding: 6px 10px; border: 1px solid #ddd; border-radius: 4px; font-size: 14px; }
    input[type="range"] { width: 200px; }
    button { padding: 8px 16px; background: #4285f4; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 14px; }
    button:hover { background: #3367d6; }
    #canvas-container { box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1); border-radius: 8px; overflow: auto; background: white; max-width: 95vw; max-height: 70vh; }
    canvas { display: block; }
    .info { margin-top: 20px; background: white; padding: 20px; border-radius: 8px; font-size: 13px; width: 100%; max-width: 800px; box-shadow: 0 1px 3px rgba(0,0,0,0.1); }
    pre { background: #f8f9fa; padding: 10px; border-radius: 4px; overflow-x: auto; max-height: 400px; overflow-y: auto; }
    .error { color: #d32f2f; background: #ffebee; padding: 10px; border-radius: 4px; }
    .cmd-count { font-weight: bold; min-width: 60px; }
  </style>
</head>
<body>
  <h2>Skia Commands Viewer</h2>

  <div class="controls">
    <div class="control-group">
      <label for="frame-select">Frame:</label>
      <select id="frame-select"></select>
    </div>
    <div class="control-group">
      <label for="cmd-slider">Commands:</label>
      <input type="range" id="cmd-slider" min="0" max="100" value="100">
      <span id="cmd-count" class="cmd-count">0 / 0</span>
    </div>
    <div class="control-group">
      <input type="number" id="cmd-input" min="0" max="100" value="100" style="width: 80px;">
      <button id="render-btn">Render</button>
    </div>
    <div class="control-group">
      <button id="play-btn">Play</button>
      <label for="speed-input">Speed (ms):</label>
      <input type="number" id="speed-input" min="10" max="2000" value="100" style="width: 70px;">
    </div>
  </div>

  <div id="canvas-container">
    <canvas id="skcanvas" width="1200" height="840"></canvas>
  </div>
  <div class="info">
    <h3>Status</h3>
    <pre id="status">Initializing CanvasKit...</pre>
  </div>

<script type="module">

class SkiaCommandRenderer {
  constructor(canvasKit) {
    this.ck = canvasKit;
    this.mergedMode = false;  // When true, negate translates for proper tile positioning
  }

  // Calculate bounds from commands by finding max clipRect values
  calculateBounds(commands) {
    let maxX = 0, maxY = 0;

    // Find the maximum extent of all clipRects
    // For merged tiles, this gives us the full composite size
    for (const cmd of commands) {
      if (cmd.type === 'clipRect' && cmd.rect && cmd.rect.length === 4) {
        maxX = Math.max(maxX, cmd.rect[2]);
        maxY = Math.max(maxY, cmd.rect[3]);
      }
    }

    // Fallback to reasonable defaults
    if (maxX === 0) maxX = 1200;
    if (maxY === 0) maxY = 840;

    return { width: Math.ceil(maxX), height: Math.ceil(maxY) };
  }

  // Convert color object to CanvasKit color
  toColor(c) {
    if (!c) return this.ck.BLACK;
    return this.ck.Color4f(c.r || 0, c.g || 0, c.b || 0, c.a || 1);
  }

  // Create paint from command's paint object
  createPaint(p) {
    const paint = new this.ck.Paint();
    if (!p) return paint;

    paint.setAntiAlias(p.antiAlias || false);
    paint.setColor(this.toColor(p.color));

    if (p.alpha !== undefined) {
      paint.setAlphaf(p.alpha);
    }

    // Style: 0 = Fill, 1 = Stroke, 2 = StrokeAndFill
    if (p.style === 1) {
      paint.setStyle(this.ck.PaintStyle.Stroke);
      paint.setStrokeWidth(p.strokeWidth || 1);
    } else {
      paint.setStyle(this.ck.PaintStyle.Fill);
    }

    // Blend mode
    if (p.blendMode !== undefined) {
      const blendModes = [
        this.ck.BlendMode.Clear,      // 0
        this.ck.BlendMode.Src,        // 1
        this.ck.BlendMode.Dst,        // 2
        this.ck.BlendMode.SrcOver,    // 3
        this.ck.BlendMode.DstOver,    // 4
        this.ck.BlendMode.SrcIn,      // 5
        this.ck.BlendMode.DstIn,      // 6
        this.ck.BlendMode.SrcOut,     // 7
        this.ck.BlendMode.DstOut,     // 8
        this.ck.BlendMode.SrcATop,    // 9
        this.ck.BlendMode.DstATop,    // 10
        this.ck.BlendMode.Xor,        // 11
        this.ck.BlendMode.Plus,       // 12
        this.ck.BlendMode.Modulate,   // 13
      ];
      if (blendModes[p.blendMode]) {
        paint.setBlendMode(blendModes[p.blendMode]);
      }
    }

    // Stroke cap: 0 = Butt, 1 = Round, 2 = Square
    if (p.strokeCap === 1) {
      paint.setStrokeCap(this.ck.StrokeCap.Round);
    } else if (p.strokeCap === 2) {
      paint.setStrokeCap(this.ck.StrokeCap.Square);
    }

    return paint;
  }

  renderCommand(canvas, cmd) {
    switch (cmd.type) {
      case 'save':
        canvas.save();
        break;

      case 'restore':
        canvas.restore();
        break;

      case 'translate':
        {
          let dx = cmd.dx || 0;
          let dy = cmd.dy || 0;
          // In merged mode, negate translates to position tiles at their world coordinates
          // The original translates were negative to map world->local, we need local->world
          if (this.mergedMode) {
            dx = -dx;
            dy = -dy;
          }
          canvas.translate(dx, dy);
        }
        break;

      case 'scale':
        canvas.scale(cmd.sx || 1, cmd.sy || 1);
        break;

      case 'concat44':
        if (cmd.matrix && cmd.matrix.length === 16) {
          canvas.concat(cmd.matrix);
        }
        break;

      case 'clipRect':
        if (cmd.rect && cmd.rect.length === 4) {
          const rect = this.ck.LTRBRect(cmd.rect[0], cmd.rect[1], cmd.rect[2], cmd.rect[3]);
          const clipOp = cmd.clipOp === 0 ? this.ck.ClipOp.Difference : this.ck.ClipOp.Intersect;
          canvas.clipRect(rect, clipOp, cmd.antiAlias || false);
        }
        break;

      case 'clipRRect':
        if (cmd.rrect && cmd.rrect.rect) {
          const rect = this.ck.LTRBRect(
            cmd.rrect.rect[0], cmd.rrect.rect[1],
            cmd.rrect.rect[2], cmd.rrect.rect[3]
          );
          // rrect.radii has 8 values: [tlX, tlY, trX, trY, brX, brY, blX, blY]
          // For simplicity, use the first radius pair
          const rx = cmd.rrect.radii ? cmd.rrect.radii[0] : 0;
          const ry = cmd.rrect.radii ? cmd.rrect.radii[1] : 0;
          const rrect = this.ck.RRectXY(rect, rx, ry);
          const clipOp = cmd.clipOp === 0 ? this.ck.ClipOp.Difference : this.ck.ClipOp.Intersect;
          canvas.clipRRect(rrect, clipOp, cmd.antiAlias || false);
        }
        break;

      case 'drawPaint':
        {
          // Skip drawPaint with alpha=0 and Src blend mode (these clear each tile)
          // In merged view, we don't want to clear between tiles
          if (cmd.paint && cmd.paint.alpha === 0 && cmd.paint.blendMode === 1) {
            break;  // Skip this clear operation
          }
          const paint = this.createPaint(cmd.paint);
          canvas.drawPaint(paint);
          paint.delete();
        }
        break;

      case 'drawRect':
        if (cmd.rect && cmd.rect.length === 4) {
          const rect = this.ck.LTRBRect(cmd.rect[0], cmd.rect[1], cmd.rect[2], cmd.rect[3]);
          const paint = this.createPaint(cmd.paint);
          canvas.drawRect(rect, paint);
          paint.delete();
        }
        break;

      case 'drawPath':
        if (cmd.path) {
          const path = this.ck.Path.MakeFromSVGString(cmd.path);
          if (path) {
            // Apply fill type
            if (cmd.fillType !== undefined) {
              const fillTypes = [
                this.ck.FillType.Winding,
                this.ck.FillType.EvenOdd,
                this.ck.FillType.InverseWinding,
                this.ck.FillType.InverseEvenOdd
              ];
              if (fillTypes[cmd.fillType]) {
                path.setFillType(fillTypes[cmd.fillType]);
              }
            }
            const paint = this.createPaint(cmd.paint);
            canvas.drawPath(path, paint);
            paint.delete();
            path.delete();
          }
        }
        break;

      case 'saveLayer':
        {
          const paint = this.createPaint(cmd.paint);
          if (cmd.bounds && cmd.bounds.length === 4) {
            const bounds = this.ck.LTRBRect(cmd.bounds[0], cmd.bounds[1], cmd.bounds[2], cmd.bounds[3]);
            canvas.saveLayer(paint, bounds);
          } else {
            canvas.saveLayer(paint);
          }
          paint.delete();
        }
        break;

      case 'drawRRect':
        if (cmd.rrect && cmd.rrect.rect) {
          const rect = this.ck.LTRBRect(
            cmd.rrect.rect[0], cmd.rrect.rect[1],
            cmd.rrect.rect[2], cmd.rrect.rect[3]
          );
          // radii has 8 values: [tlX, tlY, trX, trY, brX, brY, blX, blY]
          // Use the first radius pair for simplicity (uniform corners)
          const rx = cmd.rrect.radii ? cmd.rrect.radii[0] : 0;
          const ry = cmd.rrect.radii ? cmd.rrect.radii[1] : 0;
          const rrect = this.ck.RRectXY(rect, rx, ry);
          const paint = this.createPaint(cmd.paint);
          canvas.drawRRect(rrect, paint);
          paint.delete();
        }
        break;

      case 'drawTextBlob':
        // Text blobs don't have serialized text data, so we draw the bounds as a placeholder
        if (cmd.bounds && cmd.bounds.length === 4) {
          const rect = this.ck.LTRBRect(
            cmd.bounds[0] + (cmd.x || 0),
            cmd.bounds[1] + (cmd.y || 0),
            cmd.bounds[2] + (cmd.x || 0),
            cmd.bounds[3] + (cmd.y || 0)
          );
          const paint = this.createPaint(cmd.paint);
          canvas.drawRect(rect, paint);
          paint.delete();
        }
        break;

      case 'clipPath':
        if (cmd.path) {
          const path = this.ck.Path.MakeFromSVGString(cmd.path);
          if (path) {
            // Apply fill type
            if (cmd.fillType !== undefined) {
              const fillTypes = [
                this.ck.FillType.Winding,
                this.ck.FillType.EvenOdd,
                this.ck.FillType.InverseWinding,
                this.ck.FillType.InverseEvenOdd
              ];
              if (fillTypes[cmd.fillType]) {
                path.setFillType(fillTypes[cmd.fillType]);
              }
            }
            const clipOp = cmd.clipOp === 0 ? this.ck.ClipOp.Difference : this.ck.ClipOp.Intersect;
            canvas.clipPath(path, clipOp, cmd.antiAlias || false);
            path.delete();
          }
        }
        break;

      case 'drawImageRect':
        // Skip image drawing - we don't have the image data
        break;

      default:
        console.log(`Unknown command: ${cmd.type}`);
    }
  }

  render(canvas, commands, maxCommands = Infinity, isMerged = false) {
    this.mergedMode = isMerged;
    canvas.clear(this.ck.WHITE);

    const cmdCount = Math.min(commands.length, maxCommands);
    for (let i = 0; i < cmdCount; i++) {
      this.renderCommand(canvas, commands[i]);
    }

    return cmdCount;
  }
}

async function main() {
  const statusEl = document.getElementById('status');
  const frameSelect = document.getElementById('frame-select');
  const cmdSlider = document.getElementById('cmd-slider');
  const cmdInput = document.getElementById('cmd-input');
  const cmdCountEl = document.getElementById('cmd-count');
  const renderBtn = document.getElementById('render-btn');
  const playBtn = document.getElementById('play-btn');
  const speedInput = document.getElementById('speed-input');

  let isPlaying = false;
  let playInterval = null;

  let CanvasKit, surface, renderer, data;
  let currentFrame = null;

  function updateControls() {
    if (!currentFrame) return;
    const max = currentFrame.command_count;
    cmdSlider.max = max;
    cmdSlider.value = max;  // Always full
    cmdInput.max = max;
    cmdInput.value = max;   // Always full
    cmdCountEl.textContent = `${max} / ${max}`;
  }

  function renderCurrentFrame() {
    if (!currentFrame || !renderer || !CanvasKit) return;

    // Calculate bounds for this frame
    const bounds = renderer.calculateBounds(currentFrame.commands);
    const canvasEl = document.getElementById('skcanvas');

    // Resize canvas to fit content
    canvasEl.width = bounds.width;
    canvasEl.height = bounds.height;

    // Fresh reload: recreate surface for each render
    if (surface) {
      surface.delete();
    }
    surface = CanvasKit.MakeCanvasSurface('skcanvas');
    if (!surface) {
      statusEl.innerHTML = '<span class="error">Could not create Skia surface</span>';
      return;
    }

    // Always render full tile (all commands)
    const maxCmds = currentFrame.command_count;
    const canvas = surface.getCanvas();
    // Check if this is a merged frame (contains multiple tiles)
    const isMerged = currentFrame.label && currentFrame.label.toLowerCase().includes('merged');
    const rendered = renderer.render(canvas, currentFrame.commands, maxCmds, isMerged);
    surface.flush();

    // Update status
    const cmdTypes = {};
    const cmds = currentFrame.commands.slice(0, maxCmds);
    for (const cmd of cmds) {
      cmdTypes[cmd.type] = (cmdTypes[cmd.type] || 0) + 1;
    }

    const frameLabel = currentFrame.label || `Frame ${currentFrame.frame}`;
    let summary = `${frameLabel}: Rendered ${rendered} / ${currentFrame.command_count} commands\n`;
    summary += `Canvas size: ${bounds.width} x ${bounds.height}`;
    if (isMerged) summary += ` (merged mode - translates negated)`;
    summary += `\n\n`;
    summary += `Command types:\n`;
    for (const [type, count] of Object.entries(cmdTypes).sort((a, b) => b[1] - a[1])) {
      summary += `  ${type}: ${count}\n`;
    }
    statusEl.textContent = summary;
  }

  try {
    // Initialize CanvasKit
    CanvasKit = await CanvasKitInit({
      locateFile: (file) => `https://unpkg.com/canvaskit-wasm@0.39.1/bin/${file}`,
    });
    statusEl.textContent = "CanvasKit loaded. Fetching skia_commands.json...";

    // Fetch commands
    const response = await fetch('skia_commands.json');
    if (!response.ok) {
      throw new Error(`HTTP Error: ${response.status}`);
    }
    data = await response.json();

    // Handle both old format (single commands array) and new format (frames array)
    let frames;
    if (data.frames) {
      frames = data.frames;
    } else if (data.commands) {
      // Old format - wrap in a single frame
      frames = [{ frame: 0, command_count: data.commands.length, commands: data.commands }];
    } else {
      throw new Error("Invalid JSON format - no frames or commands found");
    }

    statusEl.textContent = `Loaded ${frames.length} frames. Setting up...`;

    // Populate frame selector
    frameSelect.innerHTML = '';
    for (const frame of frames) {
      const opt = document.createElement('option');
      opt.value = frame.frame;
      const label = frame.label || `Frame ${frame.frame}`;
      opt.textContent = `${label} (${frame.command_count} cmds)`;
      frameSelect.appendChild(opt);
    }

    // Setup canvas
    surface = CanvasKit.MakeCanvasSurface('skcanvas');
    if (!surface) throw new Error("Could not create Skia surface");

    renderer = new SkiaCommandRenderer(CanvasKit);

    // Event handlers
    frameSelect.addEventListener('change', () => {
      // Stop auto-play when manually selecting
      if (isPlaying) stopPlayback();

      const frameIdx = parseInt(frameSelect.value, 10);
      currentFrame = frames.find(f => f.frame === frameIdx) || frames[0];
      // Always use full command count
      cmdSlider.value = currentFrame.command_count;
      cmdInput.value = currentFrame.command_count;
      updateControls();
      renderCurrentFrame();
    });

    cmdSlider.addEventListener('input', () => {
      // Always snap to full count
      cmdSlider.value = currentFrame.command_count;
      cmdInput.value = currentFrame.command_count;
      cmdCountEl.textContent = `${currentFrame.command_count} / ${currentFrame.command_count}`;
    });

    cmdSlider.addEventListener('change', () => {
      // Always render full tile
      cmdSlider.value = currentFrame.command_count;
      renderCurrentFrame();
    });

    cmdInput.addEventListener('change', () => {
      // Always use full count
      cmdSlider.value = currentFrame.command_count;
      cmdInput.value = currentFrame.command_count;
      updateControls();
      renderCurrentFrame();
    });

    renderBtn.addEventListener('click', () => {
      // Fresh reload with full tile
      cmdSlider.value = currentFrame.command_count;
      cmdInput.value = currentFrame.command_count;
      updateControls();
      renderCurrentFrame();
    });

    // Auto-play functionality
    function stopPlayback() {
      if (playInterval) {
        clearInterval(playInterval);
        playInterval = null;
      }
      isPlaying = false;
      playBtn.textContent = 'Play';
    }

    function startPlayback() {
      const speed = parseInt(speedInput.value, 10) || 100;
      isPlaying = true;
      playBtn.textContent = 'Stop';

      playInterval = setInterval(() => {
        // Find current frame index and move to next
        const currentIdx = frames.findIndex(f => f.frame === currentFrame.frame);
        const nextIdx = (currentIdx + 1) % frames.length;

        currentFrame = frames[nextIdx];
        frameSelect.value = currentFrame.frame;
        cmdSlider.value = currentFrame.command_count;
        cmdInput.value = currentFrame.command_count;
        updateControls();
        renderCurrentFrame();
      }, speed);
    }

    playBtn.addEventListener('click', () => {
      if (isPlaying) {
        stopPlayback();
      } else {
        startPlayback();
      }
    });

    // Initial render
    currentFrame = frames[0];
    cmdSlider.value = currentFrame.command_count;
    cmdInput.value = currentFrame.command_count;
    updateControls();
    renderCurrentFrame();

  } catch (e) {
    console.error(e);
    statusEl.innerHTML = `<span class="error">${e.message}</span><br><br>Make sure <b>skia_commands.json</b> exists in the same folder.`;
  }
}

main();

</script>
</body>
</html>
