diff --git a/third_party/blink/renderer/core/paint/paint_layer.h b/third_party/blink/renderer/core/paint/paint_layer.h
index 00357e6c40..88fe9317f9 100644
--- a/third_party/blink/renderer/core/paint/paint_layer.h
+++ b/third_party/blink/renderer/core/paint/paint_layer.h
@@ -815,6 +815,7 @@ class CORE_EXPORT PaintLayer : public GarbageCollected<PaintLayer>,
   friend class PaintLayerPaintOrderIterator;
   friend class PaintLayerPaintOrderReverseIterator;
   friend class PaintLayerStackingNode;
+  friend class PaintLayerPainter;
   friend class CheckAncestorPositionVisibilityScope;
 
   FRIEND_TEST_ALL_PREFIXES(PaintLayerTest,
diff --git a/third_party/blink/renderer/core/paint/paint_layer_painter.cc b/third_party/blink/renderer/core/paint/paint_layer_painter.cc
index 317149bc68..211fe172a0 100644
--- a/third_party/blink/renderer/core/paint/paint_layer_painter.cc
+++ b/third_party/blink/renderer/core/paint/paint_layer_painter.cc
@@ -4,8 +4,12 @@
 
 #include "third_party/blink/renderer/core/paint/paint_layer_painter.h"
 
+#include <cstdint>
+#include <functional>
 #include <optional>
+#include <unordered_map>
 
+#include "base/logging.h"
 #include "cc/layers/view_transition_content_layer.h"
 #include "third_party/blink/renderer/core/frame/local_frame.h"
 #include "third_party/blink/renderer/core/frame/local_frame_view.h"
@@ -26,6 +30,16 @@
 #include "third_party/blink/renderer/core/paint/paint_layer.h"
 #include "third_party/blink/renderer/core/paint/paint_layer_paint_order_iterator.h"
 #include "third_party/blink/renderer/core/paint/paint_layer_scrollable_area.h"
+#include "third_party/blink/renderer/core/paint/paint_layer_stacking_node.h"
+#include "third_party/blink/renderer/core/layout/layout_text.h"
+#include "third_party/blink/renderer/core/layout/layout_box.h"
+#include "third_party/blink/renderer/core/layout/inline/fragment_item.h"
+#include "third_party/blink/renderer/core/layout/inline/inline_cursor.h"
+#include "third_party/blink/renderer/core/css/properties/longhands.h"
+#include "third_party/blink/renderer/core/style/shadow_data.h"
+#include "third_party/blink/renderer/core/style/shadow_list.h"
+#include "third_party/blink/renderer/platform/geometry/length_functions.h"
+#include "third_party/blink/renderer/platform/fonts/shaping/shape_result_view.h"
 #include "third_party/blink/renderer/core/paint/scrollable_area_painter.h"
 #include "third_party/blink/renderer/core/paint/svg_mask_painter.h"
 #include "third_party/blink/renderer/core/paint/timing/paint_timing_detector.h"
@@ -33,12 +47,14 @@
 #include "third_party/blink/renderer/platform/graphics/paint/drawing_recorder.h"
 #include "third_party/blink/renderer/platform/graphics/paint/foreign_layer_display_item.h"
 #include "third_party/blink/renderer/platform/graphics/paint/geometry_mapper.h"
+#include "third_party/blink/renderer/platform/graphics/paint/property_tree_serializer.h"
 #include "third_party/blink/renderer/platform/graphics/paint/scoped_display_item_fragment.h"
 #include "third_party/blink/renderer/platform/graphics/paint/scoped_effectively_invisible.h"
 #include "third_party/blink/renderer/platform/graphics/paint/scoped_paint_chunk_properties.h"
 #include "third_party/blink/renderer/platform/graphics/paint/subsequence_recorder.h"
+#include "third_party/blink/renderer/platform/json/json_values.h"
 #include "third_party/blink/renderer/platform/runtime_enabled_features.h"
-#include "third_party/blink/renderer/platform/wtf/casting.h"
+#include "third_party/blink/renderer/platform/wtf/text/string_builder.h"
 #include "ui/gfx/geometry/point3_f.h"
 
 namespace blink {
@@ -141,28 +157,551 @@ scoped_refptr<cc::ViewTransitionContentLayer> GetTransitionScopeSnapshotLayer(
   return nullptr;
 }
 
+// Helper to get a debug name for a LayoutObject
+String GetLayoutObjectDebugName(const LayoutObject& object) {
+  StringBuilder name;
+  name.Append(object.DebugName());
+  if (Node* node = object.GetNode()) {
+    if (Element* element = DynamicTo<Element>(node)) {
+      if (element->HasID()) {
+        name.Append("#");
+        name.Append(element->GetIdAttribute());
+      }
+      if (element->HasClass()) {
+        const SpaceSplitString& classes = element->ClassNames();
+        for (wtf_size_t i = 0; i < classes.size(); ++i) {
+          name.Append(".");
+          name.Append(classes[i]);
+        }
+      }
+    }
+  }
+  return name.ToString();
+}
+
+// Global counters for generating unique IDs during a single logging pass
+static int g_layout_object_id_counter = 0;
+static int g_paint_layer_id_counter = 0;
+
+// Serialize ComputedStyle to JSON
+std::unique_ptr<JSONObject> SerializeComputedStyle(const ComputedStyle& style) {
+  auto json = std::make_unique<JSONObject>();
+
+  // Position and display
+  json->SetString("display", style.Display() == EDisplay::kNone ? "none" :
+                             style.Display() == EDisplay::kBlock ? "block" :
+                             style.Display() == EDisplay::kInline ? "inline" :
+                             style.Display() == EDisplay::kInlineBlock ? "inline-block" :
+                             style.Display() == EDisplay::kFlex ? "flex" :
+                             style.Display() == EDisplay::kInlineFlex ? "inline-flex" :
+                             style.Display() == EDisplay::kGrid ? "grid" :
+                             style.Display() == EDisplay::kInlineGrid ? "inline-grid" :
+                             style.Display() == EDisplay::kContents ? "contents" :
+                             "other");
+  json->SetString("position", style.GetPosition() == EPosition::kStatic ? "static" :
+                              style.GetPosition() == EPosition::kRelative ? "relative" :
+                              style.GetPosition() == EPosition::kAbsolute ? "absolute" :
+                              style.GetPosition() == EPosition::kFixed ? "fixed" :
+                              style.GetPosition() == EPosition::kSticky ? "sticky" :
+                              "other");
+
+  // Visual properties
+  json->SetDouble("opacity", style.Opacity());
+  json->SetInteger("z_index", style.EffectiveZIndex());
+
+  // Transform
+  json->SetBoolean("has_transform", style.HasTransform());
+
+  // Overflow
+  json->SetString("overflow_x", style.OverflowX() == EOverflow::kVisible ? "visible" :
+                                style.OverflowX() == EOverflow::kHidden ? "hidden" :
+                                style.OverflowX() == EOverflow::kScroll ? "scroll" :
+                                style.OverflowX() == EOverflow::kAuto ? "auto" :
+                                style.OverflowX() == EOverflow::kClip ? "clip" :
+                                "other");
+  json->SetString("overflow_y", style.OverflowY() == EOverflow::kVisible ? "visible" :
+                                style.OverflowY() == EOverflow::kHidden ? "hidden" :
+                                style.OverflowY() == EOverflow::kScroll ? "scroll" :
+                                style.OverflowY() == EOverflow::kAuto ? "auto" :
+                                style.OverflowY() == EOverflow::kClip ? "clip" :
+                                "other");
+
+  // Visibility
+  json->SetString("visibility", style.Visibility() == EVisibility::kVisible ? "visible" :
+                                style.Visibility() == EVisibility::kHidden ? "hidden" :
+                                style.Visibility() == EVisibility::kCollapse ? "collapse" :
+                                "other");
+
+  // Filters and effects
+  json->SetBoolean("has_filter", style.HasFilter());
+  json->SetBoolean("has_backdrop_filter", style.HasNonInitialBackdropFilter());
+  json->SetBoolean("has_clip_path", style.HasClipPath());
+  json->SetBoolean("has_mask", style.HasMask());
+
+  // Blend mode
+  if (style.HasBlendMode()) {
+    json->SetBoolean("has_blend_mode", true);
+  }
+
+  // Isolation (check via Isolation() enum)
+  json->SetBoolean("is_isolated", style.Isolation() == EIsolation::kIsolate);
+
+  // Will-change
+  json->SetBoolean("has_will_change_transform", style.HasWillChangeTransformHint());
+  json->SetBoolean("has_will_change_opacity", style.HasWillChangeOpacityHint());
+
+  // Contain property
+  json->SetBoolean("contain_paint", style.ContainsPaint());
+  json->SetBoolean("contain_layout", style.ContainsLayout());
+
+  // Typography properties for text shaping reproduction
+  json->SetDouble("letter_spacing", style.LetterSpacing());
+  json->SetDouble("word_spacing", style.WordSpacing());
+
+  // Font properties
+  const FontDescription& font = style.GetFontDescription();
+  json->SetDouble("font_size", font.ComputedSize());
+  json->SetString("font_family", font.Family().FamilyName().GetString());
+  json->SetInteger("font_weight", static_cast<int>(font.Weight()));
+  json->SetString("font_style",
+      font.Style() == kItalicSlopeValue ? "italic" :
+      font.Style() > kNormalSlopeValue ? "oblique" : "normal");
+
+  return json;
+}
+
+std::unique_ptr<JSONObject> SerializeLayoutObject(const LayoutObject& object,
+                                                   int id) {
+  auto json = std::make_unique<JSONObject>();
+  json->SetInteger("id", id);
+  json->SetString("name", GetLayoutObjectDebugName(object));
+  json->SetInteger("z_index", object.StyleRef().EffectiveZIndex());
+  json->SetBoolean("is_stacking_context", object.IsStackingContext());
+  json->SetBoolean("is_stacked", object.IsStacked());
+  json->SetBoolean("has_layer", object.HasLayer());
+
+  // Add is_self_painting for objects with layers
+  if (object.HasLayer()) {
+    json->SetBoolean("is_self_painting",
+      To<LayoutBoxModelObject>(object).Layer()->IsSelfPaintingLayer());
+  }
+
+  if (Node* node = object.GetNode()) {
+    if (node->IsElementNode()) {
+      json->SetString("tag", To<Element>(node)->TagQName().ToString());
+    }
+  }
+
+  // Add computed style information
+  json->SetObject("computed_style", SerializeComputedStyle(object.StyleRef()));
+
+  // Serialize text content and shape results for LayoutText objects
+  if (object.IsText()) {
+    const LayoutText& layout_text = To<LayoutText>(object);
+
+    // Add the text content
+    json->SetString("text", layout_text.TransformedText());
+
+    // Serialize text fragments with glyph data using NG layout's InlineCursor
+    auto fragments_array = std::make_unique<JSONArray>();
+
+    // Use InlineCursor to iterate over FragmentItems for this LayoutText
+    InlineCursor cursor;
+    cursor.MoveTo(layout_text);
+
+    for (; cursor; cursor.MoveToNextForSameLayoutObject()) {
+      const FragmentItem* item = cursor.CurrentItem();
+      if (!item || item->Type() != FragmentItem::kText)
+        continue;
+
+      auto frag_json = std::make_unique<JSONObject>();
+
+      // Geometry (in containing block coordinates)
+      const PhysicalRect rect = item->RectInContainerFragment();
+      frag_json->SetDouble("x", rect.X().ToDouble());
+      frag_json->SetDouble("y", rect.Y().ToDouble());
+      frag_json->SetDouble("width", rect.Width().ToDouble());
+      frag_json->SetDouble("height", rect.Height().ToDouble());
+
+      // Text range within the LayoutText's content
+      frag_json->SetInteger("start", item->StartOffset());
+      frag_json->SetInteger("end", item->EndOffset());
+
+      // Serialize shape result (glyph data)
+      const ShapeResultView* shape = item->TextShapeResult();
+      if (shape) {
+        auto runs_array = std::make_unique<JSONArray>();
+        auto run_json = std::make_unique<JSONObject>();
+
+        // Collect glyph IDs and positions using ForEachGlyph callback
+        struct GlyphCollector {
+          Vector<uint16_t> glyphs;
+          Vector<float> positions;
+
+          static void Callback(void* context,
+                               unsigned character_index,
+                               Glyph glyph,
+                               gfx::Vector2dF glyph_offset,
+                               float total_advance,
+                               bool is_horizontal,
+                               CanvasRotationInVertical rotation,
+                               const SimpleFontData* font_data) {
+            auto* collector = static_cast<GlyphCollector*>(context);
+            collector->glyphs.push_back(glyph);
+            collector->positions.push_back(total_advance);
+          }
+        };
+        GlyphCollector collector;
+        shape->ForEachGlyph(0, GlyphCollector::Callback, &collector);
+
+        // Serialize glyph array
+        auto glyphs_array = std::make_unique<JSONArray>();
+        for (uint16_t g : collector.glyphs) {
+          glyphs_array->PushInteger(g);
+        }
+        run_json->SetArray("glyphs", std::move(glyphs_array));
+
+        // Serialize positions array
+        auto pos_array = std::make_unique<JSONArray>();
+        for (float p : collector.positions) {
+          pos_array->PushDouble(p);
+        }
+        run_json->SetArray("positions", std::move(pos_array));
+
+        // Positioning type (1 = horizontal)
+        run_json->SetInteger("positioning", 1);
+
+        runs_array->PushObject(std::move(run_json));
+        frag_json->SetArray("runs", std::move(runs_array));
+      }
+
+      fragments_array->PushObject(std::move(frag_json));
+    }
+
+    json->SetArray("fragments", std::move(fragments_array));
+  }
+
+  // === FULL BOX MODEL DATA ===
+  if (object.IsBox()) {
+    const auto& box = To<LayoutBox>(object);
+    const ComputedStyle& style = object.StyleRef();
+
+    // 1. GEOMETRY (absolute coordinates)
+    auto geometry = std::make_unique<JSONObject>();
+    PhysicalRect border_box = box.PhysicalBorderBoxRect();
+    // Transform to absolute document coordinates
+    PhysicalOffset offset = box.LocalToAbsolutePoint(PhysicalOffset());
+    geometry->SetDouble("x", (border_box.X() + offset.left).ToDouble());
+    geometry->SetDouble("y", (border_box.Y() + offset.top).ToDouble());
+    geometry->SetDouble("width", border_box.Width().ToDouble());
+    geometry->SetDouble("height", border_box.Height().ToDouble());
+    json->SetObject("geometry", std::move(geometry));
+
+    // 2. BORDER RADII (8 values) - using FloatValueForLength to resolve Length values
+    if (style.HasBorderRadius()) {
+      auto radii_array = std::make_unique<JSONArray>();
+      // Use border box width/height as reference for percentage values
+      float ref_width = border_box.Width().ToFloat();
+      float ref_height = border_box.Height().ToFloat();
+      // Top-left
+      radii_array->PushDouble(FloatValueForLength(style.BorderTopLeftRadius().Width(), ref_width));
+      radii_array->PushDouble(FloatValueForLength(style.BorderTopLeftRadius().Height(), ref_height));
+      // Top-right
+      radii_array->PushDouble(FloatValueForLength(style.BorderTopRightRadius().Width(), ref_width));
+      radii_array->PushDouble(FloatValueForLength(style.BorderTopRightRadius().Height(), ref_height));
+      // Bottom-right
+      radii_array->PushDouble(FloatValueForLength(style.BorderBottomRightRadius().Width(), ref_width));
+      radii_array->PushDouble(FloatValueForLength(style.BorderBottomRightRadius().Height(), ref_height));
+      // Bottom-left
+      radii_array->PushDouble(FloatValueForLength(style.BorderBottomLeftRadius().Width(), ref_width));
+      radii_array->PushDouble(FloatValueForLength(style.BorderBottomLeftRadius().Height(), ref_height));
+      json->SetArray("border_radii", std::move(radii_array));
+    }
+
+    // 3. BORDER WIDTHS (returns int, not Length)
+    if (style.HasBorder()) {
+      auto border = std::make_unique<JSONObject>();
+      border->SetInteger("top", style.BorderTopWidth());
+      border->SetInteger("right", style.BorderRightWidth());
+      border->SetInteger("bottom", style.BorderBottomWidth());
+      border->SetInteger("left", style.BorderLeftWidth());
+      json->SetObject("border_widths", std::move(border));
+
+      // 3b. BORDER COLORS (using Longhand references)
+      auto border_colors = std::make_unique<JSONObject>();
+      auto serialize_border_color = [&style](const Longhand& property) {
+        Color c = style.VisitedDependentColor(property);
+        auto obj = std::make_unique<JSONObject>();
+        obj->SetDouble("r", c.Red() / 255.0);
+        obj->SetDouble("g", c.Green() / 255.0);
+        obj->SetDouble("b", c.Blue() / 255.0);
+        obj->SetDouble("a", c.Alpha());
+        return obj;
+      };
+      border_colors->SetObject("top", serialize_border_color(GetCSSPropertyBorderTopColor()));
+      border_colors->SetObject("right", serialize_border_color(GetCSSPropertyBorderRightColor()));
+      border_colors->SetObject("bottom", serialize_border_color(GetCSSPropertyBorderBottomColor()));
+      border_colors->SetObject("left", serialize_border_color(GetCSSPropertyBorderLeftColor()));
+      json->SetObject("border_colors", std::move(border_colors));
+    }
+
+    // 4. PADDING
+    auto padding = std::make_unique<JSONObject>();
+    padding->SetDouble("top", box.PaddingTop().ToDouble());
+    padding->SetDouble("right", box.PaddingRight().ToDouble());
+    padding->SetDouble("bottom", box.PaddingBottom().ToDouble());
+    padding->SetDouble("left", box.PaddingLeft().ToDouble());
+    json->SetObject("padding", std::move(padding));
+
+    // 5. MARGIN
+    auto margin = std::make_unique<JSONObject>();
+    margin->SetDouble("top", box.MarginTop().ToDouble());
+    margin->SetDouble("right", box.MarginRight().ToDouble());
+    margin->SetDouble("bottom", box.MarginBottom().ToDouble());
+    margin->SetDouble("left", box.MarginLeft().ToDouble());
+    json->SetObject("margin", std::move(margin));
+
+    // 6. BACKGROUND COLOR
+    if (style.HasBackground()) {
+      Color bg = style.VisitedDependentColor(GetCSSPropertyBackgroundColor());
+      auto bg_color = std::make_unique<JSONObject>();
+      bg_color->SetDouble("r", bg.Red() / 255.0);
+      bg_color->SetDouble("g", bg.Green() / 255.0);
+      bg_color->SetDouble("b", bg.Blue() / 255.0);
+      bg_color->SetDouble("a", bg.Alpha());
+      json->SetObject("background_color", std::move(bg_color));
+    }
+
+    // 7. BOX SHADOW (BoxShadow() returns ShadowList*, iterate via Shadows())
+    if (style.BoxShadow()) {
+      auto shadows_array = std::make_unique<JSONArray>();
+      for (const ShadowData& shadow : style.BoxShadow()->Shadows()) {
+        auto shadow_json = std::make_unique<JSONObject>();
+        shadow_json->SetDouble("offset_x", shadow.X());
+        shadow_json->SetDouble("offset_y", shadow.Y());
+        shadow_json->SetDouble("blur", shadow.BlurRadius());
+        shadow_json->SetDouble("spread", shadow.Spread());
+        shadow_json->SetBoolean("inset", shadow.Style() == ShadowStyle::kInset);
+        // Get color - use GetColor() if it's an absolute color (not currentColor)
+        const StyleColor& style_color = shadow.GetColor();
+        Color c;
+        if (style_color.IsAbsoluteColor()) {
+          c = style_color.GetColor();
+        } else {
+          // Fallback: resolve using the element's color property
+          c = style.VisitedDependentColor(GetCSSPropertyColor());
+        }
+        auto color = std::make_unique<JSONObject>();
+        color->SetDouble("r", c.Red() / 255.0);
+        color->SetDouble("g", c.Green() / 255.0);
+        color->SetDouble("b", c.Blue() / 255.0);
+        color->SetDouble("a", c.Alpha());
+        shadow_json->SetObject("color", std::move(color));
+        shadows_array->PushObject(std::move(shadow_json));
+      }
+      json->SetArray("box_shadow", std::move(shadows_array));
+    }
+  }
+
+  return json;
+}
+
+// First pass: Assign unique IDs to all LayoutObjects
+// Using uintptr_t keys to avoid blink-gc plugin restrictions
+void AssignLayoutObjectIds(
+    const LayoutObject& object,
+    std::unordered_map<uintptr_t, int>& object_to_id) {
+  int my_id = g_layout_object_id_counter++;
+  object_to_id[reinterpret_cast<uintptr_t>(&object)] = my_id;
+
+  for (LayoutObject* child = object.SlowFirstChild(); child;
+       child = child->NextSibling()) {
+    AssignLayoutObjectIds(*child, object_to_id);
+  }
+}
+
+// Second pass: Log the LAYOUT TREE structure recursively (DOM order)
+void LogLayoutTree(
+    const LayoutObject& object,
+    JSONArray* objects_array,
+    const std::unordered_map<uintptr_t, int>& object_to_id,
+    int depth = 0) {
+  auto it = object_to_id.find(reinterpret_cast<uintptr_t>(&object));
+  int my_id = (it != object_to_id.end()) ? it->second : -1;
+
+  auto obj_json = SerializeLayoutObject(object, my_id);
+  obj_json->SetInteger("depth", depth);
+
+  // Add children IDs in DOM order
+  auto children_array = std::make_unique<JSONArray>();
+  for (LayoutObject* child = object.SlowFirstChild(); child;
+       child = child->NextSibling()) {
+    auto child_it = object_to_id.find(reinterpret_cast<uintptr_t>(child));
+    if (child_it != object_to_id.end()) {
+      children_array->PushInteger(child_it->second);
+    }
+  }
+  obj_json->SetArray("children", std::move(children_array));
+
+  objects_array->PushObject(std::move(obj_json));
+
+  // Recurse to children in DOM order
+  for (LayoutObject* child = object.SlowFirstChild(); child;
+       child = child->NextSibling()) {
+    LogLayoutTree(*child, objects_array, object_to_id, depth + 1);
+  }
+}
+
+// First pass: Assign unique IDs to all PaintLayers
+// Using uintptr_t keys to avoid blink-gc plugin restrictions
+void AssignPaintLayerIds(
+    const PaintLayer& layer,
+    std::unordered_map<uintptr_t, int>& layer_to_id) {
+  int my_id = g_paint_layer_id_counter++;
+  layer_to_id[reinterpret_cast<uintptr_t>(&layer)] = my_id;
+
+  for (PaintLayer* child = layer.FirstChild(); child;
+       child = child->NextSibling()) {
+    AssignPaintLayerIds(*child, layer_to_id);
+  }
+}
+
+// Serialize a single PaintLayer to JSON with unique ID
+std::unique_ptr<JSONObject> SerializePaintLayer(
+    const PaintLayer& layer,
+    int id,
+    const std::unordered_map<uintptr_t, int>& layer_to_id) {
+  auto json = std::make_unique<JSONObject>();
+  json->SetInteger("id", id);
+  json->SetString("name", GetLayoutObjectDebugName(layer.GetLayoutObject()));
+  json->SetInteger("z_index",
+                   layer.GetLayoutObject().StyleRef().EffectiveZIndex());
+  json->SetBoolean("is_stacking_context",
+                   layer.GetLayoutObject().IsStackingContext());
+  json->SetBoolean("is_stacked", layer.GetLayoutObject().IsStacked());
+  json->SetBoolean("is_self_painting", layer.IsSelfPaintingLayer());
+
+  // Add parent ID
+  if (layer.Parent()) {
+    auto parent_it = layer_to_id.find(reinterpret_cast<uintptr_t>(layer.Parent()));
+    if (parent_it != layer_to_id.end()) {
+      json->SetInteger("parent_id", parent_it->second);
+    }
+  }
+
+  // Add children IDs in paint layer tree order
+  auto children_array = std::make_unique<JSONArray>();
+  for (PaintLayer* child = layer.FirstChild(); child;
+       child = child->NextSibling()) {
+    auto child_it = layer_to_id.find(reinterpret_cast<uintptr_t>(child));
+    if (child_it != layer_to_id.end()) {
+      children_array->PushInteger(child_it->second);
+    }
+  }
+  json->SetArray("children", std::move(children_array));
+
+  return json;
+}
+
+// Second pass: Log the PaintLayer tree structure recursively
+void LogPaintLayerTree(
+    const PaintLayer& layer,
+    JSONArray* layers_array,
+    const std::unordered_map<uintptr_t, int>& layer_to_id,
+    int depth = 0) {
+  auto it = layer_to_id.find(reinterpret_cast<uintptr_t>(&layer));
+  int my_id = (it != layer_to_id.end()) ? it->second : -1;
+
+  auto layer_json = SerializePaintLayer(layer, my_id, layer_to_id);
+  layer_json->SetInteger("depth", depth);
+  layers_array->PushObject(std::move(layer_json));
+
+  // Recurse to children in paint layer tree order
+  for (PaintLayer* child = layer.FirstChild(); child;
+       child = child->NextSibling()) {
+    LogPaintLayerTree(*child, layers_array, layer_to_id, depth + 1);
+  }
+}
+
+// Serialize a PaintLayerStackingNode to JSON - shows pos/neg z-order lists
+// Takes stacking_node directly since StackingNode() is private
+std::unique_ptr<JSONObject> SerializeStackingNode(
+    const PaintLayer& layer,
+    int layer_id,
+    PaintLayerStackingNode* stacking_node,
+    const std::unordered_map<uintptr_t, int>& layer_to_id) {
+  auto json = std::make_unique<JSONObject>();
+  json->SetInteger("layer_id", layer_id);
+  json->SetString("layer", GetLayoutObjectDebugName(layer.GetLayoutObject()));
+
+  if (!stacking_node) {
+    json->SetBoolean("has_stacking_node", false);
+    return json;
+  }
+
+  json->SetBoolean("has_stacking_node", true);
+
+  // Serialize negative z-order list with IDs
+  auto neg_list = std::make_unique<JSONArray>();
+  for (const auto& child : stacking_node->NegZOrderList()) {
+    auto child_json = std::make_unique<JSONObject>();
+    auto child_it = layer_to_id.find(reinterpret_cast<uintptr_t>(child.Get()));
+    if (child_it != layer_to_id.end()) {
+      child_json->SetInteger("id", child_it->second);
+    }
+    child_json->SetString("name",
+                          GetLayoutObjectDebugName(child->GetLayoutObject()));
+    child_json->SetInteger(
+        "z_index", child->GetLayoutObject().StyleRef().EffectiveZIndex());
+    neg_list->PushObject(std::move(child_json));
+  }
+  json->SetArray("neg_z_order_list", std::move(neg_list));
+
+  // Serialize positive z-order list with IDs
+  auto pos_list = std::make_unique<JSONArray>();
+  for (const auto& child : stacking_node->PosZOrderList()) {
+    auto child_json = std::make_unique<JSONObject>();
+    auto child_it = layer_to_id.find(reinterpret_cast<uintptr_t>(child.Get()));
+    if (child_it != layer_to_id.end()) {
+      child_json->SetInteger("id", child_it->second);
+    }
+    child_json->SetString("name",
+                          GetLayoutObjectDebugName(child->GetLayoutObject()));
+    child_json->SetInteger(
+        "z_index", child->GetLayoutObject().StyleRef().EffectiveZIndex());
+    pos_list->PushObject(std::move(child_json));
+  }
+  json->SetArray("pos_z_order_list", std::move(pos_list));
+
+  return json;
+}
+
 }  // namespace
 
 bool PaintLayerPainter::PaintedOutputInvisible(const ComputedStyle& style) {
-  if (style.HasNonInitialBackdropFilter())
+  if (style.HasNonInitialBackdropFilter()) {
     return false;
+  }
 
   // Always paint when 'will-change: opacity' is present. Reduces jank for
   // common animation implementation approaches, for example, an element that
   // starts with opacity zero and later begins to animate.
-  if (style.HasWillChangeOpacityHint())
+  if (style.HasWillChangeOpacityHint()) {
     return false;
+  }
 
-  if (style.HasCurrentOpacityAnimation())
+  if (style.HasCurrentOpacityAnimation()) {
     return false;
+  }
 
   // 0.0004f < 1/2048. With 10-bit color channels (only available on the
   // newest Macs; otherwise it's 8-bit), we see that an alpha of 1/2048 or
   // less leads to a color output of less than 0.5 in all channels, hence
   // not visible.
   static const float kMinimumVisibleOpacity = 0.0004f;
-  if (style.Opacity() < kMinimumVisibleOpacity)
+  if (style.Opacity() < kMinimumVisibleOpacity) {
     return true;
+  }
 
   return false;
 }
@@ -200,19 +739,25 @@ static bool ShouldCreateSubsequence(const PaintLayer& paint_layer,
                                     const GraphicsContext& context,
                                     PaintFlags paint_flags) {
   // Caching is not needed during printing or painting previews.
-  if (paint_layer.GetLayoutObject().GetDocument().IsPrintingOrPaintingPreview())
+  if (paint_layer.GetLayoutObject()
+          .GetDocument()
+          .IsPrintingOrPaintingPreview()) {
     return false;
+  }
 
-  if (context.GetPaintController().IsSkippingCache())
+  if (context.GetPaintController().IsSkippingCache()) {
     return false;
+  }
 
-  if (!paint_layer.SupportsSubsequenceCaching())
+  if (!paint_layer.SupportsSubsequenceCaching()) {
     return false;
+  }
 
   // Don't create subsequence during special painting to avoid cache conflict
   // with normal painting.
-  if (paint_flags & PaintFlag::kOmitCompositingInfo)
+  if (paint_flags & PaintFlag::kOmitCompositingInfo) {
     return false;
+  }
 
   // Create subsequence if the layer will create a paint chunk because of
   // different properties.
@@ -272,8 +817,9 @@ PaintResult PaintLayerPainter::Paint(GraphicsContext& context,
     return kFullyPainted;
   }
 
-  if (object.GetFrameView()->ShouldThrottleRendering())
+  if (object.GetFrameView()->ShouldThrottleRendering()) {
     return kFullyPainted;
+  }
 
   if (object.IsFragmentLessBox()) {
     return kFullyPainted;
@@ -282,8 +828,9 @@ PaintResult PaintLayerPainter::Paint(GraphicsContext& context,
   // Non self-painting layers without self-painting descendants don't need to be
   // painted as their layoutObject() should properly paint itself.
   if (!paint_layer_.IsSelfPaintingLayer() &&
-      !paint_layer_.HasSelfPaintingLayerDescendant())
+      !paint_layer_.HasSelfPaintingLayerDescendant()) {
     return kFullyPainted;
+  }
 
   std::optional<CheckAncestorPositionVisibilityScope>
       check_position_visibility_scope;
@@ -304,10 +851,103 @@ PaintResult PaintLayerPainter::Paint(GraphicsContext& context,
     return kMayBeClippedByCullRect;
   }
 
+  // Log the full LAYOUT TREE structure at the root (DOM order)
+  if (IsA<LayoutView>(object)) {
+    // Reset ID counters for this logging pass
+    g_layout_object_id_counter = 0;
+    g_paint_layer_id_counter = 0;
+
+    // First pass: assign IDs to all LayoutObjects
+    std::unordered_map<uintptr_t, int> object_to_id;
+    AssignLayoutObjectIds(object, object_to_id);
+
+    // Second pass: log layout tree with IDs
+    auto tree_json = std::make_unique<JSONObject>();
+    auto layout_tree_array = std::make_unique<JSONArray>();
+    LogLayoutTree(object, layout_tree_array.get(), object_to_id);
+    tree_json->SetArray("layout_tree", std::move(layout_tree_array));
+    LOG(ERROR) << "LAYOUT_TREE: " << tree_json->ToJSONString().Utf8();
+
+    // First pass: assign IDs to all PaintLayers
+    std::unordered_map<uintptr_t, int> layer_to_id;
+    AssignPaintLayerIds(paint_layer_, layer_to_id);
+
+    // Second pass: log PaintLayer tree with IDs
+    auto layer_tree_json = std::make_unique<JSONObject>();
+    auto layer_tree_array = std::make_unique<JSONArray>();
+    LogPaintLayerTree(paint_layer_, layer_tree_array.get(), layer_to_id);
+    layer_tree_json->SetArray("layer_tree", std::move(layer_tree_array));
+    LOG(ERROR) << "LAYER_TREE: " << layer_tree_json->ToJSONString().Utf8();
+
+    // Log all stacking nodes (z-order lists) for paint order info
+    // We collect inline here since we have friend access to StackingNode()
+    auto paint_order_json = std::make_unique<JSONObject>();
+    auto stacking_nodes_array = std::make_unique<JSONArray>();
+
+    // Use a lambda to recursively collect stacking nodes
+    std::function<void(const PaintLayer&)> collect_stacking_nodes =
+        [&](const PaintLayer& layer) {
+          PaintLayerStackingNode* stacking_node = layer.StackingNode();
+          if (stacking_node) {
+            auto it = layer_to_id.find(reinterpret_cast<uintptr_t>(&layer));
+            int layer_id = (it != layer_to_id.end()) ? it->second : -1;
+            stacking_nodes_array->PushObject(
+                SerializeStackingNode(layer, layer_id, stacking_node,
+                                      layer_to_id));
+          }
+          for (PaintLayer* child = layer.FirstChild(); child;
+               child = child->NextSibling()) {
+            collect_stacking_nodes(*child);
+          }
+        };
+    collect_stacking_nodes(paint_layer_);
+
+    paint_order_json->SetArray("stacking_nodes", std::move(stacking_nodes_array));
+    LOG(ERROR) << "PAINT_ORDER: " << paint_order_json->ToJSONString().Utf8();
+
+    // Log Property Trees
+    PropertyTreeIdMapper property_tree_mapper;
+    std::function<void(const LayoutObject&)> collect_property_tree_nodes =
+        [&](const LayoutObject& object) {
+          for (const FragmentData& fragment : FragmentDataIterator(object)) {
+            if (fragment.HasLocalBorderBoxProperties()) {
+              PropertyTreeStateOrAlias state =
+                  fragment.LocalBorderBoxProperties();
+              property_tree_mapper.GetOrAssignTransformId(
+                  &state.Transform().Unalias());
+              property_tree_mapper.GetOrAssignClipId(&state.Clip().Unalias());
+              property_tree_mapper.GetOrAssignEffectId(
+                  &state.Effect().Unalias());
+            }
+          }
+          for (const LayoutObject* child = object.SlowFirstChild(); child;
+               child = child->NextSibling()) {
+            collect_property_tree_nodes(*child);
+          }
+        };
+
+    // Retrieve LayoutView via the current paint_layer's LayoutObject
+    collect_property_tree_nodes(*paint_layer_.GetLayoutObject().View());
+
+    auto property_trees_json = std::make_unique<JSONObject>();
+    property_trees_json->SetObject(
+        "transform_tree",
+        SerializeTransformTree(property_tree_mapper.GetTransformIds()));
+    property_trees_json->SetObject(
+        "clip_tree", SerializeClipTree(property_tree_mapper.GetClipIds()));
+    property_trees_json->SetObject(
+        "effect_tree",
+        SerializeEffectTree(property_tree_mapper.GetEffectIds()));
+
+    LOG(ERROR) << "PROPERTY_TREES: "
+               << property_trees_json->ToJSONString().Utf8();
+  }
+
   bool selection_drag_image_only =
       paint_flags & PaintFlag::kSelectionDragImageOnly;
-  if (selection_drag_image_only && !object.IsSelected())
+  if (selection_drag_image_only && !object.IsSelected()) {
     return kFullyPainted;
+  }
 
   IgnorePaintTimingScope ignore_paint_timing;
   if (object.StyleRef().Opacity() == 0.0f) {
@@ -344,8 +984,9 @@ PaintResult PaintLayerPainter::Paint(GraphicsContext& context,
     gfx::Rect visual_rect = FirstFragmentVisualRect(object);
     gfx::Rect cull_rect = object.FirstFragment().GetCullRect().Rect();
     bool cull_rect_intersects_self = cull_rect.Intersects(visual_rect);
-    if (!cull_rect.Contains(visual_rect))
+    if (!cull_rect.Contains(visual_rect)) {
       result = kMayBeClippedByCullRect;
+    }
 
     bool cull_rect_intersects_contents = true;
     if (const auto* box = DynamicTo<LayoutBox>(object)) {
@@ -355,8 +996,9 @@ PaintResult PaintLayerPainter::Paint(GraphicsContext& context,
           object.FirstFragment().GetContentsCullRect().Rect());
       cull_rect_intersects_contents =
           contents_cull_rect.Intersects(contents_visual_rect);
-      if (!contents_cull_rect.Contains(contents_visual_rect))
+      if (!contents_cull_rect.Contains(contents_visual_rect)) {
         result = kMayBeClippedByCullRect;
+      }
     } else {
       cull_rect_intersects_contents = cull_rect_intersects_self;
     }
@@ -391,8 +1033,9 @@ PaintResult PaintLayerPainter::Paint(GraphicsContext& context,
   PaintController& controller = context.GetPaintController();
 
   std::optional<ScopedEffectivelyInvisible> effectively_invisible;
-  if (PaintedOutputInvisible(object.StyleRef()))
+  if (PaintedOutputInvisible(object.StyleRef())) {
     effectively_invisible.emplace(controller);
+  }
 
   std::optional<ScopedPaintChunkProperties> layer_chunk_properties;
 
@@ -433,8 +1076,9 @@ PaintResult PaintLayerPainter::Paint(GraphicsContext& context,
   }
 
   if (PaintChildren(kNegativeZOrderChildren, context, paint_flags) ==
-      kMayBeClippedByCullRect)
+      kMayBeClippedByCullRect) {
     result = kMayBeClippedByCullRect;
+  }
 
   if (should_paint_content) {
     // If the negative-z-order children created paint chunks, this gives the
@@ -455,18 +1099,21 @@ PaintResult PaintLayerPainter::Paint(GraphicsContext& context,
       is_self_painting_layer && object.StyleRef().HasOutline();
 
   bool is_video = IsA<LayoutVideo>(object);
-  if (!is_video && should_paint_self_outline)
+  if (!is_video && should_paint_self_outline) {
     PaintWithPhase(PaintPhase::kSelfOutlineOnly, context, paint_flags);
+  }
 
   if (PaintChildren(kNormalFlowAndPositiveZOrderChildren, context,
-                    paint_flags) == kMayBeClippedByCullRect)
+                    paint_flags) == kMayBeClippedByCullRect) {
     result = kMayBeClippedByCullRect;
+  }
 
   if (should_paint_content && paint_layer_.GetScrollableArea() &&
       paint_layer_.GetScrollableArea()
           ->ShouldOverflowControlsPaintAsOverlay()) {
-    if (!paint_layer_.NeedsReorderOverlayOverflowControls())
+    if (!paint_layer_.NeedsReorderOverlayOverflowControls()) {
       PaintOverlayOverflowControls(context, paint_flags);
+    }
     // Otherwise the overlay overflow controls will be painted after scrolling
     // children in PaintChildren().
   }
@@ -488,8 +1135,9 @@ PaintResult PaintLayerPainter::Paint(GraphicsContext& context,
           PaintWithPhase(PaintPhase::kMask, context, paint_flags);
         }
       }
-      if (properties->ClipPathMask())
+      if (properties->ClipPathMask()) {
         ClipPathClipper::PaintClipPathAsMaskImage(context, object, object);
+      }
     }
     if (PaintTransitionPseudos(context, object, paint_flags) ==
         kMayBeClippedByCullRect) {
@@ -564,8 +1212,9 @@ PaintResult PaintLayerPainter::PaintChildren(
     GraphicsContext& context,
     PaintFlags paint_flags) {
   PaintResult result = kFullyPainted;
-  if (!paint_layer_.HasSelfPaintingLayerDescendant())
+  if (!paint_layer_.HasSelfPaintingLayerDescendant()) {
     return result;
+  }
 
   LayoutObject& layout_object = paint_layer_.GetLayoutObject();
   if (layout_object.ChildPaintBlockedByDisplayLock()) {
@@ -579,8 +1228,9 @@ PaintResult PaintLayerPainter::PaintChildren(
 
   PaintLayerPaintOrderIterator iterator(&paint_layer_, children_to_visit);
   while (PaintLayer* child = iterator.Next()) {
-    if (child->IsReplacedNormalFlowStacking())
+    if (child->IsReplacedNormalFlowStacking()) {
       continue;
+    }
 
     if (!layout_object.IsViewTransitionRoot() &&
         ViewTransitionUtils::IsViewTransitionRoot(child->GetLayoutObject())) {
@@ -591,8 +1241,9 @@ PaintResult PaintLayerPainter::PaintChildren(
     }
 
     if (PaintLayerPainter(*child).Paint(context, paint_flags) ==
-        kMayBeClippedByCullRect)
+        kMayBeClippedByCullRect) {
       result = kMayBeClippedByCullRect;
+    }
 
     if (const auto* layers_painting_overlay_overflow_controls_after =
             iterator.LayersPaintingOverlayOverflowControlsAfter(child)) {
@@ -632,8 +1283,9 @@ void PaintLayerPainter::PaintFragmentWithPhase(
          phase == PaintPhase::kOverlayOverflowControls);
 
   CullRect cull_rect = fragment_data.GetCullRect();
-  if (cull_rect.Rect().IsEmpty())
+  if (cull_rect.Rect().IsEmpty()) {
     return;
+  }
 
   auto chunk_properties = fragment_data.LocalBorderBoxProperties();
   if (phase == PaintPhase::kMask) {
@@ -691,14 +1343,16 @@ void PaintLayerPainter::PaintWithPhase(PaintPhase phase,
     }
 
     std::optional<ScopedDisplayItemFragment> scoped_display_item_fragment;
-    if (fragment_idx)
+    if (fragment_idx) {
       scoped_display_item_fragment.emplace(context, fragment_idx);
+    }
 
     PaintFragmentWithPhase(phase, fragment, fragment_idx, physical_fragment,
                            context, paint_flags);
 
-    if (!multiple_fragments_allowed)
+    if (!multiple_fragments_allowed) {
       break;
+    }
 
     fragment_idx++;
   }
diff --git a/third_party/blink/renderer/platform/graphics/paint/property_tree_serializer.cc b/third_party/blink/renderer/platform/graphics/paint/property_tree_serializer.cc
new file mode 100644
index 0000000000..509a35a0ca
--- /dev/null
+++ b/third_party/blink/renderer/platform/graphics/paint/property_tree_serializer.cc
@@ -0,0 +1,405 @@
+// Copyright 2024 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "third_party/blink/renderer/platform/graphics/paint/property_tree_serializer.h"
+
+#include <algorithm>
+#include <vector>
+
+#include "cc/paint/filter_operation.h"
+#include "third_party/blink/renderer/platform/graphics/compositor_filter_operations.h"
+#include "third_party/blink/renderer/platform/json/json_values.h"
+#include "third_party/blink/renderer/platform/geometry/path.h"
+#include "third_party/skia/include/core/SkBlendMode.h"
+#include "third_party/skia/include/core/SkPath.h"
+#include "third_party/skia/include/utils/SkParsePath.h"
+#include "ui/gfx/geometry/rect_f.h"
+#include "ui/gfx/geometry/transform.h"
+#include "ui/gfx/geometry/vector2d_f.h"
+
+namespace blink {
+
+// PropertyTreeIdMapper implementation
+
+int PropertyTreeIdMapper::GetOrAssignTransformId(
+    const TransformPaintPropertyNode* node) {
+  if (!node) {
+    return -1;
+  }
+  const void* key = static_cast<const void*>(node);
+  auto it = transform_ids_.find(key);
+  if (it != transform_ids_.end()) {
+    return it->second;
+  }
+  // First assign IDs to parents
+  if (auto* parent = node->UnaliasedParent()) {
+    GetOrAssignTransformId(parent);
+  }
+  int id = next_transform_id_++;
+  transform_ids_[key] = id;
+  return id;
+}
+
+int PropertyTreeIdMapper::GetOrAssignClipId(const ClipPaintPropertyNode* node) {
+  if (!node) {
+    return -1;
+  }
+  const void* key = static_cast<const void*>(node);
+  auto it = clip_ids_.find(key);
+  if (it != clip_ids_.end()) {
+    return it->second;
+  }
+  // First assign IDs to parents
+  if (auto* parent = node->UnaliasedParent()) {
+    GetOrAssignClipId(parent);
+  }
+  int id = next_clip_id_++;
+  clip_ids_[key] = id;
+  return id;
+}
+
+int PropertyTreeIdMapper::GetOrAssignEffectId(
+    const EffectPaintPropertyNode* node) {
+  if (!node) {
+    return -1;
+  }
+  const void* key = static_cast<const void*>(node);
+  auto it = effect_ids_.find(key);
+  if (it != effect_ids_.end()) {
+    return it->second;
+  }
+  // First assign IDs to parents
+  if (auto* parent = node->UnaliasedParent()) {
+    GetOrAssignEffectId(parent);
+  }
+  int id = next_effect_id_++;
+  effect_ids_[key] = id;
+  return id;
+}
+
+// Helper to serialize gfx::Transform to JSON array (row-major 4x4 matrix)
+namespace {
+
+std::unique_ptr<JSONArray> SerializeTransformMatrix(
+    const gfx::Transform& transform) {
+  auto json = std::make_unique<JSONArray>();
+  for (int row = 0; row < 4; ++row) {
+    for (int col = 0; col < 4; ++col) {
+      json->PushDouble(transform.rc(row, col));
+    }
+  }
+  return json;
+}
+
+std::unique_ptr<JSONArray> SerializeRectF(const gfx::RectF& rect) {
+  auto json = std::make_unique<JSONArray>();
+  json->PushDouble(rect.x());
+  json->PushDouble(rect.y());
+  json->PushDouble(rect.width());
+  json->PushDouble(rect.height());
+  return json;
+}
+
+}  // namespace
+
+std::unique_ptr<JSONObject> SerializeTransformTree(
+    const std::unordered_map<const void*, int>& node_ids) {
+  auto json = std::make_unique<JSONObject>();
+  auto nodes_array = std::make_unique<JSONArray>();
+
+  // Sort by ID for consistent output
+  std::vector<std::pair<int, const void*>> sorted_nodes;
+  for (const auto& entry : node_ids) {
+    sorted_nodes.push_back({entry.second, entry.first});
+  }
+  std::sort(sorted_nodes.begin(), sorted_nodes.end(),
+            [](const auto& a, const auto& b) { return a.first < b.first; });
+
+  for (const auto& entry : sorted_nodes) {
+    int id = entry.first;
+    const auto* node =
+        static_cast<const TransformPaintPropertyNode*>(entry.second);
+
+    auto node_json = std::make_unique<JSONObject>();
+    node_json->SetInteger("id", id);
+
+    // Parent ID
+    if (auto* parent = node->UnaliasedParent()) {
+      const void* parent_key = static_cast<const void*>(parent);
+      auto parent_it = node_ids.find(parent_key);
+      node_json->SetInteger(
+          "parent_id", parent_it != node_ids.end() ? parent_it->second : -1);
+    } else {
+      node_json->SetInteger("parent_id", -1);
+    }
+
+    // Transform matrix
+    if (node->IsIdentityOr2dTranslation()) {
+      gfx::Vector2dF translation = node->Get2dTranslation();
+      if (!translation.IsZero()) {
+        auto translation_array = std::make_unique<JSONArray>();
+        translation_array->PushDouble(translation.x());
+        translation_array->PushDouble(translation.y());
+        node_json->SetArray("translation2d", std::move(translation_array));
+      }
+    } else {
+      node_json->SetArray("matrix", SerializeTransformMatrix(node->Matrix()));
+    }
+
+    // Transform origin (CSS transform-origin)
+    const gfx::Point3F& origin = node->Origin();
+    if (origin.x() != 0 || origin.y() != 0 || origin.z() != 0) {
+      auto origin_array = std::make_unique<JSONArray>();
+      origin_array->PushDouble(origin.x());
+      origin_array->PushDouble(origin.y());
+      origin_array->PushDouble(origin.z());
+      node_json->SetArray("origin", std::move(origin_array));
+    }
+    
+    // Backface visibility (CSS backface-visibility: hidden)
+    if (node->IsBackfaceHidden()) {
+      node_json->SetBoolean("backface_hidden", true);
+    }
+
+    nodes_array->PushObject(std::move(node_json));
+  }
+
+  json->SetArray("nodes", std::move(nodes_array));
+  return json;
+}
+
+std::unique_ptr<JSONObject> SerializeClipTree(
+    const std::unordered_map<const void*, int>& node_ids) {
+  auto json = std::make_unique<JSONObject>();
+  auto nodes_array = std::make_unique<JSONArray>();
+
+  // Sort by ID for consistent output
+  std::vector<std::pair<int, const void*>> sorted_nodes;
+  for (const auto& entry : node_ids) {
+    sorted_nodes.push_back({entry.second, entry.first});
+  }
+  std::sort(sorted_nodes.begin(), sorted_nodes.end(),
+            [](const auto& a, const auto& b) { return a.first < b.first; });
+
+  for (const auto& entry : sorted_nodes) {
+    int id = entry.first;
+    const auto* node = static_cast<const ClipPaintPropertyNode*>(entry.second);
+
+    auto node_json = std::make_unique<JSONObject>();
+    node_json->SetInteger("id", id);
+
+    // Parent ID
+    if (auto* parent = node->UnaliasedParent()) {
+      const void* parent_key = static_cast<const void*>(parent);
+      auto parent_it = node_ids.find(parent_key);
+      node_json->SetInteger(
+          "parent_id", parent_it != node_ids.end() ? parent_it->second : -1);
+    } else {
+      node_json->SetInteger("parent_id", -1);
+    }
+
+    // Clip rect
+    node_json->SetArray("clip_rect",
+                        SerializeRectF(node->PaintClipRect().Rect()));
+
+    // Clip path (for CSS clip-path: polygon(), etc.)
+    if (node->ClipPath().has_value()) {
+      const Path& clip_path = node->ClipPath().value();
+      const SkPath& sk_path = clip_path.GetSkPath();
+      SkString path_str = SkParsePath::ToSVGString(sk_path);
+      node_json->SetString("clip_path", path_str.c_str());
+    }
+
+    nodes_array->PushObject(std::move(node_json));
+  }
+
+  json->SetArray("nodes", std::move(nodes_array));
+  return json;
+}
+
+std::unique_ptr<JSONObject> SerializeEffectTree(
+    const std::unordered_map<const void*, int>& node_ids) {
+  auto json = std::make_unique<JSONObject>();
+  auto nodes_array = std::make_unique<JSONArray>();
+
+  // Sort by ID for consistent output
+  std::vector<std::pair<int, const void*>> sorted_nodes;
+  for (const auto& entry : node_ids) {
+    sorted_nodes.push_back({entry.second, entry.first});
+  }
+  std::sort(sorted_nodes.begin(), sorted_nodes.end(),
+            [](const auto& a, const auto& b) { return a.first < b.first; });
+
+  for (const auto& entry : sorted_nodes) {
+    int id = entry.first;
+    const auto* node =
+        static_cast<const EffectPaintPropertyNode*>(entry.second);
+
+    auto node_json = std::make_unique<JSONObject>();
+    node_json->SetInteger("id", id);
+
+    // Parent ID
+    if (auto* parent = node->UnaliasedParent()) {
+      const void* parent_key = static_cast<const void*>(parent);
+      auto parent_it = node_ids.find(parent_key);
+      node_json->SetInteger(
+          "parent_id", parent_it != node_ids.end() ? parent_it->second : -1);
+    } else {
+      node_json->SetInteger("parent_id", -1);
+    }
+
+    // Opacity
+    node_json->SetDouble("opacity", node->Opacity());
+
+    // Blend mode
+    node_json->SetString("blend_mode", SkBlendMode_Name(node->BlendMode()));
+
+      // Filter (CSS filter property)
+    if (const auto* filter = node->Filter()) {
+      const auto& cc_filter = filter->AsCcFilterOperations();
+      if (!cc_filter.IsEmpty()) {
+        auto filter_array = std::make_unique<JSONArray>();
+        for (const auto& op : cc_filter.operations()) {
+          auto op_json = std::make_unique<JSONObject>();
+          switch (op.type()) {
+            case cc::FilterOperation::BLUR:
+              op_json->SetString("type", "blur");
+              op_json->SetDouble("amount", op.amount());
+              break;
+            case cc::FilterOperation::GRAYSCALE:
+              op_json->SetString("type", "grayscale");
+              op_json->SetDouble("amount", op.amount());
+              break;
+            case cc::FilterOperation::SEPIA:
+              op_json->SetString("type", "sepia");
+              op_json->SetDouble("amount", op.amount());
+              break;
+            case cc::FilterOperation::SATURATE:
+              op_json->SetString("type", "saturate");
+              op_json->SetDouble("amount", op.amount());
+              break;
+            case cc::FilterOperation::HUE_ROTATE:
+              op_json->SetString("type", "hue_rotate");
+              op_json->SetDouble("amount", op.amount());
+              break;
+            case cc::FilterOperation::INVERT:
+              op_json->SetString("type", "invert");
+              op_json->SetDouble("amount", op.amount());
+              break;
+            case cc::FilterOperation::BRIGHTNESS:
+              op_json->SetString("type", "brightness");
+              op_json->SetDouble("amount", op.amount());
+              break;
+            case cc::FilterOperation::CONTRAST:
+              op_json->SetString("type", "contrast");
+              op_json->SetDouble("amount", op.amount());
+              break;
+            case cc::FilterOperation::OPACITY:
+              op_json->SetString("type", "opacity");
+              op_json->SetDouble("amount", op.amount());
+              break;
+            case cc::FilterOperation::DROP_SHADOW: {
+              op_json->SetString("type", "drop_shadow");
+              op_json->SetDouble("std_deviation", op.amount());
+              auto offset_array = std::make_unique<JSONArray>();
+              offset_array->PushDouble(op.offset().x());
+              offset_array->PushDouble(op.offset().y());
+              op_json->SetArray("offset", std::move(offset_array));
+              const auto& color = op.drop_shadow_color();
+              auto color_array = std::make_unique<JSONArray>();
+              color_array->PushDouble(color.fR);
+              color_array->PushDouble(color.fG);
+              color_array->PushDouble(color.fB);
+              color_array->PushDouble(color.fA);
+              op_json->SetArray("color", std::move(color_array));
+              break;
+            }
+            default:
+              op_json->SetString("type", "unknown");
+              break;
+          }
+          filter_array->PushObject(std::move(op_json));
+        }
+        node_json->SetArray("filter", std::move(filter_array));
+      }
+    }
+  
+    // Backdrop filter (CSS backdrop-filter property)
+    if (const auto* backdrop_filter = node->BackdropFilter()) {
+      const auto& cc_filter = backdrop_filter->AsCcFilterOperations();
+      if (!cc_filter.IsEmpty()) {
+        auto filter_array = std::make_unique<JSONArray>();
+        for (const auto& op : cc_filter.operations()) {
+          auto op_json = std::make_unique<JSONObject>();
+          switch (op.type()) {
+            case cc::FilterOperation::BLUR:
+              op_json->SetString("type", "blur");
+              op_json->SetDouble("amount", op.amount());
+              break;
+            case cc::FilterOperation::GRAYSCALE:
+              op_json->SetString("type", "grayscale");
+              op_json->SetDouble("amount", op.amount());
+              break;
+            case cc::FilterOperation::SEPIA:
+              op_json->SetString("type", "sepia");
+              op_json->SetDouble("amount", op.amount());
+              break;
+            case cc::FilterOperation::SATURATE:
+              op_json->SetString("type", "saturate");
+              op_json->SetDouble("amount", op.amount());
+              break;
+            case cc::FilterOperation::HUE_ROTATE:
+              op_json->SetString("type", "hue_rotate");
+              op_json->SetDouble("amount", op.amount());
+              break;
+            case cc::FilterOperation::INVERT:
+              op_json->SetString("type", "invert");
+              op_json->SetDouble("amount", op.amount());
+              break;
+            case cc::FilterOperation::BRIGHTNESS:
+              op_json->SetString("type", "brightness");
+              op_json->SetDouble("amount", op.amount());
+              break;
+            case cc::FilterOperation::CONTRAST:
+              op_json->SetString("type", "contrast");
+              op_json->SetDouble("amount", op.amount());
+              break;
+            case cc::FilterOperation::OPACITY:
+              op_json->SetString("type", "opacity");
+              op_json->SetDouble("amount", op.amount());
+              break;
+            case cc::FilterOperation::DROP_SHADOW: {
+              op_json->SetString("type", "drop_shadow");
+              op_json->SetDouble("std_deviation", op.amount());
+              auto offset_array = std::make_unique<JSONArray>();
+              offset_array->PushDouble(op.offset().x());
+              offset_array->PushDouble(op.offset().y());
+              op_json->SetArray("offset", std::move(offset_array));
+              const auto& color = op.drop_shadow_color();
+              auto color_array = std::make_unique<JSONArray>();
+              color_array->PushDouble(color.fR);
+              color_array->PushDouble(color.fG);
+              color_array->PushDouble(color.fB);
+              color_array->PushDouble(color.fA);
+              op_json->SetArray("color", std::move(color_array));
+              break;
+            }
+            default:
+              op_json->SetString("type", "unknown");
+              break;
+          }
+          filter_array->PushObject(std::move(op_json));
+        }
+        node_json->SetArray("backdrop_filter", std::move(filter_array));
+      }
+    }
+
+    nodes_array->PushObject(std::move(node_json));
+  }
+
+  json->SetArray("nodes", std::move(nodes_array));
+  return json;
+}
+
+}  // namespace blink
\ No newline at end of file
diff --git a/third_party/blink/renderer/platform/graphics/paint/property_tree_serializer.h b/third_party/blink/renderer/platform/graphics/paint/property_tree_serializer.h
new file mode 100644
index 0000000000..af9b526ca2
--- /dev/null
+++ b/third_party/blink/renderer/platform/graphics/paint/property_tree_serializer.h
@@ -0,0 +1,68 @@
+// Copyright 2024 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef THIRD_PARTY_BLINK_RENDERER_PLATFORM_GRAPHICS_PAINT_PROPERTY_TREE_SERIALIZER_H_
+#define THIRD_PARTY_BLINK_RENDERER_PLATFORM_GRAPHICS_PAINT_PROPERTY_TREE_SERIALIZER_H_
+
+#include <memory>
+#include <unordered_map>
+
+#include "third_party/blink/renderer/platform/allow_discouraged_type.h"
+#include "third_party/blink/renderer/platform/graphics/paint/clip_paint_property_node.h"
+#include "third_party/blink/renderer/platform/graphics/paint/effect_paint_property_node.h"
+#include "third_party/blink/renderer/platform/graphics/paint/transform_paint_property_node.h"
+#include "third_party/blink/renderer/platform/platform_export.h"
+
+namespace blink {
+
+class JSONObject;
+
+// Property tree node ID assignment helper for serialization.
+// Uses void* keys to avoid blink-gc checker issues with GC-managed pointers.
+// This is safe because we only use these maps during serialization within
+// a single stack frame - no GC can occur during this time.
+class PLATFORM_EXPORT PropertyTreeIdMapper {
+ public:
+  int GetOrAssignTransformId(const TransformPaintPropertyNode* node);
+  int GetOrAssignClipId(const ClipPaintPropertyNode* node);
+  int GetOrAssignEffectId(const EffectPaintPropertyNode* node);
+
+  const std::unordered_map<const void*, int>& GetTransformIds() const {
+    return transform_ids_;
+  }
+  const std::unordered_map<const void*, int>& GetClipIds() const {
+    return clip_ids_;
+  }
+  const std::unordered_map<const void*, int>& GetEffectIds() const {
+    return effect_ids_;
+  }
+
+ private:
+  std::unordered_map<const void*, int> transform_ids_ ALLOW_DISCOURAGED_TYPE(
+      "Using void* to avoid blink-gc issues with GC pointers");
+  std::unordered_map<const void*, int> clip_ids_ ALLOW_DISCOURAGED_TYPE(
+      "Using void* to avoid blink-gc issues with GC pointers");
+  std::unordered_map<const void*, int> effect_ids_ ALLOW_DISCOURAGED_TYPE(
+      "Using void* to avoid blink-gc issues with GC pointers");
+  int next_transform_id_ = 0;
+  int next_clip_id_ = 0;
+  int next_effect_id_ = 0;
+};
+
+// Serialize transform tree nodes to JSON.
+// Takes the ID map from PropertyTreeIdMapper.
+PLATFORM_EXPORT std::unique_ptr<JSONObject> SerializeTransformTree(
+    const std::unordered_map<const void*, int>& node_ids);
+
+// Serialize clip tree nodes to JSON.
+PLATFORM_EXPORT std::unique_ptr<JSONObject> SerializeClipTree(
+    const std::unordered_map<const void*, int>& node_ids);
+
+// Serialize effect tree nodes to JSON.
+PLATFORM_EXPORT std::unique_ptr<JSONObject> SerializeEffectTree(
+    const std::unordered_map<const void*, int>& node_ids);
+
+}  // namespace blink
+
+#endif  // THIRD_PARTY_BLINK_RENDERER_PLATFORM_GRAPHICS_PAINT_PROPERTY_TREE_SERIALIZER_H_
