<style>
    @font-face {
        font-family: Arial;
        src: url("../Arial.ttf");
    }
    body {
        margin: 20px;
        background: #f0f0f0;
        display: grid;
        grid-template-columns: repeat(3, 1fr);
    }

    * {
        font-family: Arial;
    }

    /* Card with shadow and rounded corners */
    .card {
        background: white;
        border-radius: 12px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 1);
        padding: 20px;
        margin-bottom: 20px;
        max-width: 400px;
    }

    /* Transformed container */
    .transformed-box {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        padding: 15px;
        border-radius: 8px;
        transform: rotate(-15deg) scale(1.2);
        margin: 10px 0;
    }

    /* Semi-transparent overlay */
    .overlay-container {
        position: relative;
        background: #3498db;
        padding: 30px;
        border-radius: 8px;
        margin: 15px 0;
    }
    .overlay {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(255, 255, 255, 0.3);
        border-radius: 8px;
        pointer-events: none;
    }

    /* Clipped element */
    .clipped {
        background: #e74c3c;
        color: white;
        padding: 20px;
        clip-path: polygon(10% 0%, 100% 0%, 90% 100%, 0% 100%);
        margin: 15px 0;
    }

    /* Nested transforms */
    .outer-transform {
        transform: perspective(500px) rotateY(5deg);
        padding: 10px;
        background: #ecf0f1;
        border-radius: 8px;
        margin: 15px 0;
    }
    .inner-transform {
        transform: translateX(10px) skewX(-3deg);
        background: #9b59b6;
        color: white;
        padding: 15px;
        border-radius: 4px;
    }

    /* Form elements */
    .form-group {
        margin: 12px 0;
    }
    .form-group label {
        display: block;
        margin-bottom: 5px;
        font-weight: bold;
        color: #333;
    }
    .form-group input[type="text"],
    .form-group input[type="email"],
    .form-group input[type="password"] {
        width: 100%;
        padding: 10px;
        border: 2px solid #ddd;
        border-radius: 6px;
        font-size: 14px;
        box-sizing: border-box;
    }
    .form-group input:focus {
        border-color: #3498db;
        outline: none;
    }
    .form-group textarea {
        width: 100%;
        padding: 10px;
        border: 2px solid #ddd;
        border-radius: 6px;
        font-size: 14px;
        min-height: 80px;
        box-sizing: border-box;
        resize: vertical;
    }

    /* Checkbox and radio styling */
    .checkbox-group {
        display: flex;
        gap: 15px;
        margin: 10px 0;
    }
    .checkbox-group label {
        display: flex;
        align-items: center;
        gap: 5px;
        cursor: pointer;
    }

    /* Buttons with different styles */
    .button-row {
        display: flex;
        gap: 10px;
        margin: 15px 0;
        flex-wrap: wrap;
    }
    .btn {
        padding: 10px 20px;
        border: none;
        border-radius: 6px;
        cursor: pointer;
        font-size: 14px;
        transition: transform 0.2s;
    }
    .btn-primary {
        background: #3498db;
        color: white;
    }
    .btn-success {
        background: #27ae60;
        color: white;
    }
    .btn-warning {
        background: #f39c12;
        color: white;
    }
    .btn-danger {
        background: #e74c3c;
        color: white;
    }
    .btn-outline {
        background: transparent;
        border: 2px solid #3498db;
        color: #3498db;
    }

    /* Opacity variations */
    .opacity-demo {
        display: flex;
        gap: 10px;
        margin: 15px 0;
    }
    .opacity-box {
        width: 60px;
        height: 60px;
        background: #2c3e50;
        border-radius: 8px;
        display: flex;
        align-items: center;
        justify-content: center;
        color: white;
        font-size: 12px;
    }

    /* Nested rounded borders */
    .nested-rounded {
        background: #1abc9c;
        border-radius: 16px;
        padding: 15px;
        margin: 15px 0;
    }
    .nested-rounded .inner {
        background: rgba(255, 255, 255, 0.9);
        border-radius: 10px;
        padding: 12px;
        color: #333;
    }
    .nested-rounded .inner .innermost {
        background: #16a085;
        color: white;
        border-radius: 6px;
        padding: 8px;
        margin-top: 8px;
    }

    /* Select dropdown */
    .form-group select {
        width: 100%;
        padding: 10px;
        border: 2px solid #ddd;
        border-radius: 6px;
        font-size: 14px;
        background: white;
    }

    /* Range slider */
    .form-group input[type="range"] {
        width: 100%;
    }

    /* Progress-like bar */
    .progress-bar {
        background: #ecf0f1;
        border-radius: 10px;
        height: 20px;
        overflow: hidden;
        margin: 15px 0;
    }
    .progress-bar .fill {
        background: linear-gradient(90deg, #3498db, #2ecc71);
        height: 100%;
        width: 65%;
        border-radius: 10px;
    }

    /* Badge/tag elements */
    .tags {
        display: flex;
        gap: 8px;
        flex-wrap: wrap;
        margin: 10px 0;
    }
    .tag {
        background: #e8e8e8;
        padding: 4px 12px;
        border-radius: 20px;
        font-size: 12px;
        color: #555;
    }
    .tag.active {
        background: #3498db;
        color: white;
    }


    /* Data table */
    .data-table {
        width: 100%;
        border-collapse: collapse;
        margin: 15px 0;
        font-size: 13px;
    }
    .data-table th {
        background: #34495e;
        color: white;
        padding: 12px 10px;
        text-align: left;
        font-weight: 600;
    }
    .data-table th:first-child {
        border-radius: 6px 0 0 0;
    }
    .data-table th:last-child {
        border-radius: 0 6px 0 0;
    }
    .data-table td {
        padding: 10px;
        border-bottom: 1px solid #ecf0f1;
    }
    .data-table tr:nth-child(even) {
        background: #f8f9fa;
    }
    .data-table tr:hover {
        background: #e8f4f8;
    }
    .status-badge {
        display: inline-block;
        padding: 3px 8px;
        border-radius: 12px;
        font-size: 11px;
        font-weight: 600;
    }
    .status-active { background: #d4edda; color: #155724; }
    .status-pending { background: #fff3cd; color: #856404; }
    .status-inactive { background: #f8d7da; color: #721c24; }

    /* Notification/Alert boxes */
    .alert {
        padding: 12px 16px;
        border-radius: 6px;
        margin: 10px 0;
        font-size: 13px;
        display: flex;
        align-items: center;
        gap: 10px;
    }
    .alert-info {
        background: linear-gradient(90deg, #e3f2fd 0%, #bbdefb 100%);
        border-left: 4px solid #2196f3;
        color: #1565c0;
    }
    .alert-success {
        background: linear-gradient(90deg, #e8f5e9 0%, #c8e6c9 100%);
        border-left: 4px solid #4caf50;
        color: #2e7d32;
    }
    .alert-warning {
        background: linear-gradient(90deg, #fff8e1 0%, #ffecb3 100%);
        border-left: 4px solid #ff9800;
        color: #e65100;
    }
    .alert-error {
        background: linear-gradient(90deg, #ffebee 0%, #ffcdd2 100%);
        border-left: 4px solid #f44336;
        color: #c62828;
    }

    /* Avatar and user info */
    .user-card {
        display: flex;
        align-items: center;
        gap: 12px;
        padding: 12px;
        background: #f8f9fa;
        border-radius: 8px;
        margin: 10px 0;
    }
    .avatar {
        width: 48px;
        height: 48px;
        border-radius: 50%;
        background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%);
        display: flex;
        align-items: center;
        justify-content: center;
        color: white;
        font-weight: bold;
        font-size: 18px;
    }
    .user-info {
        flex: 1;
    }
    .user-info .name {
        font-weight: 600;
        color: #2c3e50;
        margin-bottom: 2px;
    }
    .user-info .role {
        font-size: 12px;
        color: #7f8c8d;
    }

    /* Pricing card */
    .pricing-card {
        background: white;
        border-radius: 12px;
        padding: 24px;
        text-align: center;
        box-shadow: 0 4px 20px rgba(0,0,0,0.1);
        margin: 10px 0;
        border: 2px solid transparent;
    }
    .pricing-card.featured {
        border-color: #667eea;
        transform: scale(1.02);
    }
    .pricing-card .plan-name {
        font-size: 14px;
        color: #7f8c8d;
        text-transform: uppercase;
        letter-spacing: 1px;
    }
    .pricing-card .price {
        font-size: 36px;
        font-weight: bold;
        color: #2c3e50;
        margin: 10px 0;
    }
    .pricing-card .price span {
        font-size: 14px;
        color: #95a5a6;
        font-weight: normal;
    }
    .pricing-card .features {
        text-align: left;
        margin: 20px 0;
        font-size: 13px;
        color: #555;
    }
    .pricing-card .features div {
        padding: 6px 0;
        border-bottom: 1px solid #ecf0f1;
    }
    /* Tooltip style */
    .tooltip-demo {
        position: relative;
        display: inline-block;
        padding: 8px 16px;
        background: #3498db;
        color: white;
        border-radius: 4px;
        margin: 10px 0;
    }
    .tooltip-demo::after {
        content: "This is a tooltip!";
        position: absolute;
        bottom: 100%;
        left: 50%;
        transform: translateX(-50%);
        background: #2c3e50;
        color: white;
        padding: 6px 12px;
        border-radius: 4px;
        font-size: 12px;
        white-space: nowrap;
        margin-bottom: 8px;
    }
    .tooltip-demo::before {
        content: "";
        position: absolute;
        bottom: 100%;
        left: 50%;
        transform: translateX(-50%);
        border: 6px solid transparent;
        border-top-color: #2c3e50;
        margin-bottom: -4px;
    }

    /* Search box */
    .search-box {
        display: flex;
        gap: 0;
        margin: 10px 0;
    }
    .search-box input {
        flex: 1;
        padding: 10px 15px;
        border: 2px solid #ddd;
        border-right: none;
        border-radius: 6px 0 0 6px;
        font-size: 14px;
        outline: none;
    }
    .search-box input:focus {
        border-color: #3498db;
    }
    .search-box button {
        padding: 10px 20px;
        background: #3498db;
        color: white;
        border: none;
        border-radius: 0 6px 6px 0;
        cursor: pointer;
        font-size: 14px;
    }

    /* Tabs */
    .tabs {
        display: flex;
        border-bottom: 2px solid #ecf0f1;
        margin: 10px 0;
    }
    .tabs .tab {
        padding: 10px 20px;
        cursor: pointer;
        color: #7f8c8d;
        font-size: 14px;
        border-bottom: 2px solid transparent;
        margin-bottom: -2px;
        transition: all 0.2s;
    }
    .tabs .tab.active {
        color: #3498db;
        border-bottom-color: #3498db;
    }
    .tab-content {
        padding: 15px 0;
        font-size: 14px;
        color: #555;
    }

    /* Stats cards */
    .stat-card {
        background: white;
        border-radius: 8px;
        padding: 15px;
        box-shadow: 0 2px 8px rgba(0,0,0,0.08);
    }
    .stat-card .stat-value {
        font-size: 24px;
        font-weight: bold;
        color: #2c3e50;
    }
    .stat-card .stat-label {
        font-size: 12px;
        color: #95a5a6;
        margin-top: 4px;
    }
    .stat-card.gradient-1 {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
    }
    .stat-card.gradient-1 .stat-value,
    .stat-card.gradient-1 .stat-label {
        color: white;
    }
    .stat-card.gradient-2 {
        background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%);
        color: white;
    }
    .stat-card.gradient-2 .stat-value,
    .stat-card.gradient-2 .stat-label {
        color: white;
    }

    /* Timeline */
    .timeline {
        position: relative;
        margin: 15px 0;
        padding-left: 30px;
    }
    .timeline::before {
        content: "";
        position: absolute;
        left: 10px;
        top: 0;
        bottom: 0;
        width: 2px;
        background: #ecf0f1;
    }
    .timeline-item {
        position: relative;
        padding-bottom: 20px;
    }
    .timeline-item::before {
        content: "";
        position: absolute;
        left: -24px;
        top: 4px;
        width: 10px;
        height: 10px;
        border-radius: 50%;
        background: #3498db;
        border: 2px solid white;
        box-shadow: 0 0 0 2px #3498db;
    }
    .timeline-item .time {
        font-size: 11px;
        color: #95a5a6;
        margin-bottom: 4px;
    }
    .timeline-item .content {
        font-size: 13px;
        color: #2c3e50;
    }

    /* Modal overlay preview */
    .modal-preview {
        background: rgba(0, 0, 0, 0.5);
        border-radius: 8px;
        padding: 30px;
        margin: 15px 0;
    }
    .modal-box {
        background: white;
        border-radius: 12px;
        padding: 20px;
        max-width: 300px;
        margin: 0 auto;
        box-shadow: 0 10px 40px rgba(0,0,0,0.3);
    }
    .modal-box h4 {
        margin: 0 0 10px 0;
        color: #2c3e50;
    }
    .modal-box p {
        font-size: 13px;
        color: #7f8c8d;
        margin: 0 0 15px 0;
    }

    /* Skeleton loading */
    .skeleton {
        background: linear-gradient(90deg, #f0f0f0 25%, #e0e0e0 50%, #f0f0f0 75%);
        background-size: 200% 100%;
        border-radius: 4px;
        margin: 8px 0;
    }
    .skeleton-text {
        height: 14px;
        width: 80%;
    }
    .skeleton-title {
        height: 20px;
        width: 60%;
    }
    .skeleton-avatar {
        width: 40px;
        height: 40px;
        border-radius: 50%;
    }

    /* Footer */
    .footer {
        background: #2c3e50;
        color: #bdc3c7;
        padding: 20px;
        border-radius: 8px;
        margin-top: 20px;
        font-size: 13px;
    }
    .footer-grid {
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        gap: 20px;
    }
    .footer h5 {
        color: white;
        margin: 0 0 10px 0;
        font-size: 14px;
    }
    .footer a {
        color: #95a5a6;
        text-decoration: none;
        display: block;
        padding: 3px 0;
    }
    .footer-bottom {
        border-top: 1px solid #34495e;
        margin-top: 20px;
        padding-top: 15px;
        text-align: center;
        color: #7f8c8d;
    }

    /* Dropdown menu */
    .dropdown {
        position: relative;
        display: inline-block;
    }
    .dropdown-trigger {
        padding: 8px 16px;
        background: #ecf0f1;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        font-size: 14px;
    }
    .dropdown-menu {
        position: absolute;
        top: 100%;
        left: 0;
        background: white;
        border-radius: 6px;
        box-shadow: 0 4px 20px rgba(0,0,0,0.15);
        min-width: 160px;
        margin-top: 4px;
        padding: 6px 0;
    }
    .dropdown-menu a {
        display: block;
        padding: 8px 16px;
        color: #2c3e50;
        text-decoration: none;
        font-size: 13px;
    }
    .dropdown-menu a:hover {
        background: #f8f9fa;
    }

    /* List group */
    .list-group {
        border: 1px solid #ecf0f1;
        border-radius: 8px;
        overflow: hidden;
        margin: 10px 0;
    }
    .list-group-item {
        padding: 12px 16px;
        border-bottom: 1px solid #ecf0f1;
        display: flex;
        justify-content: space-between;
        align-items: center;
        font-size: 14px;
    }
    .list-group-item:last-child {
        border-bottom: none;
    }
    .list-group-item:hover {
        background: #f8f9fa;
    }
    .list-group-item .badge {
        background: #e74c3c;
        color: white;
        padding: 2px 8px;
        border-radius: 10px;
        font-size: 11px;
    }

    /* ============================================
       OVERFLOW PROPERTY
       ============================================ */
    .overflow-demo {
        display: flex;
        gap: 15px;
        flex-wrap: wrap;
        margin: 10px 0;
    }
    .overflow-box {
        width: 100px;
        height: 60px;
        border: 2px solid #3498db;
        border-radius: 6px;
        padding: 8px;
        font-size: 11px;
        background: #f8f9fa;
    }
    .overflow-visible { overflow: visible; }
    .overflow-hidden { overflow: hidden; }
    .overflow-scroll { overflow: scroll; }
    .overflow-auto { overflow: auto; }

    /* ============================================
       MIX-BLEND-MODE
       ============================================ */
    .blend-container {
        position: relative;
        width: 250px;
        height: 100px;
        background: linear-gradient(90deg, #e74c3c, #3498db);
        border-radius: 8px;
        margin: 10px 0;
    }
    .blend-box {
        position: absolute;
        width: 70px;
        height: 70px;
        top: 15px;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 9px;
        color: white;
        font-weight: bold;
    }
    .blend-multiply { left: 15px; background: #f1c40f; mix-blend-mode: multiply; }
    .blend-screen { left: 90px; background: #9b59b6; mix-blend-mode: screen; }
    .blend-overlay { left: 165px; background: #2ecc71; mix-blend-mode: overlay; }

    /* ============================================
       BLUR / FILTER EFFECTS
       ============================================ */
    .blur-demo {
        display: flex;
        gap: 15px;
        margin: 10px 0;
    }
    .blur-box {
        width: 70px;
        height: 50px;
        background: linear-gradient(135deg, #667eea, #764ba2);
        border-radius: 8px;
        display: flex;
        align-items: center;
        justify-content: center;
        color: white;
        font-size: 10px;
    }
    .blur-none { filter: blur(0); }
    .blur-sm { filter: blur(2px); }
    .blur-md { filter: blur(4px); }
    .blur-lg { filter: blur(8px); }

    .backdrop-blur-container {
        position: relative;
        background: linear-gradient(135deg, #e74c3c 0%, #f39c12 50%, #2ecc71 100%);
        border-radius: 8px;
        padding: 20px;
        margin: 10px 0;
    }
    .backdrop-blur-box {
        background: rgba(255, 255, 255, 0.2);
        backdrop-filter: blur(10px);
        -webkit-backdrop-filter: blur(10px);
        border-radius: 8px;
        padding: 12px;
        color: white;
        font-size: 12px;
    }

    /* ============================================
       TRANSFORM DEMOS
       ============================================ */
    .transform-grid {
        display: grid;
        grid-template-columns: repeat(4, 1fr);
        gap: 15px;
        margin: 15px 0;
    }
    .transform-item {
        background: #3498db;
        color: white;
        padding: 15px;
        border-radius: 8px;
        text-align: center;
        font-size: 11px;
    }
    .transform-rotate { transform: rotate(15deg); }
    .transform-scale { transform: scale(1.15); }
    .transform-skew { transform: skewX(-10deg); }
    .transform-translate { transform: translate(8px, -4px); }
    .transform-rotate-y { transform: rotateY(25deg); }
    .transform-rotate-x { transform: rotateX(15deg); }
    .transform-multiple { transform: rotate(8deg) scale(0.95) translateX(5px); }

    /* Transform origin */
    .origin-demo {
        display: flex;
        gap: 25px;
        margin: 15px 0;
        padding: 20px;
    }
    .origin-box {
        width: 50px;
        height: 50px;
        background: #9b59b6;
        color: white;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 9px;
        transform: rotate(30deg);
        text-align: center;
    }
    .origin-center { transform-origin: center; }
    .origin-top-left { transform-origin: top left; }
    .origin-bottom-right { transform-origin: bottom right; }

    /* Perspective */
    .perspective-container {
        perspective: 300px;
        perspective-origin: center;
        padding: 20px;
        margin: 10px 0;
    }
    .perspective-box {
        width: 100px;
        height: 60px;
        background: linear-gradient(135deg, #11998e, #38ef7d);
        color: white;
        display: flex;
        align-items: center;
        justify-content: center;
        border-radius: 8px;
        transform: rotateY(30deg);
        transform-style: preserve-3d;
        font-size: 11px;
    }

    /* 3D Transform with preserve-3d */
    .preserve-3d-demo {
        perspective: 500px;
        perspective-origin: 50% 50%;
        height: 120px;
        margin: 15px 0;
    }
    .cube-wrapper {
        position: relative;
        width: 60px;
        height: 60px;
        margin: 30px auto;
        transform-style: preserve-3d;
        transform: rotateX(-15deg) rotateY(25deg);
    }
    .cube-face {
        position: absolute;
        width: 60px;
        height: 60px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 12px;
        font-weight: bold;
        color: white;
    }
    .cube-front { background: rgba(52, 152, 219, 0.9); transform: translateZ(30px); }
    .cube-back { background: rgba(155, 89, 182, 0.9); transform: translateZ(-30px) rotateY(180deg); }
    .cube-left { background: rgba(46, 204, 113, 0.9); transform: translateX(-30px) rotateY(-90deg); }
    .cube-right { background: rgba(241, 196, 15, 0.9); transform: translateX(30px) rotateY(90deg); }
    .cube-top { background: rgba(231, 76, 60, 0.9); transform: translateY(-30px) rotateX(90deg); }
    .cube-bottom { background: rgba(52, 73, 94, 0.9); transform: translateY(30px) rotateX(-90deg); }

    /* Backface visibility */
    .backface-demo {
        display: flex;
        gap: 30px;
        margin: 15px 0;
        perspective: 300px;
    }
    .backface-card {
        width: 80px;
        height: 50px;
        background: #e74c3c;
        color: white;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 10px;
        border-radius: 6px;
        transform: rotateY(150deg);
    }
    .backface-visible { backface-visibility: visible; }
    .backface-hidden { backface-visibility: hidden; }

    /* ============================================
       BACKGROUND PROPERTIES
       ============================================ */
    .bg-clip-demo {
        display: flex;
        gap: 15px;
        flex-wrap: wrap;
        margin: 10px 0;
    }
    .bg-clip-box {
        width: 100px;
        height: 70px;
        padding: 12px;
        background: linear-gradient(135deg, #667eea, #764ba2);
        border: 8px dashed rgba(0,0,0,0.2);
        color: white;
        font-size: 10px;
        display: flex;
        align-items: center;
        justify-content: center;
        text-align: center;
    }
    .bg-clip-border { background-clip: border-box; }
    .bg-clip-padding { background-clip: padding-box; }
    .bg-clip-content { background-clip: content-box; }
    .bg-clip-text-demo {
        background: linear-gradient(90deg, #667eea, #764ba2, #f093fb);
        -webkit-background-clip: text;
        background-clip: text;
        -webkit-text-fill-color: transparent;
        font-size: 28px;
        font-weight: bold;
        margin: 10px 0;
    }

    /* ============================================
       BORDER STYLES
       ============================================ */
    .border-demo {
        display: flex;
        gap: 12px;
        flex-wrap: wrap;
        margin: 10px 0;
    }
    .border-box {
        width: 70px;
        height: 45px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 9px;
        background: #f8f9fa;
        text-align: center;
    }
    .border-solid { border: 3px solid #3498db; }
    .border-dashed { border: 3px dashed #e74c3c; }
    .border-dotted { border: 3px dotted #2ecc71; }
    .border-double { border: 4px double #9b59b6; }
    .border-groove { border: 4px groove #f39c12; }
    .border-ridge { border: 4px ridge #1abc9c; }
    .border-inset { border: 4px inset #34495e; }
    .border-outset { border: 4px outset #7f8c8d; }
    .border-mixed {
        border-top: 3px solid #e74c3c;
        border-right: 3px dashed #3498db;
        border-bottom: 3px dotted #2ecc71;
        border-left: 3px double #f39c12;
    }

    /* Border radius variations */
    .radius-demo {
        display: flex;
        gap: 12px;
        flex-wrap: wrap;
        margin: 10px 0;
    }
    .radius-box {
        width: 60px;
        height: 60px;
        background: #3498db;
        display: flex;
        align-items: center;
        justify-content: center;
        color: white;
        font-size: 8px;
        text-align: center;
    }
    .radius-none { border-radius: 0; }
    .radius-sm { border-radius: 4px; }
    .radius-md { border-radius: 12px; }
    .radius-lg { border-radius: 20px; }
    .radius-full { border-radius: 50%; }
    .radius-pill { border-radius: 30px; width: 90px; }
    .radius-asymmetric { border-radius: 20px 5px 25px 10px; }
    .radius-elliptical { border-radius: 50% / 25%; }

    /* Outline */
    .outline-demo {
        display: flex;
        gap: 25px;
        margin: 15px 0;
    }
    .outline-box {
        width: 70px;
        height: 45px;
        background: #f8f9fa;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 9px;
        text-align: center;
    }
    .outline-solid { outline: 3px solid #3498db; }
    .outline-dashed { outline: 3px dashed #e74c3c; }
    .outline-offset { outline: 3px solid #2ecc71; outline-offset: 4px; }

    /* ============================================
       TEXT PROPERTIES
       ============================================ */
    .text-fill-demo {
        font-size: 24px;
        font-weight: bold;
        background: linear-gradient(90deg, #667eea, #764ba2, #f093fb);
        -webkit-background-clip: text;
        background-clip: text;
        -webkit-text-fill-color: transparent;
    }
    .text-stroke-demo {
        font-size: 28px;
        font-weight: bold;
        color: white;
        -webkit-text-stroke: 2px #2c3e50;
    }
    .text-stroke-only {
        font-size: 28px;
        font-weight: bold;
        -webkit-text-fill-color: transparent;
        -webkit-text-stroke: 1px #3498db;
    }

    /* Font weights */
    .font-light { font-weight: 300; }
    .font-normal { font-weight: 400; }
    .font-medium { font-weight: 500; }
    .font-semibold { font-weight: 600; }
    .font-bold { font-weight: 700; }

    /* Letter spacing */
    .letter-tight { letter-spacing: -1px; }
    .letter-normal { letter-spacing: 0; }
    .letter-wide { letter-spacing: 2px; }
    .letter-wider { letter-spacing: 4px; }

    /* Line height */
    .line-tight { line-height: 1.0; }
    .line-normal { line-height: 1.5; }
    .line-relaxed { line-height: 2.0; }

    /* Text transform */
    .text-upper { text-transform: uppercase; }
    .text-lower { text-transform: lowercase; }
    .text-capitalize { text-transform: capitalize; }

    /* Text decoration */
    .text-underline { text-decoration: underline; }
    .text-overline { text-decoration: overline; }
    .text-line-through { text-decoration: line-through; }
    .text-decoration-wavy { text-decoration: underline wavy #e74c3c; }
    .text-decoration-double { text-decoration: underline double #3498db; }
    .text-decoration-dotted { text-decoration: underline dotted #2ecc71; }

    /* Text shadow */
    .text-shadow-sm { text-shadow: 1px 1px 2px rgba(0,0,0,0.3); }
    .text-shadow-md { text-shadow: 2px 2px 4px rgba(0,0,0,0.4); }
    .text-shadow-lg { text-shadow: 3px 3px 6px rgba(0,0,0,0.5); }
    .text-shadow-glow { text-shadow: 0 0 10px #3498db, 0 0 20px #3498db; }
    .text-shadow-multi {
        text-shadow: 1px 1px 0 #e74c3c, 2px 2px 0 #f39c12, 3px 3px 0 #2ecc71;
    }

    /* Writing mode */
    .writing-vertical { writing-mode: vertical-rl; height: 80px; }
    .writing-vertical-lr { writing-mode: vertical-lr; height: 80px; }
    .text-rtl { direction: rtl; }

    /* ============================================
       BOX SHADOW VARIATIONS
       ============================================ */
    .shadow-demo {
        display: flex;
        gap: 15px;
        flex-wrap: wrap;
        margin: 15px 0;
    }
    .shadow-box {
        width: 80px;
        height: 55px;
        background: white;
        border-radius: 6px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 9px;
        text-align: center;
    }
    .shadow-sm { box-shadow: 0 1px 3px rgba(0,0,0,0.12); }
    .shadow-md { box-shadow: 0 4px 6px rgba(0,0,0,0.15); }
    .shadow-lg { box-shadow: 0 10px 20px rgba(0,0,0,0.2); }
    .shadow-xl { box-shadow: 0 15px 35px rgba(0,0,0,0.25); }
    .shadow-colored { box-shadow: 0 8px 25px rgba(52, 152, 219, 0.4); }
    .shadow-multi {
        box-shadow:
            0 2px 4px rgba(0,0,0,0.1),
            0 8px 16px rgba(0,0,0,0.1);
    }

    /* Inset shadows */
    .shadow-inset { box-shadow: inset 0 2px 6px rgba(0,0,0,0.2); }
    .shadow-inset-deep { box-shadow: inset 0 4px 10px rgba(0,0,0,0.3); }
    .shadow-inset-all { box-shadow: inset 0 0 8px rgba(0,0,0,0.2); }

    /* Spread radius */
    .shadow-spread-pos { box-shadow: 0 4px 8px 4px rgba(52,152,219,0.25); }
    .shadow-spread-neg { box-shadow: 0 4px 15px -4px rgba(0,0,0,0.4); }
    .shadow-spread-only { box-shadow: 0 0 0 4px #3498db; }

    /* Combined shadows */
    .shadow-combined {
        box-shadow:
            0 4px 10px rgba(0,0,0,0.15),
            inset 0 -2px 4px rgba(0,0,0,0.1);
    }
    .shadow-neumorphic {
        background: #e0e5ec;
        box-shadow:
            6px 6px 12px #a3b1c6,
            -6px -6px 12px #ffffff;
    }

    /* ============================================
       OPACITY VARIATIONS (extended)
       ============================================ */
    .opacity-grid {
        display: flex;
        gap: 8px;
        margin: 10px 0;
    }
    .opacity-item {
        width: 45px;
        height: 45px;
        background: #3498db;
        border-radius: 6px;
        display: flex;
        align-items: center;
        justify-content: center;
        color: white;
        font-size: 10px;
    }
</style>

<script>
    function changeText() {
        document.querySelector("#dynamic-text").textContent = "Text has been changed!";
    }
    function toggleVisibility() {
        const el = document.querySelector(".toggle-target");
        el.style.opacity = el.style.opacity === "0.3" ? "1" : "0.3";
    }

    // ============================================
    // LAYOUT TREE EXTRACTION
    // ============================================

    function parseColor(colorStr) {
        if (!colorStr || colorStr === 'transparent' || colorStr === 'rgba(0, 0, 0, 0)') {
            return null;
        }
        const match = colorStr.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*([\d.]+))?\)/);
        if (match) {
            return {
                r: parseInt(match[1]) / 255,
                g: parseInt(match[2]) / 255,
                b: parseInt(match[3]) / 255,
                a: match[4] !== undefined ? parseFloat(match[4]) : 1
            };
        }
        return null;
    }

    function parseBoxShadow(shadowStr) {
        if (!shadowStr || shadowStr === 'none') return null;
        const shadows = [];
        // Computed style format: [inset] rgba(...) offset-x offset-y blur [spread]
        // or: rgba(...) offset-x offset-y blur [spread] [inset]
        const shadowRegex = /(inset\s+)?(rgba?\([^)]+\))\s+(-?[\d.]+)px\s+(-?[\d.]+)px\s+(-?[\d.]+)px(?:\s+(-?[\d.]+)px)?(\s+inset)?/gi;
        let match;
        while ((match = shadowRegex.exec(shadowStr)) !== null) {
            const color = parseColor(match[2]);
            if (color) {
                shadows.push({
                    inset: !!(match[1] || match[7]),
                    offset_x: parseFloat(match[3]),
                    offset_y: parseFloat(match[4]),
                    blur: parseFloat(match[5]),
                    spread: match[6] ? parseFloat(match[6]) : 0,
                    color: color
                });
            }
        }
        return shadows.length > 0 ? shadows : null;
    }

    function createsStackingContext(element) {
        if (element === document.documentElement) return true;
        const style = getComputedStyle(element);
        if (style.position !== 'static' && style.zIndex !== 'auto') return true;
        const parent = element.parentElement;
        if (parent) {
            const parentDisplay = getComputedStyle(parent).display;
            if ((parentDisplay === 'flex' || parentDisplay === 'grid' ||
                 parentDisplay === 'inline-flex' || parentDisplay === 'inline-grid') &&
                style.zIndex !== 'auto') {
                return true;
            }
        }
        if (parseFloat(style.opacity) < 1) return true;
        if (style.transform !== 'none') return true;
        if (style.filter !== 'none') return true;
        if (style.backdropFilter && style.backdropFilter !== 'none') return true;
        if (style.isolation === 'isolate') return true;
        if (style.willChange && (
            style.willChange.includes('transform') ||
            style.willChange.includes('opacity') ||
            style.willChange.includes('filter'))) return true;
        if (style.contain && (style.contain.includes('paint') || style.contain.includes('layout'))) return true;
        if (style.clipPath && style.clipPath !== 'none') return true;
        if (style.mask && style.mask !== 'none') return true;
        if (style.webkitMask && style.webkitMask !== 'none') return true;
        if (style.mixBlendMode && style.mixBlendMode !== 'normal') return true;
        return false;
    }

    function isStacked(element) {
        const style = getComputedStyle(element);
        return style.position !== 'static' || createsStackingContext(element);
    }

    function hasLayer(element) {
        const style = getComputedStyle(element);
        return (
            createsStackingContext(element) ||
            (style.overflow !== 'visible' && style.overflow !== '') ||
            style.transform !== 'none' ||
            (style.willChange && style.willChange !== 'auto')
        );
    }

    // Check if a pseudo-element exists and has content
    function hasPseudoElement(element, pseudo) {
        const style = getComputedStyle(element, pseudo);
        const content = style.content;
        // content is 'none' or 'normal' if pseudo-element doesn't exist
        // content: "" (empty string) IS valid and creates a pseudo-element
        return content && content !== 'none' && content !== 'normal';
    }

    // Get computed style info for a pseudo-element
    function getPseudoComputedStyleInfo(element, pseudo) {
        const style = getComputedStyle(element, pseudo);
        return {
            display: style.display,
            position: style.position,
            opacity: parseFloat(style.opacity),
            z_index: style.zIndex === 'auto' ? 0 : parseInt(style.zIndex),
            has_transform: style.transform !== 'none',
            overflow_x: style.overflowX,
            overflow_y: style.overflowY,
            visibility: style.visibility,
            has_filter: style.filter !== 'none',
            has_backdrop_filter: style.backdropFilter ? style.backdropFilter !== 'none' : false,
            has_clip_path: style.clipPath ? style.clipPath !== 'none' : false,
            has_mask: false,
            is_isolated: style.isolation === 'isolate',
            has_will_change_transform: false,
            has_will_change_opacity: false,
            contain_paint: false,
            contain_layout: false,
            letter_spacing: parseFloat(style.letterSpacing) || 0,
            word_spacing: parseFloat(style.wordSpacing) || 0,
            font_size: parseFloat(style.fontSize),
            font_family: style.fontFamily.split(',')[0].replace(/['"]/g, '').trim(),
            font_weight: parseInt(style.fontWeight),
            font_style: style.fontStyle
        };
    }

    // Estimate pseudo-element geometry based on parent and styles
    function getPseudoGeometry(element, pseudo) {
        const parentRect = element.getBoundingClientRect();
        const style = getComputedStyle(element, pseudo);

        // Get dimensions
        let width = parseFloat(style.width) || 0;
        let height = parseFloat(style.height) || 0;

        // For positioned pseudo-elements, calculate position
        const position = style.position;
        let x = parentRect.x;
        let y = parentRect.y;

        if (position === 'absolute') {
            const top = parseFloat(style.top);
            const left = parseFloat(style.left);
            const right = parseFloat(style.right);
            const bottom = parseFloat(style.bottom);

            if (!isNaN(top)) y = parentRect.y + top;
            else if (!isNaN(bottom)) y = parentRect.y + parentRect.height - bottom - height;

            if (!isNaN(left)) x = parentRect.x + left;
            else if (!isNaN(right)) x = parentRect.x + parentRect.width - right - width;
        }

        return {
            x: x + window.scrollX,
            y: y + window.scrollY,
            width: width,
            height: height
        };
    }

    // Create a pseudo-element node
    function createPseudoElementNode(id, element, pseudo, depth) {
        const style = getComputedStyle(element, pseudo);
        const position = style.position;
        const isPositioned = position !== 'static';

        let name = 'LayoutBlockFlow';
        if (isPositioned) name += ' (positioned, children-inline)';
        else name += ' (children-inline)';
        name += ` ${pseudo}`;

        const entry = {
            id,
            name,
            z_index: style.zIndex === 'auto' ? 0 : parseInt(style.zIndex),
            is_stacking_context: isPositioned && style.zIndex !== 'auto',
            is_stacked: isPositioned,
            has_layer: isPositioned,
            computed_style: getPseudoComputedStyleInfo(element, pseudo),
            geometry: getPseudoGeometry(element, pseudo),
            padding: {
                top: parseFloat(style.paddingTop) || 0,
                right: parseFloat(style.paddingRight) || 0,
                bottom: parseFloat(style.paddingBottom) || 0,
                left: parseFloat(style.paddingLeft) || 0
            },
            margin: {
                top: parseFloat(style.marginTop) || 0,
                right: parseFloat(style.marginRight) || 0,
                bottom: parseFloat(style.marginBottom) || 0,
                left: parseFloat(style.marginLeft) || 0
            },
            depth,
            children: []
        };

        // Add background color if present
        const bgColor = parseColor(style.backgroundColor);
        if (bgColor && bgColor.a > 0) entry.background_color = bgColor;

        // Add border radius if present
        const tl = parseFloat(style.borderTopLeftRadius) || 0;
        const tr = parseFloat(style.borderTopRightRadius) || 0;
        const br = parseFloat(style.borderBottomRightRadius) || 0;
        const bl = parseFloat(style.borderBottomLeftRadius) || 0;
        if (tl || tr || br || bl) {
            entry.border_radii = [tl, tl, tr, tr, br, br, bl, bl];
        }

        // Add box shadow if present
        const boxShadow = parseBoxShadow(style.boxShadow);
        if (boxShadow) entry.box_shadow = boxShadow;

        return entry;
    }

    // Detect form element types that have shadow DOM
    function getFormElementInfo(element) {
        const tag = element.tagName;
        if (tag === 'INPUT') {
            const type = element.type || 'text';
            if (['text', 'email', 'password', 'search', 'tel', 'url'].includes(type)) {
                return { type: 'text-control-single', inputType: type };
            } else if (type === 'range') {
                return { type: 'slider', inputType: type };
            }
        } else if (tag === 'TEXTAREA') {
            return { type: 'text-control-multi' };
        } else if (tag === 'SELECT') {
            return { type: 'select' };
        }
        return null;
    }

    // Create shadow DOM children for text input controls
    function createTextControlShadowChildren(element, parentId, depth, nodes, currentIdRef) {
        const rect = element.getBoundingClientRect();
        const style = getComputedStyle(element);
        const childIds = [];

        // Create LayoutTextControlInnerEditor
        const editorId = currentIdRef.id++;
        const editorEntry = {
            id: editorId,
            name: 'LayoutTextControlInnerEditor DIV',
            z_index: 0,
            is_stacking_context: false,
            is_stacked: false,
            has_layer: false,
            computed_style: {
                display: 'block',
                position: 'static',
                opacity: 1,
                z_index: 0,
                has_transform: false,
                overflow_x: 'visible',
                overflow_y: 'visible',
                visibility: style.visibility,
                has_filter: false,
                has_backdrop_filter: false,
                has_clip_path: false,
                has_mask: false,
                is_isolated: false,
                has_will_change_transform: false,
                has_will_change_opacity: false,
                contain_paint: false,
                contain_layout: false,
                letter_spacing: parseFloat(style.letterSpacing) || 0,
                word_spacing: parseFloat(style.wordSpacing) || 0,
                font_size: parseFloat(style.fontSize),
                font_family: style.fontFamily.split(',')[0].replace(/['"]/g, '').trim(),
                font_weight: parseInt(style.fontWeight),
                font_style: style.fontStyle
            },
            geometry: {
                x: rect.x + window.scrollX + parseFloat(style.paddingLeft),
                y: rect.y + window.scrollY + parseFloat(style.paddingTop),
                width: rect.width - parseFloat(style.paddingLeft) - parseFloat(style.paddingRight),
                height: rect.height - parseFloat(style.paddingTop) - parseFloat(style.paddingBottom)
            },
            padding: { top: 0, right: 0, bottom: 0, left: 0 },
            margin: { top: 0, right: 0, bottom: 0, left: 0 },
            depth: depth,
            children: []
        };
        nodes.push(editorEntry);
        childIds.push(editorId);

        // Create LayoutText for placeholder or value
        const text = element.value || element.placeholder || '';
        if (text) {
            const textId = currentIdRef.id++;
            const textEntry = {
                id: textId,
                name: 'LayoutText #text',
                z_index: 0,
                is_stacking_context: false,
                is_stacked: false,
                has_layer: false,
                computed_style: editorEntry.computed_style,
                text: text,
                fragments: [{
                    x: editorEntry.geometry.x,
                    y: editorEntry.geometry.y,
                    width: editorEntry.geometry.width,
                    height: parseFloat(style.lineHeight) || parseFloat(style.fontSize) * 1.2,
                    start: 0,
                    end: text.length,
                    runs: [{ glyphs: null, positions: null }]
                }],
                depth: depth + 1,
                children: []
            };
            nodes.push(textEntry);
            editorEntry.children.push(textId);
        }

        return childIds;
    }

    function getLayoutObjectName(node) {
        if (node.nodeType === Node.TEXT_NODE) {
            return 'LayoutText #text';
        }
        const tag = node.tagName;

        // Special case for BR element
        if (tag === 'BR') {
            return 'LayoutBR BR';
        }

        // Special cases for form elements with shadow DOM
        const formInfo = getFormElementInfo(node);
        if (formInfo) {
            if (formInfo.type === 'text-control-single') {
                return 'LayoutTextControlSingleLine (inline) INPUT';
            } else if (formInfo.type === 'text-control-multi') {
                return 'LayoutTextControlMultiLine (inline) TEXTAREA';
            } else if (formInfo.type === 'select') {
                return 'LayoutFlexibleBox (inline) SELECT';
            } else if (formInfo.type === 'slider') {
                return 'LayoutFlexibleBox (inline) INPUT';
            }
        }

        const style = getComputedStyle(node);
        const display = style.display;
        let layoutType;
        switch (display) {
            case 'block':
            case 'flow-root':
                layoutType = 'LayoutBlockFlow';
                break;
            case 'inline':
                layoutType = 'LayoutInline';
                break;
            case 'inline-block':
                layoutType = 'LayoutBlockFlow';
                break;
            case 'flex':
            case 'inline-flex':
                layoutType = 'LayoutFlexibleBox';
                break;
            case 'grid':
            case 'inline-grid':
                layoutType = 'LayoutGrid';
                break;
            case 'table':
                layoutType = 'LayoutTable';
                break;
            case 'table-row-group':
                layoutType = 'LayoutTableSection';
                break;
            case 'table-header-group':
                layoutType = 'LayoutTableSection';
                break;
            case 'table-row':
                layoutType = 'LayoutTableRow';
                break;
            case 'table-cell':
                layoutType = 'LayoutTableCell';
                break;
            default:
                layoutType = 'LayoutBlockFlow';
        }
        const hasInlineChildren = Array.from(node.childNodes).some(child => {
            if (child.nodeType === Node.TEXT_NODE) return child.textContent.trim();
            if (child.nodeType === Node.ELEMENT_NODE) {
                const childDisplay = getComputedStyle(child).display;
                return childDisplay === 'inline' || childDisplay === 'inline-block';
            }
            return false;
        });
        let name = layoutType;
        if (hasInlineChildren && layoutType === 'LayoutBlockFlow') {
            name += ' (children-inline)';
        }
        name += ` ${tag}`;
        // Add class name if present
        if (node.className && typeof node.className === 'string' && node.className.trim()) {
            const firstClass = node.className.trim().split(/\s+/)[0];
            name += ` class='${firstClass}'.${firstClass}`;
        }
        // Add id if present
        if (node.id) {
            name += ` id='${node.id}'#${node.id}`;
        }
        return name;
    }

    function getComputedStyleInfo(element) {
        const style = getComputedStyle(element);
        return {
            display: style.display,
            position: style.position,
            opacity: parseFloat(style.opacity),
            z_index: style.zIndex === 'auto' ? 0 : parseInt(style.zIndex),
            has_transform: style.transform !== 'none',
            overflow_x: style.overflowX,
            overflow_y: style.overflowY,
            visibility: style.visibility,
            has_filter: style.filter !== 'none',
            has_backdrop_filter: style.backdropFilter ? style.backdropFilter !== 'none' : false,
            has_clip_path: style.clipPath ? style.clipPath !== 'none' : false,
            has_mask: (style.mask && style.mask !== 'none') || (style.maskImage && style.maskImage !== 'none'),
            is_isolated: style.isolation === 'isolate',
            has_will_change_transform: style.willChange ? style.willChange.includes('transform') : false,
            has_will_change_opacity: style.willChange ? style.willChange.includes('opacity') : false,
            contain_paint: style.contain ? style.contain.includes('paint') : false,
            contain_layout: style.contain ? style.contain.includes('layout') : false,
            letter_spacing: parseFloat(style.letterSpacing) || 0,
            word_spacing: parseFloat(style.wordSpacing) || 0,
            font_size: parseFloat(style.fontSize),
            font_family: style.fontFamily.split(',')[0].replace(/['"]/g, '').trim(),
            font_weight: parseInt(style.fontWeight),
            font_style: style.fontStyle
        };
    }

    function getGeometry(element) {
        const rect = element.getBoundingClientRect();
        return {
            x: rect.x + window.scrollX,
            y: rect.y + window.scrollY,
            width: rect.width,
            height: rect.height
        };
    }

    function getTextFragments(textNode) {
        const range = document.createRange();
        range.selectNodeContents(textNode);
        const rects = range.getClientRects();
        return Array.from(rects).map((rect) => ({
            x: rect.x + window.scrollX,
            y: rect.y + window.scrollY,
            width: rect.width,
            height: rect.height,
            start: 0,
            end: textNode.textContent.length,
            runs: [{ glyphs: null, positions: null }]
        }));
    }

    function getPadding(element) {
        const style = getComputedStyle(element);
        return {
            top: parseFloat(style.paddingTop) || 0,
            right: parseFloat(style.paddingRight) || 0,
            bottom: parseFloat(style.paddingBottom) || 0,
            left: parseFloat(style.paddingLeft) || 0
        };
    }

    function getMargin(element) {
        const style = getComputedStyle(element);
        return {
            top: parseFloat(style.marginTop) || 0,
            right: parseFloat(style.marginRight) || 0,
            bottom: parseFloat(style.marginBottom) || 0,
            left: parseFloat(style.marginLeft) || 0
        };
    }

    function getBorderWidths(element) {
        const style = getComputedStyle(element);
        const widths = {
            top: parseFloat(style.borderTopWidth) || 0,
            right: parseFloat(style.borderRightWidth) || 0,
            bottom: parseFloat(style.borderBottomWidth) || 0,
            left: parseFloat(style.borderLeftWidth) || 0
        };
        if (widths.top || widths.right || widths.bottom || widths.left) {
            return widths;
        }
        return null;
    }

    function getBorderColors(element) {
        const style = getComputedStyle(element);
        return {
            top: parseColor(style.borderTopColor),
            right: parseColor(style.borderRightColor),
            bottom: parseColor(style.borderBottomColor),
            left: parseColor(style.borderLeftColor)
        };
    }

    function getBorderRadii(element) {
        const style = getComputedStyle(element);
        const tl = parseFloat(style.borderTopLeftRadius) || 0;
        const tr = parseFloat(style.borderTopRightRadius) || 0;
        const br = parseFloat(style.borderBottomRightRadius) || 0;
        const bl = parseFloat(style.borderBottomLeftRadius) || 0;
        const radii = [tl, tl, tr, tr, br, br, bl, bl];
        if (radii.some(r => r > 0)) {
            return radii;
        }
        return null;
    }

    function getBackgroundColor(element) {
        const style = getComputedStyle(element);
        const color = parseColor(style.backgroundColor);
        if (color && color.a > 0) {
            return color;
        }
        return null;
    }

    // Check if a display value creates a block-level box
    function isBlockLevel(display) {
        return ['block', 'flex', 'grid', 'table', 'flow-root',
                'table-row-group', 'table-header-group', 'table-footer-group',
                'table-row', 'table-cell', 'table-caption', 'list-item'].includes(display);
    }

    // Create an anonymous block wrapper
    function createAnonymousBlock(id, parentElement, depth, inlineChildren) {
        const parentStyle = getComputedStyle(parentElement);
        const parentRect = parentElement.getBoundingClientRect();

        // Calculate geometry from inline children
        let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
        for (const child of inlineChildren) {
            if (child.isText) {
                const range = document.createRange();
                range.selectNodeContents(child.node);
                const rects = range.getClientRects();
                for (const rect of rects) {
                    minX = Math.min(minX, rect.x);
                    minY = Math.min(minY, rect.y);
                    maxX = Math.max(maxX, rect.x + rect.width);
                    maxY = Math.max(maxY, rect.y + rect.height);
                }
            } else {
                const rect = child.node.getBoundingClientRect();
                minX = Math.min(minX, rect.x);
                minY = Math.min(minY, rect.y);
                maxX = Math.max(maxX, rect.x + rect.width);
                maxY = Math.max(maxY, rect.y + rect.height);
            }
        }

        // If no geometry found (e.g., all whitespace), use parent geometry
        if (minX === Infinity) {
            minX = parentRect.x;
            minY = parentRect.y;
            maxX = parentRect.x;
            maxY = parentRect.y;
        }

        return {
            id,
            name: 'LayoutBlockFlow (anonymous, children-inline)',
            z_index: 0,
            is_stacking_context: false,
            is_stacked: false,
            has_layer: false,
            computed_style: {
                display: 'block',
                position: 'static',
                opacity: parseFloat(parentStyle.opacity),
                z_index: 0,
                has_transform: false,
                overflow_x: 'visible',
                overflow_y: 'visible',
                visibility: parentStyle.visibility,
                has_filter: false,
                has_backdrop_filter: false,
                has_clip_path: false,
                has_mask: false,
                is_isolated: false,
                has_will_change_transform: false,
                has_will_change_opacity: false,
                contain_paint: false,
                contain_layout: false,
                letter_spacing: parseFloat(parentStyle.letterSpacing) || 0,
                word_spacing: parseFloat(parentStyle.wordSpacing) || 0,
                font_size: parseFloat(parentStyle.fontSize),
                font_family: parentStyle.fontFamily.split(',')[0].replace(/['"]/g, '').trim(),
                font_weight: parseInt(parentStyle.fontWeight),
                font_style: parentStyle.fontStyle
            },
            geometry: {
                x: minX + window.scrollX,
                y: minY + window.scrollY,
                width: maxX - minX,
                height: maxY - minY
            },
            padding: { top: 0, right: 0, bottom: 0, left: 0 },
            margin: { top: 0, right: 0, bottom: 0, left: 0 },
            depth,
            children: []
        };
    }

    function extractLayoutTree(root = document.documentElement) {
        const nodes = [];
        let currentId = 0;

        function processNode(node, depth) {
            const id = currentId++;
            const isTextNode = node.nodeType === Node.TEXT_NODE;
            const element = isTextNode ? node.parentElement : node;

            const entry = {
                id,
                name: getLayoutObjectName(node),
                z_index: isTextNode ? 0 : (parseInt(getComputedStyle(node).zIndex) || 0),
                is_stacking_context: isTextNode ? false : createsStackingContext(node),
                is_stacked: isTextNode ? false : isStacked(node),
                has_layer: isTextNode ? false : hasLayer(node),
                computed_style: isTextNode ? getComputedStyleInfo(element) : getComputedStyleInfo(node),
                depth,
                children: []
            };

            if (!isTextNode) {
                entry.tag = node.tagName.toLowerCase();
            }

            if (isTextNode) {
                entry.text = node.textContent;
                const fragments = getTextFragments(node);
                if (fragments.length > 0) {
                    entry.fragments = fragments;
                } else {
                    // Whitespace text node - no visible geometry but still exists
                    entry.fragments = [];
                }
            } else {
                entry.geometry = getGeometry(node);
                entry.padding = getPadding(node);
                entry.margin = getMargin(node);

                const bgColor = getBackgroundColor(node);
                if (bgColor) entry.background_color = bgColor;

                const borderRadii = getBorderRadii(node);
                if (borderRadii) entry.border_radii = borderRadii;

                const borderWidths = getBorderWidths(node);
                if (borderWidths) {
                    entry.border_widths = borderWidths;
                    entry.border_colors = getBorderColors(node);
                }

                const boxShadow = parseBoxShadow(getComputedStyle(node).boxShadow);
                if (boxShadow) entry.box_shadow = boxShadow;
            }

            if (entry.has_layer && !isTextNode) {
                entry.is_self_painting = createsStackingContext(node);
            }

            nodes.push(entry);

            if (!isTextNode) {
                const childIds = [];
                const style = getComputedStyle(node);
                const display = style.display;
                const isFlexOrGrid = ['flex', 'inline-flex', 'grid', 'inline-grid'].includes(display);
                const isBlock = ['block', 'flow-root'].includes(display);

                // Check for form elements with shadow DOM
                const formInfo = getFormElementInfo(node);
                if (formInfo && (formInfo.type === 'text-control-single' || formInfo.type === 'text-control-multi')) {
                    // Create shadow DOM children for text controls
                    const currentIdRef = { id: currentId };
                    const shadowChildIds = createTextControlShadowChildren(node, id, depth + 1, nodes, currentIdRef);
                    currentId = currentIdRef.id;
                    childIds.push(...shadowChildIds);
                    entry.children = childIds;
                    return id;
                }

                // Check for ::before pseudo-element
                if (hasPseudoElement(node, '::before')) {
                    const beforeId = currentId++;
                    const beforeEntry = createPseudoElementNode(beforeId, node, '::before', depth + 1);
                    nodes.push(beforeEntry);
                    childIds.push(beforeId);

                    // Create text fragment child for the pseudo-element content
                    const textFragId = currentId++;
                    const textFragEntry = {
                        id: textFragId,
                        name: 'LayoutTextFragment (anonymous)',
                        z_index: 0,
                        is_stacking_context: false,
                        is_stacked: false,
                        has_layer: false,
                        computed_style: beforeEntry.computed_style,
                        depth: depth + 2,
                        children: []
                    };
                    nodes.push(textFragEntry);
                    beforeEntry.children.push(textFragId);
                }

                // Collect valid children
                // Whitespace text nodes are only kept when between inline elements (not at boundaries)
                const rawChildren = [];
                for (const child of node.childNodes) {
                    if (child.nodeType === Node.ELEMENT_NODE) {
                        const tag = child.tagName.toLowerCase();
                        if (!['script', 'style', 'noscript'].includes(tag)) {
                            const childStyle = getComputedStyle(child);
                            if (childStyle.display !== 'none') {
                                rawChildren.push({ node: child, isText: false, isBlock: isBlockLevel(childStyle.display), isWhitespace: false });
                            }
                        }
                    } else if (child.nodeType === Node.TEXT_NODE) {
                        if (child.textContent.trim()) {
                            rawChildren.push({ node: child, isText: true, isBlock: false, isWhitespace: false });
                        } else if (child.textContent.length > 0) {
                            rawChildren.push({ node: child, isText: true, isBlock: false, isWhitespace: true });
                        }
                    }
                }

                // Filter: keep whitespace only when it's trailing after an inline element
                // (Chromium keeps trailing whitespace after inline elements in anonymous blocks)
                const validChildren = [];
                for (let i = 0; i < rawChildren.length; i++) {
                    const child = rawChildren[i];
                    if (!child.isWhitespace) {
                        validChildren.push(child);
                    } else {
                        // Check adjacent elements
                        const prevNonWS = rawChildren.slice(0, i).reverse().find(c => !c.isWhitespace);
                        const nextNonWS = rawChildren.slice(i + 1).find(c => !c.isWhitespace);
                        // Keep whitespace if:
                        // 1. It's after an inline element AND (followed by a block OR is last in run)
                        const afterInline = prevNonWS && !prevNonWS.isBlock;
                        const beforeBlockOrEnd = !nextNonWS || nextNonWS.isBlock;
                        if (afterInline && beforeBlockOrEnd) {
                            validChildren.push(child);
                        }
                    }
                }

                // Check if we have mixed block/inline content
                const hasBlockChild = validChildren.some(c => c.isBlock);
                const hasInlineContent = validChildren.some(c => !c.isBlock);
                const needsAnonymousBlocks = (isFlexOrGrid && hasInlineContent) ||
                                              (isBlock && hasBlockChild && hasInlineContent);

                if (needsAnonymousBlocks) {
                    // Group consecutive inline content and wrap in anonymous blocks
                    let inlineRun = [];

                    const flushInlineRun = () => {
                        if (inlineRun.length > 0) {
                            // Create anonymous block for this inline run
                            const anonId = currentId++;
                            const anonEntry = createAnonymousBlock(anonId, node, depth + 1, inlineRun);
                            nodes.push(anonEntry);

                            // Process children of anonymous block
                            const anonChildIds = [];
                            for (const inlineChild of inlineRun) {
                                anonChildIds.push(processNode(inlineChild.node, depth + 2));
                            }
                            anonEntry.children = anonChildIds;

                            childIds.push(anonId);
                            inlineRun = [];
                        }
                    };

                    for (const child of validChildren) {
                        if (child.isBlock) {
                            flushInlineRun();
                            childIds.push(processNode(child.node, depth + 1));
                        } else {
                            inlineRun.push(child);
                        }
                    }
                    flushInlineRun();
                } else {
                    // No anonymous blocks needed
                    for (const child of validChildren) {
                        childIds.push(processNode(child.node, depth + 1));
                    }
                }

                // Check for ::after pseudo-element
                if (hasPseudoElement(node, '::after')) {
                    const afterId = currentId++;
                    const afterEntry = createPseudoElementNode(afterId, node, '::after', depth + 1);
                    nodes.push(afterEntry);
                    childIds.push(afterId);

                    // Create text fragment child for the pseudo-element content
                    const textFragId = currentId++;
                    const textFragEntry = {
                        id: textFragId,
                        name: 'LayoutTextFragment (anonymous)',
                        z_index: 0,
                        is_stacking_context: false,
                        is_stacked: false,
                        has_layer: false,
                        computed_style: afterEntry.computed_style,
                        depth: depth + 2,
                        children: []
                    };
                    nodes.push(textFragEntry);
                    afterEntry.children.push(textFragId);
                }

                entry.children = childIds;
            }

            return id;
        }

        const layoutView = {
            id: currentId++,
            name: 'LayoutView #document',
            z_index: 0,
            is_stacking_context: true,
            is_stacked: true,
            has_layer: true,
            is_self_painting: true,
            computed_style: {
                display: 'block',
                position: 'absolute',
                opacity: 1,
                z_index: 0,
                has_transform: false,
                overflow_x: 'auto',
                overflow_y: 'auto',
                visibility: 'visible',
                has_filter: false,
                has_backdrop_filter: false,
                has_clip_path: false,
                has_mask: false,
                is_isolated: false,
                has_will_change_transform: false,
                has_will_change_opacity: false,
                contain_paint: false,
                contain_layout: false,
                letter_spacing: 0,
                word_spacing: 0,
                font_size: parseFloat(getComputedStyle(document.documentElement).fontSize),
                font_family: getComputedStyle(document.documentElement).fontFamily.split(',')[0].replace(/['"]/g, '').trim(),
                font_weight: 400,
                font_style: 'normal'
            },
            geometry: {
                x: 0,
                y: 0,
                width: document.documentElement.scrollWidth,
                height: document.documentElement.scrollHeight
            },
            padding: { top: 0, right: 0, bottom: 0, left: 0 },
            margin: { top: 0, right: 0, bottom: 0, left: 0 },
            depth: 0,
            children: []
        };

        const bodyBg = getBackgroundColor(document.body);
        if (bodyBg) {
            layoutView.background_color = bodyBg;
        }

        nodes.push(layoutView);

        const rootId = processNode(root, 1);
        layoutView.children = [rootId];

        nodes.sort((a, b) => a.id - b.id);

        return { layout_tree: nodes };
    }

    // ============================================
    // WEBSOCKET CLIENT
    // ============================================

    window.addEventListener('load', function() {
        setTimeout(function() {
            const ws = new WebSocket('ws://localhost:8765');

            ws.onopen = function() {
                console.log('[WS] Connected to server');
                const tree = extractLayoutTree();
                ws.send(JSON.stringify({
                    type: 'layout_tree',
                    data: tree
                }));
                console.log('[WS] Sent layout tree with', tree.layout_tree.length, 'nodes');
            };

            ws.onmessage = function(event) {
                console.log('[WS] Received:', JSON.parse(event.data));
            };

            ws.onerror = function(err) {
                console.log('[WS] Error:', err);
            };
        }, 1000);
    });
</script>

<body>
    <!-- Main card container -->
    <div class="card">
        <h2>Complex UI Demo</h2>
        <p id="dynamic-text">This text can be changed dynamically.</p>

        <!-- Transformed box -->
        <div class="transformed-box">
            <strong>Transformed Element</strong><br>
            Rotated and scaled with CSS transforms
        </div>

        <!-- Opacity demo -->
        <p><strong>Opacity Variations:</strong></p>
        <div class="opacity-demo">
            <div class="opacity-box" style="opacity: 1">100%</div>
            <div class="opacity-box" style="opacity: 0.75">75%</div>
            <div class="opacity-box" style="opacity: 0.5">50%</div>
            <div class="opacity-box" style="opacity: 0.25">25%</div>
        </div>

        <!-- Semi-transparent overlay -->
        <div class="overlay-container">
            <span>Content with overlay</span>
            <div class="overlay"></div>
        </div>

        <!-- Clipped element -->
        <div class="clipped">
            Clipped with clip-path polygon
        </div>

        <!-- Nested transforms -->
        <div class="outer-transform">
            <div class="inner-transform">
                Nested CSS Transforms (perspective + skew)
            </div>
        </div>

        <!-- Nested rounded borders -->
        <div class="nested-rounded">
            <div class="inner">
                Nested rounded corners
                <div class="innermost">
                    Deeply nested element
                </div>
            </div>
        </div>

        <!-- Progress bar -->
        <p><strong>Progress:</strong></p>
        <div class="progress-bar">
            <div class="fill"></div>
        </div>

        <!-- Tags -->
        <div class="tags">
            <span class="tag active">Active</span>
            <span class="tag">Design</span>
            <span class="tag">CSS</span>
            <span class="tag">Transforms</span>
        </div>
    </div>

    <!-- Form card -->
    <div class="card">
        <h3>Form Elements</h3>

        <div class="form-group">
            <label>Text Input</label>
            <input type="text" placeholder="Enter your name">
        </div>

        <div class="form-group">
            <label>Email Input</label>
            <input type="email" placeholder="you@example.com">
        </div>

        <div class="form-group">
            <label>Password Input</label>
            <input type="password" placeholder="Password">
        </div>

        <div class="form-group">
            <label>Dropdown Select</label>
            <select>
                <option>Option 1</option>
                <option>Option 2</option>
                <option>Option 3</option>
            </select>
        </div>

        <div class="form-group">
            <label>Range Slider</label>
            <input type="range" min="0" max="100" value="50">
        </div>

        <div class="form-group">
            <label>Textarea</label>
            <textarea placeholder="Write something..."></textarea>
        </div>

        <div class="form-group">
            <label>Checkboxes</label>
            <div class="checkbox-group">
                <label><input type="checkbox" checked> Option A</label>
                <label><input type="checkbox"> Option B</label>
                <label><input type="checkbox"> Option C</label>
            </div>
        </div>

        <div class="form-group">
            <label>Radio Buttons</label>
            <div class="checkbox-group">
                <label><input type="radio" name="radio-demo" checked> Choice 1</label>
                <label><input type="radio" name="radio-demo"> Choice 2</label>
                <label><input type="radio" name="radio-demo"> Choice 3</label>
            </div>
        </div>
    </div>

    <!-- Buttons card -->
    <div class="card">
        <h3>Buttons</h3>
        <div class="button-row">
            <button class="btn btn-primary" onclick="changeText()">Primary</button>
            <button class="btn btn-success">Success</button>
            <button class="btn btn-warning">Warning</button>
            <button class="btn btn-danger">Danger</button>
            <button class="btn btn-outline" onclick="toggleVisibility()">Toggle</button>
        </div>

        <div class="toggle-target" style="margin-top: 15px; padding: 15px; background: #f8f8f8; border-radius: 8px;">
            <p>This element's opacity can be toggled.</p>
        </div>
    </div>

    <!-- Data table card -->
    <div class="card">
        <h3>Data Table</h3>
        <table class="data-table">
            <thead>
                <tr>
                    <th>Name</th>
                    <th>Email</th>
                    <th>Status</th>
                    <th>Role</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>John Smith</td>
                    <td>john@example.com</td>
                    <td><span class="status-badge status-active">Active</span></td>
                    <td>Admin</td>
                </tr>
                <tr>
                    <td>Sarah Johnson</td>
                    <td>sarah@example.com</td>
                    <td><span class="status-badge status-active">Active</span></td>
                    <td>Editor</td>
                </tr>
                <tr>
                    <td>Mike Wilson</td>
                    <td>mike@example.com</td>
                    <td><span class="status-badge status-pending">Pending</span></td>
                    <td>Viewer</td>
                </tr>
                <tr>
                    <td>Emily Brown</td>
                    <td>emily@example.com</td>
                    <td><span class="status-badge status-inactive">Inactive</span></td>
                    <td>Viewer</td>
                </tr>
            </tbody>
        </table>
    </div>

    <!-- User cards and avatars -->
    <div class="card">
        <h3>Team Members</h3>
        <div class="user-card">
            <div class="avatar">JD</div>
            <div class="user-info">
                <div class="name">Jane Doe</div>
                <div class="role">Senior Developer</div>
            </div>
        </div>
        <div class="user-card">
            <div class="avatar" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);">AB</div>
            <div class="user-info">
                <div class="name">Alex Brown</div>
                <div class="role">Product Manager</div>
            </div>
        </div>
        <div class="user-card">
            <div class="avatar" style="background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);">CW</div>
            <div class="user-info">
                <div class="name">Chris Wilson</div>
                <div class="role">UX Designer</div>
            </div>
        </div>
    </div>

    <!-- Tabs -->
    <div class="card">
        <h3>Tabbed Content</h3>
        <div class="tabs">
            <div class="tab active">Overview</div>
            <div class="tab">Analytics</div>
            <div class="tab">Reports</div>
            <div class="tab">Settings</div>
        </div>
        <div class="tab-content">
            This is the content of the Overview tab. You can switch between different tabs to view different content sections.
        </div>
    </div>

    <!-- Search and dropdown -->
    <div class="card">
        <h3>Search & Navigation</h3>
        <div class="search-box">
            <input type="text" placeholder="Search for anything...">
            <button>Search</button>
        </div>

        <div style="margin-top: 15px;">
            <div class="dropdown">
                <button class="dropdown-trigger">Select Option</button>
                <div class="dropdown-menu">
                    <a href="#">Edit Profile</a>
                    <a href="#">Account Settings</a>
                    <a href="#">Notifications</a>
                    <a href="#">Sign Out</a>
                </div>
            </div>
        </div>
    </div>

    <!-- List group -->
    <div class="card">
        <h3>Notifications</h3>
        <div class="list-group">
            <div class="list-group-item">
                <span>New message from support</span>
                <span class="badge">New</span>
            </div>
            <div class="list-group-item">
                <span>Your order has been shipped</span>
                <span class="badge">2</span>
            </div>
            <div class="list-group-item">
                <span>Password changed successfully</span>
            </div>
            <div class="list-group-item">
                <span>Weekly report is ready</span>
            </div>
        </div>
    </div>

    <!-- Timeline -->
    <div class="card">
        <h3>Activity Timeline</h3>
        <div class="timeline">
            <div class="timeline-item">
                <div class="time">2 hours ago</div>
                <div class="content">New user registration: john.doe@email.com</div>
            </div>
            <div class="timeline-item">
                <div class="time">5 hours ago</div>
                <div class="content">Payment received: $299.00 for Pro Plan</div>
            </div>
            <div class="timeline-item">
                <div class="time">Yesterday</div>
                <div class="content">System update completed successfully</div>
            </div>
            <div class="timeline-item">
                <div class="time">2 days ago</div>
                <div class="content">New feature deployed: Dark mode support</div>
            </div>
        </div>
    </div>

    <!-- Pricing card -->
    <div class="card">
        <h3>Pricing</h3>
        <div class="pricing-card featured">
            <div class="plan-name">Professional</div>
            <div class="price">$29<span>/month</span></div>
            <div class="features">
                <div>Unlimited projects</div>
                <div>Priority support</div>
                <div>Advanced analytics</div>
                <div>Custom integrations</div>
            </div>
            <button class="btn btn-primary" style="width: 100%;">Choose Plan</button>
        </div>
    </div>

    <!-- Modal preview -->
    <div class="card">
        <h3>Modal Dialog</h3>
        <div class="modal-preview">
            <div class="modal-box">
                <h4>Confirm Action</h4>
                <p>Are you sure you want to proceed with this action? This cannot be undone.</p>
                <div class="button-row">
                    <button class="btn btn-outline" style="flex: 1;">Cancel</button>
                    <button class="btn btn-danger" style="flex: 1;">Confirm</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Skeleton loading -->
    <div class="card">
        <h3>Loading Skeleton</h3>
        <div style="display: flex; gap: 12px; align-items: center;">
            <div class="skeleton skeleton-avatar"></div>
            <div style="flex: 1;">
                <div class="skeleton skeleton-title"></div>
                <div class="skeleton skeleton-text"></div>
            </div>
        </div>
    </div>

    <!-- Tooltip demo -->
    <div class="card">
        <h3>Tooltip</h3>
        <div class="tooltip-demo">Hover for tooltip</div>
    </div>

    <!-- ============================================
         OVERFLOW PROPERTY DEMO
         ============================================ -->
    <div class="card">
        <h3>Overflow Property</h3>
        <div class="overflow-demo">
            <div class="overflow-box overflow-visible">
                <div style="background: #e74c3c; color: white; padding: 5px;">Visible: This content overflows the container boundaries</div>
            </div>
            <div class="overflow-box overflow-hidden">
                <div style="background: #3498db; color: white; padding: 5px;">Hidden: This content is clipped at boundaries</div>
            </div>
            <div class="overflow-box overflow-scroll">
                <div style="background: #2ecc71; color: white; padding: 5px;">Scroll: This content has scrollbars always</div>
            </div>
            <div class="overflow-box overflow-auto">
                <div style="background: #9b59b6; color: white; padding: 5px;">Auto: Scrollbars appear when needed</div>
            </div>
        </div>
    </div>

    <!-- ============================================
         MIX-BLEND-MODE DEMO
         ============================================ -->
    <div class="card">
        <h3>Mix Blend Mode</h3>
        <div class="blend-container">
            <div class="blend-box blend-multiply">multiply</div>
            <div class="blend-box blend-screen">screen</div>
            <div class="blend-box blend-overlay">overlay</div>
        </div>
    </div>

    <!-- ============================================
         BLUR / FILTER EFFECTS
         ============================================ -->
    <div class="card">
        <h3>Blur Effects</h3>
        <p style="font-size: 12px; color: #666;">Filter blur:</p>
        <div class="blur-demo">
            <div class="blur-box blur-none">0px</div>
            <div class="blur-box blur-sm">2px</div>
            <div class="blur-box blur-md">4px</div>
            <div class="blur-box blur-lg">8px</div>
        </div>
        <p style="font-size: 12px; color: #666; margin-top: 15px;">Backdrop blur:</p>
        <div class="backdrop-blur-container">
            <div class="backdrop-blur-box">
                Content with backdrop-filter blur effect
            </div>
        </div>
    </div>

    <!-- ============================================
         TRANSFORM DEMOS
         ============================================ -->
    <div class="card">
        <h3>CSS Transforms</h3>
        <p style="font-size: 12px; color: #666;">Basic transforms:</p>
        <div class="transform-grid">
            <div class="transform-item transform-rotate">rotate(15deg)</div>
            <div class="transform-item transform-scale">scale(1.15)</div>
            <div class="transform-item transform-skew">skewX(-10deg)</div>
            <div class="transform-item transform-translate">translate</div>
        </div>
        <p style="font-size: 12px; color: #666; margin-top: 15px;">3D transforms:</p>
        <div class="transform-grid">
            <div class="transform-item transform-rotate-y">rotateY(25deg)</div>
            <div class="transform-item transform-rotate-x">rotateX(15deg)</div>
            <div class="transform-item transform-multiple">combined</div>
            <div class="transform-item" style="transform: rotate3d(1, 1, 0, 20deg);">rotate3d</div>
        </div>
    </div>

    <!-- Transform Origin -->
    <div class="card">
        <h3>Transform Origin</h3>
        <div class="origin-demo">
            <div class="origin-box origin-center">center</div>
            <div class="origin-box origin-top-left">top left</div>
            <div class="origin-box origin-bottom-right">bottom right</div>
        </div>
    </div>

    <!-- Perspective -->
    <div class="card">
        <h3>Perspective</h3>
        <div class="perspective-container">
            <div class="perspective-box">rotateY with perspective</div>
        </div>
    </div>

    <!-- 3D Cube with preserve-3d -->
    <div class="card">
        <h3>3D Transform (preserve-3d)</h3>
        <div class="preserve-3d-demo">
            <div class="cube-wrapper">
                <div class="cube-face cube-front">F</div>
                <div class="cube-face cube-back">B</div>
                <div class="cube-face cube-left">L</div>
                <div class="cube-face cube-right">R</div>
                <div class="cube-face cube-top">T</div>
                <div class="cube-face cube-bottom">Bo</div>
            </div>
        </div>
    </div>

    <!-- Backface Visibility -->
    <div class="card">
        <h3>Backface Visibility</h3>
        <div class="backface-demo">
            <div class="backface-card backface-visible">visible</div>
            <div class="backface-card backface-hidden">hidden</div>
        </div>
    </div>

    <!-- ============================================
         BACKGROUND PROPERTIES
         ============================================ -->
    <div class="card">
        <h3>Background Clip</h3>
        <div class="bg-clip-demo">
            <div class="bg-clip-box bg-clip-border">border-box</div>
            <div class="bg-clip-box bg-clip-padding">padding-box</div>
            <div class="bg-clip-box bg-clip-content">content-box</div>
        </div>
        <div class="bg-clip-text-demo">Gradient Text Clip</div>
    </div>

    <!-- ============================================
         BORDER STYLES
         ============================================ -->
    <div class="card">
        <h3>Border Styles</h3>
        <div class="border-demo">
            <div class="border-box border-solid">solid</div>
            <div class="border-box border-dashed">dashed</div>
            <div class="border-box border-dotted">dotted</div>
            <div class="border-box border-double">double</div>
            <div class="border-box border-groove">groove</div>
            <div class="border-box border-ridge">ridge</div>
            <div class="border-box border-inset">inset</div>
            <div class="border-box border-outset">outset</div>
            <div class="border-box border-mixed">mixed</div>
        </div>
    </div>

    <!-- Border Radius Variations -->
    <div class="card">
        <h3>Border Radius</h3>
        <div class="radius-demo">
            <div class="radius-box radius-none">0</div>
            <div class="radius-box radius-sm">4px</div>
            <div class="radius-box radius-md">12px</div>
            <div class="radius-box radius-lg">20px</div>
            <div class="radius-box radius-full">50%</div>
            <div class="radius-box radius-pill">pill</div>
            <div class="radius-box radius-asymmetric">asym</div>
            <div class="radius-box radius-elliptical">ellipse</div>
        </div>
    </div>

    <!-- Outline -->
    <div class="card">
        <h3>Outline</h3>
        <div class="outline-demo">
            <div class="outline-box outline-solid">solid</div>
            <div class="outline-box outline-dashed">dashed</div>
            <div class="outline-box outline-offset">offset 4px</div>
        </div>
    </div>

    <!-- ============================================
         TEXT PROPERTIES
         ============================================ -->
    <div class="card">
        <h3>Text Fill & Stroke</h3>
        <div class="text-fill-demo">Gradient Fill Text</div>
        <div class="text-stroke-demo">Stroked Text</div>
        <div class="text-stroke-only">Stroke Only</div>
    </div>

    <div class="card">
        <h3>Font Weights</h3>
        <div class="font-light">Light (300)</div>
        <div class="font-normal">Normal (400)</div>
        <div class="font-medium">Medium (500)</div>
        <div class="font-semibold">Semibold (600)</div>
        <div class="font-bold">Bold (700)</div>
    </div>

    <div class="card">
        <h3>Letter Spacing</h3>
        <div class="letter-tight">Tight spacing (-1px)</div>
        <div class="letter-normal">Normal spacing</div>
        <div class="letter-wide">Wide spacing (2px)</div>
        <div class="letter-wider">Wider spacing (4px)</div>
    </div>

    <div class="card">
        <h3>Text Transform</h3>
        <div class="text-upper">uppercase text</div>
        <div class="text-lower">LOWERCASE TEXT</div>
        <div class="text-capitalize">capitalize each word</div>
    </div>

    <div class="card">
        <h3>Text Decoration</h3>
        <div class="text-underline">Underlined text</div>
        <div class="text-overline">Overlined text</div>
        <div class="text-line-through">Strikethrough text</div>
        <div class="text-decoration-wavy">Wavy underline</div>
        <div class="text-decoration-double">Double underline</div>
        <div class="text-decoration-dotted">Dotted underline</div>
    </div>

    <div class="card">
        <h3>Text Shadow</h3>
        <div style="font-size: 18px;">
            <div class="text-shadow-sm">Small shadow</div>
            <div class="text-shadow-md">Medium shadow</div>
            <div class="text-shadow-lg">Large shadow</div>
            <div class="text-shadow-glow" style="color: #2c3e50;">Glow effect</div>
            <div class="text-shadow-multi">Multi-layer shadow</div>
        </div>
    </div>

    <div class="card">
        <h3>Writing Mode & Direction</h3>
        <div style="display: flex; gap: 20px; align-items: flex-start;">
            <div class="writing-vertical" style="background: #f0f0f0; padding: 10px; border-radius: 4px;">Vertical RL</div>
            <div class="writing-vertical-lr" style="background: #f0f0f0; padding: 10px; border-radius: 4px;">Vertical LR</div>
            <div class="text-rtl" dir="rtl" style="background: #f0f0f0; padding: 10px; border-radius: 4px; width: 150px;">RTL Direction Text</div>
        </div>
    </div>

    <!-- ============================================
         BOX SHADOW VARIATIONS
         ============================================ -->
    <div class="card">
        <h3>Box Shadow - Basic</h3>
        <div class="shadow-demo">
            <div class="shadow-box shadow-sm">small</div>
            <div class="shadow-box shadow-md">medium</div>
            <div class="shadow-box shadow-lg">large</div>
            <div class="shadow-box shadow-xl">x-large</div>
            <div class="shadow-box shadow-colored">colored</div>
            <div class="shadow-box shadow-multi">multi</div>
        </div>
    </div>

    <div class="card">
        <h3>Box Shadow - Inset</h3>
        <div class="shadow-demo">
            <div class="shadow-box shadow-inset">inset</div>
            <div class="shadow-box shadow-inset-deep">deep inset</div>
            <div class="shadow-box shadow-inset-all">all sides</div>
        </div>
    </div>

    <div class="card">
        <h3>Box Shadow - Spread Radius</h3>
        <div class="shadow-demo">
            <div class="shadow-box shadow-spread-pos">positive</div>
            <div class="shadow-box shadow-spread-neg">negative</div>
            <div class="shadow-box shadow-spread-only">spread only</div>
        </div>
    </div>

    <div class="card">
        <h3>Box Shadow - Combined</h3>
        <div class="shadow-demo">
            <div class="shadow-box shadow-combined">combined</div>
            <div class="shadow-box shadow-neumorphic">neumorphic</div>
        </div>
    </div>

    <!-- ============================================
         OPACITY VARIATIONS (extended)
         ============================================ -->
    <div class="card">
        <h3>Opacity Variations</h3>
        <div class="opacity-grid">
            <div class="opacity-item" style="opacity: 1">100%</div>
            <div class="opacity-item" style="opacity: 0.9">90%</div>
            <div class="opacity-item" style="opacity: 0.75">75%</div>
            <div class="opacity-item" style="opacity: 0.5">50%</div>
            <div class="opacity-item" style="opacity: 0.25">25%</div>
            <div class="opacity-item" style="opacity: 0.1">10%</div>
        </div>
    </div>

    <!-- Footer -->
    <footer class="footer">
        <div class="footer-grid">
            <div>
                <h5>Product</h5>
                <a href="#">Features</a>
                <a href="#">Pricing</a>
                <a href="#">Documentation</a>
            </div>
            <div>
                <h5>Company</h5>
                <a href="#">About Us</a>
                <a href="#">Careers</a>
                <a href="#">Contact</a>
            </div>
            <div>
                <h5>Legal</h5>
                <a href="#">Privacy Policy</a>
                <a href="#">Terms of Service</a>
                <a href="#">Cookie Policy</a>
            </div>
        </div>
        <div class="footer-bottom">
            2024 WebApp Inc. All rights reserved.
        </div>
    </footer>
</body>
