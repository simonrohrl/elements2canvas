<!DOCTYPE html>
<html>
<head>
    <title>Background Clip Test</title>
    <style>
        @font-face {
            font-family: Arial;
            src: url("./Arial.ttf");
        }

        body {
            font-family: Arial, sans-serif;
            margin: 40px;
            background: #f5f5f5;
        }

        h2 {
            margin-top: 30px;
        }

        /* Background clip demo boxes */
        .bg-clip-demo {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
            margin: 20px 0;
        }

        .bg-clip-box {
            width: 120px;
            height: 80px;
            padding: 15px;
            background: linear-gradient(135deg, #667eea, #764ba2);
            border: 8px dashed rgba(0,0,0,0.3);
            color: white;
            font-size: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
        }

        .bg-clip-border { background-clip: border-box; }
        .bg-clip-padding { background-clip: padding-box; }
        .bg-clip-content { background-clip: content-box; }

        /* Gradient text clip */
        .bg-clip-text-demo {
            background: linear-gradient(90deg, #667eea, #764ba2, #f093fb);
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
            font-size: 48px;
            font-weight: bold;
            margin: 30px 0;
        }

        .info-box {
            background: white;
            padding: 20px;
            border-radius: 8px;
            margin: 20px 0;
            font-size: 14px;
            border: 1px solid #ddd;
        }

        code {
            background: #eee;
            padding: 2px 6px;
            border-radius: 3px;
        }
    </style>
</head>
<body>
    <h1>Background Clip Test</h1>

    <div class="info-box">
        <strong>Purpose:</strong> Test background-clip CSS property rendering in CanvasKit.<br><br>
        <strong>Expected behavior:</strong>
        <ul>
            <li><code>border-box</code>: Gradient visible through dashed border gaps</li>
            <li><code>padding-box</code>: No gradient behind border (stops at padding edge)</li>
            <li><code>content-box</code>: Gradient only in content area (not in padding)</li>
            <li><code>text</code>: Gradient fills the text shape</li>
        </ul>
    </div>

    <h2>background-clip: border-box / padding-box / content-box</h2>
    <div class="bg-clip-demo">
        <div class="bg-clip-box bg-clip-border">border-box</div>
        <div class="bg-clip-box bg-clip-padding">padding-box</div>
        <div class="bg-clip-box bg-clip-content">content-box</div>
    </div>

    <h2>background-clip: text</h2>
    <div class="bg-clip-text-demo">Gradient Text Clip</div>

    <h2>CanvasKit DstIn Test (Simple)</h2>
    <p>This canvas tests if saveLayer with DstIn blend mode works in CanvasKit:</p>
    <canvas id="canvaskit-test" width="400" height="100"></canvas>
    <p id="test-result"></p>

    <h2>CanvasKit DstIn Test (With Save/Clip/Translate like test.html)</h2>
    <p>This canvas mimics how test.html draws the gradient (with save/clipRect/translate):</p>
    <canvas id="canvaskit-test2" width="400" height="100"></canvas>
    <p id="test-result2"></p>

    <script src="https://unpkg.com/canvaskit-wasm@0.39.1/bin/canvaskit.js"></script>
    <script>
        // Test CanvasKit saveLayer with DstIn blend mode
        CanvasKitInit({
            locateFile: (file) => 'https://unpkg.com/canvaskit-wasm@0.39.1/bin/' + file
        }).then((CanvasKit) => {
            const canvas = document.getElementById('canvaskit-test');
            const surface = CanvasKit.MakeCanvasSurface(canvas);
            if (!surface) {
                document.getElementById('test-result').textContent = 'Failed to create surface';
                return;
            }

            const skCanvas = surface.getCanvas();
            skCanvas.clear(CanvasKit.WHITE);

            // Match exact Chromium structure:
            // 1. SaveLayer (SrcOver) - isolation layer
            const srcOverPaint = new CanvasKit.Paint();
            srcOverPaint.setBlendMode(CanvasKit.BlendMode.SrcOver);
            skCanvas.saveLayer(srcOverPaint);
            console.log('[TEST] 1. SaveLayer (SrcOver) - isolation layer');

            // 2. Draw gradient rect (destination) - inside SrcOver layer
            const gradientPaint = new CanvasKit.Paint();
            const shader = CanvasKit.Shader.MakeLinearGradient(
                [0, 0], [400, 0],
                [CanvasKit.Color(102, 126, 234, 1), CanvasKit.Color(118, 75, 162, 1), CanvasKit.Color(240, 147, 251, 1)],
                [0, 0.5, 1],
                CanvasKit.TileMode.Clamp
            );
            gradientPaint.setShader(shader);
            skCanvas.drawRect(CanvasKit.LTRBRect(0, 0, 400, 100), gradientPaint);
            console.log('[TEST] 2. Drew gradient rect inside SrcOver layer');

            // 3. SaveLayer with DstIn - nested inside SrcOver layer
            const dstInPaint = new CanvasKit.Paint();
            dstInPaint.setBlendMode(CanvasKit.BlendMode.DstIn);
            skCanvas.saveLayer(dstInPaint);
            console.log('[TEST] 3. SaveLayer (DstIn) - nested inside SrcOver');

            // 4. Draw rectangles as mask
            const maskPaint = new CanvasKit.Paint();
            maskPaint.setColor(CanvasKit.BLACK);
            maskPaint.setAntiAlias(true);
            skCanvas.drawRect(CanvasKit.LTRBRect(20, 30, 60, 70), maskPaint);
            skCanvas.drawRect(CanvasKit.LTRBRect(70, 30, 110, 70), maskPaint);
            skCanvas.drawRect(CanvasKit.LTRBRect(120, 30, 160, 70), maskPaint);
            skCanvas.drawRect(CanvasKit.LTRBRect(170, 30, 210, 70), maskPaint);
            skCanvas.drawRect(CanvasKit.LTRBRect(220, 30, 260, 70), maskPaint);
            skCanvas.drawRect(CanvasKit.LTRBRect(270, 30, 310, 70), maskPaint);
            skCanvas.drawRect(CanvasKit.LTRBRect(320, 30, 380, 70), maskPaint);
            console.log('[TEST] 4. Drew rectangles as mask inside DstIn layer');

            // 5. Restore DstIn layer
            skCanvas.restore();
            console.log('[TEST] 5. Restore (closes DstIn - applies masking)');

            // 6. Restore SrcOver layer
            skCanvas.restore();
            console.log('[TEST] 6. Restore (closes SrcOver - composites to canvas)');

            srcOverPaint.delete();

            surface.flush();
            gradientPaint.delete();
            dstInPaint.delete();
            maskPaint.delete();

            document.getElementById('test-result').textContent =
                'This matches Chromium structure: SrcOver layer containing gradient + nested DstIn layer with mask.';

            // ========== Second test: mimic test.html's save/clipRect/translate pattern ==========
            const canvas2 = document.getElementById('canvaskit-test2');
            const surface2 = CanvasKit.MakeCanvasSurface(canvas2);
            if (!surface2) {
                document.getElementById('test-result2').textContent = 'Failed to create surface';
                return;
            }

            const skCanvas2 = surface2.getCanvas();
            skCanvas2.clear(CanvasKit.WHITE);

            // 1. SaveLayer (SrcOver) - isolation layer
            const srcOverPaint2 = new CanvasKit.Paint();
            srcOverPaint2.setBlendMode(CanvasKit.BlendMode.SrcOver);
            skCanvas2.saveLayer(srcOverPaint2);
            console.log('[TEST2] 1. SaveLayer (SrcOver)');

            // 2. Draw gradient using save/clipRect/translate pattern (like drawTiledPattern in test.html)
            const destRect = CanvasKit.LTRBRect(0, 0, 400, 100);
            const destLeft = 0, destTop = 0;

            skCanvas2.save();
            skCanvas2.clipRect(destRect, CanvasKit.ClipOp.Intersect, true);
            skCanvas2.translate(destLeft, destTop);

            // Draw the gradient at local coords (0,0) like tiled pattern does
            const gradientPaint2 = new CanvasKit.Paint();
            const shader2 = CanvasKit.Shader.MakeLinearGradient(
                [0, 0], [400, 0],
                [CanvasKit.Color(102, 126, 234, 1), CanvasKit.Color(118, 75, 162, 1), CanvasKit.Color(240, 147, 251, 1)],
                [0, 0.5, 1],
                CanvasKit.TileMode.Clamp
            );
            gradientPaint2.setShader(shader2);
            skCanvas2.drawRect(CanvasKit.LTRBRect(0, 0, 400, 100), gradientPaint2);

            skCanvas2.restore();  // Restore from the save/clip/translate
            console.log('[TEST2] 2. Drew gradient with save/clipRect/translate/restore pattern');

            // 3. SaveLayer with DstIn
            const dstInPaint2 = new CanvasKit.Paint();
            dstInPaint2.setBlendMode(CanvasKit.BlendMode.DstIn);
            skCanvas2.saveLayer(dstInPaint2);
            console.log('[TEST2] 3. SaveLayer (DstIn)');

            // 4. Draw rectangles as mask
            const maskPaint2 = new CanvasKit.Paint();
            maskPaint2.setColor(CanvasKit.BLACK);
            maskPaint2.setAntiAlias(true);
            skCanvas2.drawRect(CanvasKit.LTRBRect(20, 30, 60, 70), maskPaint2);
            skCanvas2.drawRect(CanvasKit.LTRBRect(70, 30, 110, 70), maskPaint2);
            skCanvas2.drawRect(CanvasKit.LTRBRect(120, 30, 160, 70), maskPaint2);
            skCanvas2.drawRect(CanvasKit.LTRBRect(170, 30, 210, 70), maskPaint2);
            skCanvas2.drawRect(CanvasKit.LTRBRect(220, 30, 260, 70), maskPaint2);
            skCanvas2.drawRect(CanvasKit.LTRBRect(270, 30, 310, 70), maskPaint2);
            skCanvas2.drawRect(CanvasKit.LTRBRect(320, 30, 380, 70), maskPaint2);
            console.log('[TEST2] 4. Drew rectangles as mask');

            // 5. Restore DstIn layer
            skCanvas2.restore();
            console.log('[TEST2] 5. Restore (DstIn)');

            // 6. Restore SrcOver layer
            skCanvas2.restore();
            console.log('[TEST2] 6. Restore (SrcOver)');

            surface2.flush();
            srcOverPaint2.delete();
            gradientPaint2.delete();
            dstInPaint2.delete();
            maskPaint2.delete();

            document.getElementById('test-result2').textContent =
                'This uses save/clipRect/translate pattern like test.html drawTiledPattern. Should show same result as above.';
        });
    </script>

    <script>
        // Log expected Skia commands for background-clip: text
        console.log('=== Background Clip: Text - Expected Skia Sequence ===');
        console.log('');
        console.log('For CSS background-clip: text, the expected compositing sequence is:');
        console.log('1. SaveLayer (SrcOver) - creates isolation layer');
        console.log('2. DrawRect with gradient shader - draws the background');
        console.log('3. SaveLayer (DstIn) - destination-in blend mode');
        console.log('4. DrawTextBlob - draws the text as mask');
        console.log('5. Restore - applies DstIn: keeps gradient only where text is');
        console.log('6. Restore - composites result back to canvas');
        console.log('');
        console.log('CSS properties on .bg-clip-text-demo:');
        console.log('  background: linear-gradient(90deg, #667eea, #764ba2, #f093fb)');
        console.log('  background-clip: text');
        console.log('  -webkit-text-fill-color: transparent');
        console.log('');
        console.log('DstIn blend mode: keeps Destination pixels where Source is opaque');
        console.log('  - Destination = gradient rect (drawn before DstIn layer)');
        console.log('  - Source = text (drawn inside DstIn layer)');
        console.log('  - Result = gradient visible only where text shape is');
    </script>
</body>
</html>
