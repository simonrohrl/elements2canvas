<!DOCTYPE html>
<html>
<head>
  <title>Font Rendering Test - DOM vs Canvas</title>
  <script src="https://unpkg.com/canvaskit-wasm@0.39.1/bin/canvaskit.js"></script>
  <script src="https://unpkg.com/opentype.js@1.3.4/dist/opentype.min.js"></script>
  <style>
    * { box-sizing: border-box; }
    body {
      font-family: Arial, sans-serif;
      margin: 0;
      padding: 20px;
      background: #f5f5f5;
    }
    h1 { margin: 0 0 20px 0; color: #333; }
    .container { display: flex; gap: 20px; flex-wrap: wrap; }
    .panel {
      background: white;
      border-radius: 8px;
      padding: 20px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    }
    .panel h2 { margin: 0 0 15px 0; font-size: 16px; color: #666; }

    /* Test cases container */
    #test-cases {
      flex: 1;
      min-width: 400px;
    }
    .test-item {
      margin-bottom: 15px;
      padding: 10px;
      border: 1px solid #e0e0e0;
      border-radius: 4px;
      background: white;
      cursor: pointer;
    }
    .test-item:hover { background: #f9f9f9; }
    .test-item.selected { border-color: #2196F3; background: #e3f2fd; }
    .test-label { font-size: 12px; color: #999; margin-bottom: 5px; }
    .test-text { font-family: Arial, sans-serif; }

    /* Comparison view */
    #comparison {
      flex: 1;
      min-width: 500px;
    }
    .comparison-row {
      display: flex;
      gap: 20px;
      margin-bottom: 20px;
    }
    .comparison-box {
      flex: 1;
      border: 1px solid #ddd;
      border-radius: 4px;
      padding: 10px;
      min-height: 80px;
      background: white;
    }
    .comparison-box h3 { margin: 0 0 10px 0; font-size: 14px; color: #666; }
    .comparison-box canvas { display: block; }

    /* Debug panel */
    #debug-panel {
      width: 100%;
      margin-top: 20px;
    }
    #debug-panel pre {
      background: #1e1e1e;
      color: #d4d4d4;
      padding: 15px;
      border-radius: 4px;
      overflow: auto;
      max-height: 400px;
      font-size: 12px;
      font-family: 'Monaco', 'Menlo', monospace;
    }
    .tabs {
      display: flex;
      gap: 5px;
      margin-bottom: 10px;
    }
    .tab {
      padding: 8px 16px;
      border: none;
      background: #e0e0e0;
      border-radius: 4px 4px 0 0;
      cursor: pointer;
    }
    .tab.active { background: #1e1e1e; color: white; }

    /* Status */
    #status {
      padding: 10px;
      background: #e8f5e9;
      border-radius: 4px;
      margin-bottom: 20px;
      color: #2e7d32;
    }
    #status.error { background: #ffebee; color: #c62828; }
    #status.loading { background: #fff3e0; color: #ef6c00; }
  </style>
</head>
<body>
  <h1>Font Rendering Test - DOM vs Canvas</h1>
  <div id="status" class="loading">Initializing...</div>

  <div class="container">
    <!-- Test Cases -->
    <div id="test-cases" class="panel">
      <h2>Test Cases (click to select)</h2>
      <div id="tests-list"></div>
    </div>

    <!-- Side-by-side Comparison -->
    <div id="comparison" class="panel">
      <h2>Comparison</h2>
      <div class="comparison-row">
        <div class="comparison-box">
          <h3>DOM Rendering (Reference)</h3>
          <div id="dom-render"></div>
        </div>
        <div class="comparison-box">
          <h3>Canvas Rendering (CanvasKit)</h3>
          <canvas id="canvas-render" width="400" height="100"></canvas>
        </div>
      </div>
    </div>
  </div>

  <!-- Debug Panel -->
  <div id="debug-panel" class="panel">
    <h2>Debug Info</h2>
    <div class="tabs">
      <button class="tab active" data-tab="glyph-data">Glyph Data</button>
      <button class="tab" data-tab="input-json">Input JSON</button>
      <button class="tab" data-tab="paint-ops">Paint Ops</button>
    </div>
    <pre id="debug-output">Select a test case to see debug info</pre>
  </div>

<script type="module">
// ============================================
// Test Cases Definition
// ============================================

const TEST_CASES = [
  {
    id: 'basic',
    label: 'Basic Text (16px)',
    css: { fontSize: '16px', fontWeight: '400' },
    text: 'Hello World'
  },
  {
    id: 'large',
    label: 'Large Text (32px)',
    css: { fontSize: '32px', fontWeight: '400' },
    text: 'Big Text'
  },
  {
    id: 'bold',
    label: 'Bold Text',
    css: { fontSize: '16px', fontWeight: '700' },
    text: 'Bold Text'
  },
  {
    id: 'colored',
    label: 'Colored Text',
    css: { fontSize: '16px', color: '#ff0000' },
    text: 'Red Text'
  },
  {
    id: 'underline',
    label: 'Underlined Text',
    css: { fontSize: '16px', textDecoration: 'underline' },
    text: 'Underlined'
  },
  {
    id: 'strikethrough',
    label: 'Strikethrough Text',
    css: { fontSize: '16px', textDecoration: 'line-through' },
    text: 'Strikethrough'
  },
  {
    id: 'overline',
    label: 'Overlined Text',
    css: { fontSize: '16px', textDecoration: 'overline' },
    text: 'Overlined'
  },
  {
    id: 'wavy-underline',
    label: 'Wavy Underline',
    css: { fontSize: '16px', textDecoration: 'underline', textDecorationStyle: 'wavy', textDecorationColor: 'red' },
    text: 'Wavy Line'
  },
  {
    id: 'letter-spacing',
    label: 'Letter Spacing (2px)',
    css: { fontSize: '16px', letterSpacing: '2px' },
    text: 'Spaced Out'
  },
  {
    id: 'shadow',
    label: 'Text Shadow',
    css: { fontSize: '20px', textShadow: '2px 2px 4px rgba(0,0,0,0.5)' },
    text: 'Shadow'
  },
  {
    id: 'multi-decoration',
    label: 'Multiple Decorations',
    css: { fontSize: '16px', textDecoration: 'underline overline' },
    text: 'Multi Deco'
  }
];

// ============================================
// Global State
// ============================================

let CanvasKit = null;
let typeface = null;
let opentypeFont = null;
let surface = null;
let selectedTest = null;

// Debug data storage
let debugData = {
  glyphData: null,
  inputJson: null,
  paintOps: null
};

// ============================================
// Glyph Extraction (using opentype.js)
// ============================================

function getGlyphDataFromDOM(element) {
  const text = element.textContent;
  const style = window.getComputedStyle(element);
  const rect = element.getBoundingClientRect();
  const fontSize = parseFloat(style.fontSize);

  if (!opentypeFont) {
    console.error('opentype.js font not loaded');
    return null;
  }

  // Get glyphs using opentype.js for accurate glyph IDs
  const glyphs = opentypeFont.stringToGlyphs(text);
  const scale = fontSize / opentypeFont.unitsPerEm;

  // Calculate positions with kerning
  const positions = [];
  let x = 0;

  // Parse letter-spacing
  let letterSpacing = 0;
  if (style.letterSpacing && style.letterSpacing !== 'normal') {
    letterSpacing = parseFloat(style.letterSpacing) || 0;
  }

  for (let i = 0; i < glyphs.length; i++) {
    positions.push(x);

    const glyph = glyphs[i];
    const advance = glyph.advanceWidth * scale;

    // Apply kerning if available
    let kerning = 0;
    if (i < glyphs.length - 1) {
      kerning = opentypeFont.getKerningValue(glyph, glyphs[i + 1]) * scale;
    }

    x += advance + kerning + letterSpacing;
  }

  const totalWidth = x;
  const ascent = opentypeFont.ascender * scale;
  const descent = -opentypeFont.descender * scale;

  return {
    text,
    glyphs: glyphs.map(g => g.index),
    positions,
    fontMetrics: {
      ascent,
      descent,
      width: totalWidth,
      fontSize,
      fontFamily: style.fontFamily.split(',')[0].replace(/['"]/g, '').trim(),
      fontWeight: parseInt(style.fontWeight) || 400,
      unitsPerEm: opentypeFont.unitsPerEm
    },
    box: {
      x: rect.left,
      y: rect.top,
      width: rect.width,
      height: rect.height
    },
    style: extractTextStyle(style),
    decorations: extractDecorations(style),
    shadows: extractShadows(style)
  };
}

function extractTextStyle(style) {
  return {
    fill_color: rgbaToHex(style.color),
    stroke_color: '#00000000',
    stroke_width: 0,
    paint_order: 'normal'
  };
}

function extractDecorations(style) {
  const decorations = [];
  const textDecorationLine = style.textDecorationLine || 'none';
  const textDecorationStyle = style.textDecorationStyle || 'solid';
  const textDecorationColor = style.textDecorationColor || style.color;

  // Map CSS decoration style to our format
  const styleMap = {
    'solid': 'solid',
    'double': 'double',
    'dotted': 'dotted',
    'dashed': 'dashed',
    'wavy': 'wavy'
  };

  const decoStyle = styleMap[textDecorationStyle] || 'solid';
  const decoColor = rgbaToHex(textDecorationColor);

  if (textDecorationLine.includes('underline')) {
    decorations.push({
      line: 'underline',
      style: decoStyle,
      color: decoColor,
      thickness: 1
    });
  }

  if (textDecorationLine.includes('overline')) {
    decorations.push({
      line: 'overline',
      style: decoStyle,
      color: decoColor,
      thickness: 1
    });
  }

  if (textDecorationLine.includes('line-through')) {
    decorations.push({
      line: 'line-through',
      style: decoStyle,
      color: decoColor,
      thickness: 1
    });
  }

  return decorations;
}

function extractShadows(style) {
  const textShadow = style.textShadow;
  if (!textShadow || textShadow === 'none') {
    return null;
  }

  // Parse text-shadow: offsetX offsetY blur color
  // Simple parser for basic shadow format
  const shadows = [];
  const parts = textShadow.split(/,(?![^(]*\))/);

  for (const part of parts) {
    const match = part.trim().match(/^(rgba?\([^)]+\)|#[0-9a-f]+|\w+)?\s*(-?[\d.]+)px\s+(-?[\d.]+)px\s*([\d.]+px)?\s*(rgba?\([^)]+\)|#[0-9a-f]+|\w+)?$/i);
    if (match) {
      const color = match[1] || match[5] || 'rgba(0,0,0,1)';
      const offsetX = parseFloat(match[2]) || 0;
      const offsetY = parseFloat(match[3]) || 0;
      const blur = parseFloat(match[4]) || 0;

      const rgba = parseColor(color);
      shadows.push({
        offset_x: offsetX,
        offset_y: offsetY,
        blur: blur,
        color: rgba
      });
    }
  }

  return shadows.length > 0 ? shadows : null;
}

function parseColor(color) {
  // Handle rgba format
  const rgbaMatch = color.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*([\d.]+))?\)/);
  if (rgbaMatch) {
    return {
      r: parseInt(rgbaMatch[1]),
      g: parseInt(rgbaMatch[2]),
      b: parseInt(rgbaMatch[3]),
      a: rgbaMatch[4] !== undefined ? Math.round(parseFloat(rgbaMatch[4]) * 255) : 255
    };
  }

  // Handle hex format
  const hexMatch = color.match(/^#([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})?$/i);
  if (hexMatch) {
    return {
      r: parseInt(hexMatch[1], 16),
      g: parseInt(hexMatch[2], 16),
      b: parseInt(hexMatch[3], 16),
      a: hexMatch[4] ? parseInt(hexMatch[4], 16) : 255
    };
  }

  // Default to black
  return { r: 0, g: 0, b: 0, a: 255 };
}

function rgbaToHex(colorStr) {
  const rgba = parseColor(colorStr);
  const toHex = n => n.toString(16).padStart(2, '0');
  return `#${toHex(rgba.a)}${toHex(rgba.r)}${toHex(rgba.g)}${toHex(rgba.b)}`;
}

// ============================================
// Input JSON Generation
// ============================================

function generateInputJson(glyphData, boxX, boxY) {
  const fm = glyphData.fontMetrics;

  const input = {
    fragment: {
      text: glyphData.text,
      from: 0,
      to: glyphData.text.length,
      shape_result: {
        bounds: {
          x: 0,
          y: -fm.ascent,
          width: fm.width,
          height: fm.ascent + fm.descent
        },
        runs: [{
          font: {
            family: fm.fontFamily,
            size: fm.fontSize,
            weight: fm.fontWeight,
            width: 5,
            slant: 0,
            scaleX: 1,
            skewX: 0,
            embolden: fm.fontWeight >= 600,
            linearMetrics: true,
            subpixel: true,
            forceAutoHinting: false,
            typefaceId: 27,
            ascent: fm.ascent,
            descent: fm.descent
          },
          glyphs: glyphData.glyphs,
          positions: glyphData.positions,
          offsetX: 0,
          offsetY: 0,
          positioning: 1  // POSITIONING_HORIZONTAL
        }]
      }
    },
    box: {
      x: boxX,
      y: boxY,
      width: fm.width + 20,
      height: fm.ascent + fm.descent + 10
    },
    style: {
      fill_color: glyphData.style.fill_color,
      stroke_color: glyphData.style.stroke_color,
      stroke_width: glyphData.style.stroke_width,
      emphasis_mark_color: glyphData.style.fill_color,
      current_color: glyphData.style.fill_color,
      color_scheme: 'light',
      paint_order: 'normal'
    },
    paint_phase: 'foreground',
    node_id: 1,
    state_ids: {
      transform_id: 1,
      clip_id: 1,
      effect_id: 1
    }
  };

  // Add decorations if present
  if (glyphData.decorations && glyphData.decorations.length > 0) {
    input.decorations = glyphData.decorations;
  }

  // Add shadows if present
  if (glyphData.shadows) {
    input.style.shadows = glyphData.shadows;
  }

  return input;
}

// ============================================
// Paint Ops Simulation (since WASM not built yet)
// ============================================

function simulatePaintOps(inputJson) {
  // This simulates what text_painter would output
  // In production, this would call the WASM module

  const ops = [];
  const fm = inputJson.fragment.shape_result.runs[0].font;
  const box = inputJson.box;

  // Calculate text origin (baseline position)
  const textX = box.x;
  const textY = box.y + fm.ascent;

  // Parse fill color
  const fillColor = parseHexColor(inputJson.style.fill_color);

  // Add decorations (underline/overline) before text
  if (inputJson.decorations) {
    for (const deco of inputJson.decorations) {
      if (deco.line === 'underline' || deco.line === 'overline') {
        ops.push(createDecorationOp(deco, box, fm, inputJson.state_ids));
      }
    }
  }

  // Main text blob
  const run = inputJson.fragment.shape_result.runs[0];
  ops.push({
    type: 'DrawTextBlobOp',
    x: textX,
    y: textY,
    runs: [{
      glyphCount: run.glyphs.length,
      glyphs: run.glyphs,
      positions: run.positions.map(x => ({ x, y: 0 })),
      positioning: 2,  // POSITIONING_FULL
      font: {
        family: fm.family,
        size: fm.size,
        weight: fm.weight,
        embolden: fm.embolden
      },
      offsetX: 0,
      offsetY: 0
    }],
    flags: {
      r: fillColor.r,
      g: fillColor.g,
      b: fillColor.b,
      a: fillColor.a
    },
    transform_id: inputJson.state_ids.transform_id,
    clip_id: inputJson.state_ids.clip_id,
    effect_id: inputJson.state_ids.effect_id
  });

  // Add line-through after text
  if (inputJson.decorations) {
    for (const deco of inputJson.decorations) {
      if (deco.line === 'line-through') {
        ops.push(createDecorationOp(deco, box, fm, inputJson.state_ids));
      }
    }
  }

  return ops;
}

function createDecorationOp(deco, box, fm, stateIds) {
  const decoColor = parseHexColor(deco.color);
  const width = box.width - 20;
  const thickness = deco.thickness || Math.max(1, fm.size / 10);

  let y;
  switch (deco.line) {
    case 'underline':
      y = box.y + fm.ascent + fm.descent * 0.5;
      break;
    case 'overline':
      y = box.y;
      break;
    case 'line-through':
      y = box.y + fm.ascent * 0.65;
      break;
    default:
      y = box.y + fm.ascent;
  }

  // For wavy style, use DrawPathOp
  if (deco.style === 'wavy') {
    return createWavyDecorationOp(box.x, y, width, thickness, decoColor, stateIds);
  }

  return {
    type: 'DrawRectOp',
    rect: [box.x, y, box.x + width, y + thickness],
    flags: {
      r: decoColor.r,
      g: decoColor.g,
      b: decoColor.b,
      a: decoColor.a,
      style: 0  // Fill
    },
    transform_id: stateIds.transform_id,
    clip_id: stateIds.clip_id,
    effect_id: stateIds.effect_id
  };
}

function createWavyDecorationOp(x, y, width, thickness, color, stateIds) {
  // Create SVG path for wavy line
  const wavelength = 4;
  const amplitude = 2;
  let path = `M ${x} ${y}`;

  for (let px = 0; px < width; px += wavelength / 2) {
    const offset = (Math.floor(px / (wavelength / 2)) % 2 === 0) ? amplitude : -amplitude;
    path += ` Q ${x + px + wavelength / 4} ${y + offset} ${x + px + wavelength / 2} ${y}`;
  }

  return {
    type: 'DrawPathOp',
    path,
    flags: {
      r: color.r,
      g: color.g,
      b: color.b,
      a: color.a,
      style: 1,  // Stroke
      strokeWidth: thickness
    },
    transform_id: stateIds.transform_id,
    clip_id: stateIds.clip_id,
    effect_id: stateIds.effect_id
  };
}

function parseHexColor(hex) {
  // Format: #AARRGGBB
  const match = hex.match(/^#([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})$/i);
  if (match) {
    return {
      r: parseInt(match[2], 16) / 255,
      g: parseInt(match[3], 16) / 255,
      b: parseInt(match[4], 16) / 255,
      a: parseInt(match[1], 16) / 255
    };
  }
  return { r: 0, g: 0, b: 0, a: 1 };
}

// ============================================
// CanvasKit Renderer (adapted from test.html)
// ============================================

class PaintOpRenderer {
  constructor(canvasKit) {
    this.ck = canvasKit;
  }

  renderOp(canvas, op) {
    if (!op || !op.type) return;

    switch (op.type) {
      case 'DrawRectOp':
        this.drawRect(canvas, op);
        break;
      case 'DrawTextBlobOp':
        this.drawTextBlob(canvas, op);
        break;
      case 'DrawPathOp':
        this.drawPath(canvas, op);
        break;
    }
  }

  drawRect(canvas, op) {
    if (!op.rect || op.rect.length !== 4) return;

    const rect = this.ck.LTRBRect(op.rect[0], op.rect[1], op.rect[2], op.rect[3]);
    const paint = new this.ck.Paint();
    paint.setAntiAlias(true);

    if (op.flags) {
      paint.setColor(this.ck.Color4f(
        op.flags.r || 0,
        op.flags.g || 0,
        op.flags.b || 0,
        op.flags.a || 1
      ));

      if (op.flags.style === 1) {
        paint.setStyle(this.ck.PaintStyle.Stroke);
        paint.setStrokeWidth(op.flags.strokeWidth || 1);
      } else {
        paint.setStyle(this.ck.PaintStyle.Fill);
      }
    }

    canvas.drawRect(rect, paint);
    paint.delete();
  }

  drawPath(canvas, op) {
    if (!op.path) return;

    const path = this.ck.Path.MakeFromSVGString(op.path);
    if (!path) return;

    const paint = new this.ck.Paint();
    paint.setAntiAlias(true);

    if (op.flags) {
      paint.setColor(this.ck.Color4f(
        op.flags.r || 0,
        op.flags.g || 0,
        op.flags.b || 0,
        op.flags.a || 1
      ));

      if (op.flags.style === 1) {
        paint.setStyle(this.ck.PaintStyle.Stroke);
        paint.setStrokeWidth(op.flags.strokeWidth || 1);
      } else {
        paint.setStyle(this.ck.PaintStyle.Fill);
      }
    }

    canvas.drawPath(path, paint);
    paint.delete();
    path.delete();
  }

  drawTextBlob(canvas, op) {
    if (!op.runs || op.runs.length === 0) return;

    const paint = new this.ck.Paint();
    paint.setAntiAlias(true);

    if (op.flags) {
      paint.setColor(this.ck.Color4f(
        op.flags.r || 0,
        op.flags.g || 0,
        op.flags.b || 0,
        op.flags.a || 1
      ));
    } else {
      paint.setColor(this.ck.BLACK);
    }

    for (const run of op.runs) {
      if (!run.glyphs || run.glyphCount <= 0) continue;

      const fontInfo = run.font || {};
      const fontSize = fontInfo.size || 16;

      const font = new this.ck.Font(typeface, fontSize);
      font.setHinting(this.ck.FontHinting.Normal);
      font.setSubpixel(true);
      font.setEdging(this.ck.FontEdging.SubpixelAntiAlias);

      if (fontInfo.weight >= 600 || fontInfo.embolden) {
        font.setEmbolden(true);
      }

      const glyphs = new Uint16Array(run.glyphCount);
      for (let i = 0; i < run.glyphCount && i < run.glyphs.length; i++) {
        glyphs[i] = run.glyphs[i];
      }

      const rsxforms = new Float32Array(run.glyphCount * 4);

      if (run.positions) {
        for (let i = 0; i < run.glyphCount && i < run.positions.length; i++) {
          const pos = run.positions[i];
          rsxforms[i * 4] = 1.0;
          rsxforms[i * 4 + 1] = 0.0;
          rsxforms[i * 4 + 2] = pos.x || 0;
          rsxforms[i * 4 + 3] = pos.y || 0;
        }
      }

      const blob = this.ck.TextBlob.MakeFromRSXformGlyphs(glyphs, rsxforms, font);
      if (blob) {
        const drawX = (op.x || 0) + (run.offsetX || 0);
        const drawY = (op.y || 0) + (run.offsetY || 0);
        canvas.drawTextBlob(blob, drawX, drawY, paint);
        blob.delete();
      }

      font.delete();
    }

    paint.delete();
  }
}

// ============================================
// UI Functions
// ============================================

function createTestCaseElements() {
  const container = document.getElementById('tests-list');
  container.innerHTML = '';

  for (const test of TEST_CASES) {
    const div = document.createElement('div');
    div.className = 'test-item';
    div.dataset.id = test.id;

    const label = document.createElement('div');
    label.className = 'test-label';
    label.textContent = test.label;

    const textSpan = document.createElement('span');
    textSpan.className = 'test-text';
    textSpan.textContent = test.text;

    // Apply CSS styles
    for (const [prop, value] of Object.entries(test.css)) {
      textSpan.style[prop] = value;
    }

    div.appendChild(label);
    div.appendChild(textSpan);
    div.addEventListener('click', () => selectTest(test.id));
    container.appendChild(div);
  }
}

function selectTest(testId) {
  selectedTest = TEST_CASES.find(t => t.id === testId);
  if (!selectedTest) return;

  // Update UI
  document.querySelectorAll('.test-item').forEach(el => {
    el.classList.toggle('selected', el.dataset.id === testId);
  });

  renderComparison();
}

function renderComparison() {
  if (!selectedTest || !CanvasKit || !typeface || !opentypeFont) return;

  // Create DOM element for extraction
  const domRender = document.getElementById('dom-render');
  domRender.innerHTML = '';

  const textEl = document.createElement('span');
  textEl.style.fontFamily = 'Arial, sans-serif';
  textEl.textContent = selectedTest.text;

  // Apply CSS
  for (const [prop, value] of Object.entries(selectedTest.css)) {
    textEl.style[prop] = value;
  }

  domRender.appendChild(textEl);

  // Small delay to ensure rendering completes
  requestAnimationFrame(() => {
    // Extract glyph data
    const glyphData = getGlyphDataFromDOM(textEl);
    debugData.glyphData = glyphData;

    // Generate input JSON
    const inputJson = generateInputJson(glyphData, 10, 30);
    debugData.inputJson = inputJson;

    // Generate paint ops (simulated for now)
    const paintOps = simulatePaintOps(inputJson);
    debugData.paintOps = paintOps;

    // Render to canvas
    const canvasEl = document.getElementById('canvas-render');
    const fm = glyphData.fontMetrics;
    canvasEl.width = Math.max(400, fm.width + 40);
    canvasEl.height = Math.max(100, fm.ascent + fm.descent + 60);

    if (surface) {
      surface.delete();
    }

    surface = CanvasKit.MakeCanvasSurface('canvas-render');
    if (!surface) {
      console.error('Failed to create surface');
      return;
    }

    const canvas = surface.getCanvas();
    canvas.clear(CanvasKit.WHITE);

    const renderer = new PaintOpRenderer(CanvasKit);
    for (const op of paintOps) {
      renderer.renderOp(canvas, op);
    }

    surface.flush();

    // Update debug panel
    updateDebugPanel();
  });
}

function updateDebugPanel() {
  const output = document.getElementById('debug-output');
  const activeTab = document.querySelector('.tab.active').dataset.tab;

  switch (activeTab) {
    case 'glyph-data':
      output.textContent = JSON.stringify(debugData.glyphData, null, 2);
      break;
    case 'input-json':
      output.textContent = JSON.stringify(debugData.inputJson, null, 2);
      break;
    case 'paint-ops':
      output.textContent = JSON.stringify(debugData.paintOps, null, 2);
      break;
  }
}

// Tab handling
document.querySelectorAll('.tab').forEach(tab => {
  tab.addEventListener('click', () => {
    document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
    tab.classList.add('active');
    updateDebugPanel();
  });
});

// ============================================
// Initialization
// ============================================

async function init() {
  const statusEl = document.getElementById('status');

  try {
    statusEl.textContent = 'Loading CanvasKit...';
    statusEl.className = 'loading';

    // Initialize CanvasKit
    CanvasKit = await CanvasKitInit({
      locateFile: (file) => `https://unpkg.com/canvaskit-wasm@0.39.1/bin/${file}`,
    });

    statusEl.textContent = 'Loading fonts...';

    // Load font for CanvasKit (try local first, then remote)
    let fontData;
    try {
      const fontResp = await fetch('Arial.ttf');
      if (fontResp.ok) {
        fontData = await fontResp.arrayBuffer();
      } else {
        throw new Error('Local font not found');
      }
    } catch (e) {
      // Try system font fallback - create from default
      console.warn('Could not load Arial.ttf, using fallback');
      statusEl.textContent = 'Arial.ttf not found. Please add Arial.ttf to the project root.';
      statusEl.className = 'error';
      return;
    }

    typeface = CanvasKit.Typeface.MakeFreeTypeFaceFromData(fontData);
    if (!typeface) {
      throw new Error('Failed to create typeface from font data');
    }

    // Load font for opentype.js
    try {
      opentypeFont = await opentype.load('Arial.ttf');
    } catch (e) {
      throw new Error('Failed to load font with opentype.js: ' + e.message);
    }

    statusEl.textContent = 'Ready! Select a test case to compare rendering.';
    statusEl.className = '';

    // Create test case elements
    createTestCaseElements();

    // Select first test by default
    selectTest(TEST_CASES[0].id);

  } catch (e) {
    console.error(e);
    statusEl.textContent = 'Error: ' + e.message;
    statusEl.className = 'error';
  }
}

init();

</script>
</body>
</html>
