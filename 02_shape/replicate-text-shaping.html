<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Replicate Text Shaping</title>
  <style>
    body {
      font-family: system-ui, sans-serif;
      padding: 20px;
      max-width: 1200px;
      margin: 0 auto;
    }
    .controls {
      margin-bottom: 20px;
      padding: 15px;
      background: #f5f5f5;
      border-radius: 8px;
    }
    button {
      padding: 10px 20px;
      margin-right: 10px;
      cursor: pointer;
    }
    #status {
      margin-top: 10px;
      padding: 10px;
      background: #e8f5e9;
      border-radius: 4px;
    }
    .comparison {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 20px;
      margin-top: 20px;
    }
    .panel {
      border: 1px solid #ddd;
      border-radius: 8px;
      padding: 15px;
    }
    .panel h3 {
      margin-top: 0;
      border-bottom: 1px solid #eee;
      padding-bottom: 10px;
    }
    .text-item {
      margin: 10px 0;
      padding: 10px;
      background: #fafafa;
      border-radius: 4px;
      font-size: 12px;
    }
    .text-item .text-content {
      font-weight: bold;
      margin-bottom: 5px;
    }
    .text-item .positions {
      font-family: monospace;
      color: #666;
      word-break: break-all;
    }
    .match { background: #e8f5e9; }
    .mismatch { background: #ffebee; }
    .diff {
      color: #c62828;
      font-weight: bold;
    }
    #results {
      margin-top: 20px;
    }
    .stats {
      padding: 15px;
      background: #e3f2fd;
      border-radius: 8px;
      margin-bottom: 20px;
    }
  </style>
  <script src="https://unpkg.com/canvaskit-wasm@0.39.1/bin/canvaskit.js"></script>
</head>
<body>
  <h1>Text Shaping Replication</h1>

  <div class="controls">
    <div style="margin-bottom: 15px;">
      <strong>1. Input Files:</strong><br>
      <label style="display: inline-block; margin: 5px 10px 5px 0;">
        layout_tree.json: <input type="file" id="layoutFile" accept=".json">
      </label>
      <label style="display: inline-block; margin: 5px 10px 5px 0;">
        Debug log (optional): <input type="file" id="debugFile" accept=".log,.txt">
      </label>
    </div>
    <div style="margin-bottom: 15px;">
      <strong>2. Output Files (select where to save):</strong><br>
      <button id="selectPreShapeBtn" style="margin: 5px 10px 5px 0;">Select layout_tree_pre_shape.json</button>
      <span id="preShapeStatus" style="color: #666;">Not selected</span><br>
      <button id="selectReconBtn" style="margin: 5px 10px 5px 0;">Select layout_tree_reconstructed.json</button>
      <span id="reconStatus" style="color: #666;">Not selected</span><br>
      <button id="selectDebugOutBtn" style="margin: 5px 10px 5px 0;">Select text_shaping_debug.log</button>
      <span id="debugOutStatus" style="color: #666;">Not selected</span>
    </div>
    <div style="margin-bottom: 10px;">
      <strong>3. Run:</strong>
      <button id="compareBtn" disabled>Run Comparison</button>
      <label style="margin-left: 20px;">
        Tolerance (px): <input type="number" id="tolerance" value="0.5" step="0.1" min="0" style="width: 60px;">
      </label>
    </div>
    <div id="status">Select layout_tree.json to begin...</div>
    <div id="debugInfo" style="margin-top: 10px; padding: 10px; background: #fff3e0; border-radius: 4px; display: none;">
      <strong>Debug Log:</strong>
      <pre id="debugContent" style="font-size: 10px; max-height: 150px; overflow: auto; margin: 5px 0;"></pre>
    </div>
  </div>

  <div id="results"></div>

  <script>
    let CanvasKit = null;
    let layoutData = null;
    let arialTypeface = null;
    let fontMgr = null;
    let debugLogData = null;
    let preShapeFileHandle = null;
    let reconFileHandle = null;
    let debugOutFileHandle = null;
    let debugLogLines = [];

    // Initialize CanvasKit and font
    async function init() {
      try {
        updateStatus('Initializing CanvasKit...');
        CanvasKit = await CanvasKitInit({
          locateFile: (file) => `https://unpkg.com/canvaskit-wasm@0.39.1/bin/${file}`
        });

        updateStatus('Loading Arial.ttf...');
        const fontResponse = await fetch('Arial.ttf');
        if (!fontResponse.ok) {
          throw new Error(`Failed to load Arial.ttf: ${fontResponse.status}`);
        }
        const fontData = await fontResponse.arrayBuffer();
        arialTypeface = CanvasKit.Typeface.MakeFreeTypeFaceFromData(fontData);
        if (!arialTypeface) {
          throw new Error('Failed to create typeface from Arial.ttf');
        }

        // Create FontMgr with Arial for Paragraph API
        fontMgr = CanvasKit.FontMgr.FromData([fontData]);
        if (!fontMgr) {
          throw new Error('Failed to create FontMgr');
        }

        // Debug: check what fonts are available
        const fontCount = fontMgr.countFamilies();
        const families = [];
        for (let i = 0; i < fontCount; i++) {
          families.push(fontMgr.getFamilyName(i));
        }
        console.log('Available fonts in FontMgr:', families);

        updateStatus('CanvasKit ready. Select layout_tree.json file to continue...');

      } catch (e) {
        updateStatus(`Error: ${e.message}`);
        console.error(e);
      }
    }

    // Handle layout_tree.json file selection
    function handleLayoutFile(event) {
      const file = event.target.files[0];
      if (!file) return;

      const reader = new FileReader();
      reader.onload = (e) => {
        try {
          layoutData = JSON.parse(e.target.result);
          const textNodes = layoutData.layout_tree.filter(n => n.text && n.fragments);
          updateStatus(`Loaded ${textNodes.length} text nodes from ${file.name}. Click "Run Comparison" to start.`);
          document.getElementById('compareBtn').disabled = false;
        } catch (err) {
          updateStatus(`Error parsing JSON: ${err.message}`);
        }
      };
      reader.readAsText(file);
    }

    // Handle debug log file selection
    function handleDebugFile(event) {
      const file = event.target.files[0];
      if (!file) return;

      const reader = new FileReader();
      reader.onload = (e) => {
        debugLogData = e.target.result;
        document.getElementById('debugInfo').style.display = 'block';
        document.getElementById('debugContent').textContent = debugLogData.substring(0, 2000) +
          (debugLogData.length > 2000 ? '\n... (truncated)' : '');
        console.log('Debug log loaded:', debugLogData.length, 'bytes');
      };
      reader.readAsText(file);
    }

    // Select output file for pre-shape JSON
    async function selectPreShapeFile() {
      try {
        preShapeFileHandle = await window.showSaveFilePicker({
          suggestedName: 'layout_tree_pre_shape.json',
          types: [{
            description: 'JSON Files',
            accept: { 'application/json': ['.json'] }
          }]
        });
        document.getElementById('preShapeStatus').textContent = preShapeFileHandle.name;
        document.getElementById('preShapeStatus').style.color = '#2e7d32';
      } catch (err) {
        if (err.name !== 'AbortError') {
          console.error('Error selecting pre-shape file:', err);
        }
      }
    }

    // Select output file for reconstructed JSON
    async function selectReconFile() {
      try {
        reconFileHandle = await window.showSaveFilePicker({
          suggestedName: 'layout_tree_reconstructed.json',
          types: [{
            description: 'JSON Files',
            accept: { 'application/json': ['.json'] }
          }]
        });
        document.getElementById('reconStatus').textContent = reconFileHandle.name;
        document.getElementById('reconStatus').style.color = '#2e7d32';
      } catch (err) {
        if (err.name !== 'AbortError') {
          console.error('Error selecting reconstructed file:', err);
        }
      }
    }

    // Select output file for debug log
    async function selectDebugOutFile() {
      try {
        debugOutFileHandle = await window.showSaveFilePicker({
          suggestedName: 'text_shaping_debug.log',
          types: [{
            description: 'Log Files',
            accept: { 'text/plain': ['.log', '.txt'] }
          }]
        });
        document.getElementById('debugOutStatus').textContent = debugOutFileHandle.name;
        document.getElementById('debugOutStatus').style.color = '#2e7d32';
      } catch (err) {
        if (err.name !== 'AbortError') {
          console.error('Error selecting debug output file:', err);
        }
      }
    }

    // Write data to a file handle
    async function writeToFileHandle(fileHandle, data) {
      if (!fileHandle) return false;
      try {
        const writable = await fileHandle.createWritable();
        await writable.write(JSON.stringify(data, null, 2));
        await writable.close();
        return true;
      } catch (err) {
        console.error('Error writing to file:', err);
        return false;
      }
    }

    // Write text to a file handle
    async function writeTextToFileHandle(fileHandle, text) {
      if (!fileHandle) return false;
      try {
        const writable = await fileHandle.createWritable();
        await writable.write(text);
        await writable.close();
        return true;
      } catch (err) {
        console.error('Error writing to file:', err);
        return false;
      }
    }

    // Add a debug log line
    function debugLog(msg) {
      debugLogLines.push(msg);
      console.log('[DEBUG]', msg);
    }

    function updateStatus(msg) {
      document.getElementById('status').textContent = msg;
    }

    // Extract text nodes with their styling and glyph data
    function extractTextNodes(layoutTree) {
      const textNodes = [];

      for (const node of layoutTree) {
        if (node.text && node.fragments && node.fragments.length > 0) {
          const style = node.computed_style || {};

          // Chromium stores fragment start/end as positions in the COLLAPSED text
          // So we need to collapse whitespace first, then extract the substring
          const collapsedFullText = collapseWhitespace(node.text);

          for (const fragment of node.fragments) {
            if (fragment.runs && fragment.runs.length > 0) {
              for (const run of fragment.runs) {
                if (run.glyphs && run.positions) {
                  // IMPORTANT: Trust glyph count over fragment boundaries
                  // Fragment start/end can be incorrect (point outside valid range)
                  // The glyph count tells us exactly how many characters were shaped
                  const glyphCount = run.glyphs.length;

                  // Try fragment boundaries first, but validate against glyph count
                  let fragmentText = collapsedFullText.substring(fragment.start, fragment.end);

                  // If fragment text length doesn't match glyph count, use full text
                  if (fragmentText.length !== glyphCount) {
                    // Fragment boundaries are wrong - use full collapsed text if glyph count matches
                    if (collapsedFullText.length === glyphCount) {
                      fragmentText = collapsedFullText;
                    }
                    // Otherwise keep the mismatched text for debugging
                  }

                  textNodes.push({
                    id: node.id,
                    name: node.name,
                    text: fragmentText,
                    originalText: node.text,
                    collapsedFullText: collapsedFullText,
                    start: fragment.start,
                    end: fragment.end,
                    style: {
                      fontFamily: style.font_family || 'Arial',
                      fontSize: style.font_size || 16,
                      fontWeight: style.font_weight || 400,
                      fontStyle: style.font_style || 'normal',
                      letterSpacing: style.letter_spacing || 0,
                      wordSpacing: style.word_spacing || 0
                    },
                    chromiumGlyphs: run.glyphs,
                    chromiumPositions: run.positions
                  });
                }
              }
            }
          }
        }
      }

      return textNodes;
    }

    // Collapse whitespace like CSS does (similar to Chromium's behavior)
    // This handles: newlines -> space, multiple spaces -> single space, trim leading/trailing
    function collapseWhitespace(text) {
      // Replace newlines and tabs with spaces
      let collapsed = text.replace(/[\n\r\t]/g, ' ');
      // Collapse multiple spaces to single space
      collapsed = collapsed.replace(/  +/g, ' ');
      // Trim leading and trailing whitespace
      collapsed = collapsed.trim();
      return collapsed;
    }

    // Shape text using CanvasKit Paragraph API
    // NOTE: text is expected to already be collapsed (from extractTextNodes)
    function shapeText(text, style) {
      const collapsedText = text;

      let glyphs = [];
      let positions = [];
      let advances = [];

      // Build paragraph style
      const paraStyle = new CanvasKit.ParagraphStyle({
        textStyle: {
          color: CanvasKit.BLACK,
          fontFamilies: ['Arial'],
          fontSize: style.fontSize,
          fontStyle: {
            weight: style.fontWeight === 700 ? CanvasKit.FontWeight.Bold : CanvasKit.FontWeight.Normal,
            slant: style.fontStyle === 'italic' ? CanvasKit.FontSlant.Italic : CanvasKit.FontSlant.Upright
          },
          letterSpacing: style.letterSpacing || 0,
          wordSpacing: style.wordSpacing || 0
        }
      });

      const builder = CanvasKit.ParagraphBuilder.Make(paraStyle, fontMgr);
      builder.addText(collapsedText);
      const paragraph = builder.build();

      // Layout at a very wide width to avoid line breaks
      paragraph.layout(10000);

      // Get shaped lines with glyph positions
      const shapedLines = paragraph.getShapedLines();

      if (shapedLines && shapedLines.length > 0) {
        for (const line of shapedLines) {
          if (line.runs) {
            for (const run of line.runs) {
              if (run.glyphs && run.positions) {
                // Glyphs are straightforward
                glyphs = glyphs.concat(Array.from(run.glyphs));

                // Positions are [x0, y0, x1, y1, ...] - extract just x values
                const xPositions = [];
                for (let i = 0; i < run.glyphs.length; i++) {
                  xPositions.push(run.positions[i * 2]); // x position
                }
                positions = positions.concat(xPositions);

                // Calculate advances: advance[i] = position[i+1] - position[i]
                for (let i = 0; i < xPositions.length; i++) {
                  if (i < xPositions.length - 1) {
                    advances.push(xPositions[i + 1] - xPositions[i]);
                  } else {
                    // Last glyph - use glyph width
                    const font = new CanvasKit.Font(arialTypeface, style.fontSize);
                    const lastGlyphWidth = font.getGlyphWidths(new Uint16Array([run.glyphs[i]]))[0] || 0;
                    advances.push(lastGlyphWidth);
                    font.delete();
                  }
                }
              }
            }
          }
        }
      }

      // Fallback to simple approach if Paragraph API didn't work
      if (glyphs.length === 0) {
        const font = new CanvasKit.Font(arialTypeface, style.fontSize);
        font.setSubpixel(true);
        const glyphIds = font.getGlyphIDs(collapsedText);
        const glyphWidths = font.getGlyphWidths(glyphIds);

        let currentX = 0;
        for (let i = 0; i < collapsedText.length; i++) {
          positions.push(currentX);
          advances.push(glyphWidths[i] || 0);
          currentX += (glyphWidths[i] || 0);
          if (style.letterSpacing) currentX += style.letterSpacing;
          if (style.wordSpacing && (collapsedText[i] === ' ' || collapsedText[i] === '\u00A0')) {
            currentX += style.wordSpacing;
          }
        }
        glyphs = Array.from(glyphIds);
        font.delete();
      }

      paragraph.delete();
      builder.delete();

      return { glyphs, positions, advances, collapsedText };
    }

    // Compare positions with tolerance
    // letterSpacing: CanvasKit adds letterSpacing/2 as initial offset, Chromium starts at 0
    function comparePositions(chromiumPos, canvaskitPos, tolerance = 0.5, letterSpacing = 0) {
      if (chromiumPos.length !== canvaskitPos.length) {
        return { match: false, reason: 'length mismatch' };
      }

      // CanvasKit Paragraph API adds letterSpacing/2 as initial X offset
      // Chromium starts at position 0. Correct for this offset.
      const letterSpacingOffset = letterSpacing / 2;
      const correctedCkPos = canvaskitPos.map(pos => pos - letterSpacingOffset);

      const diffs = [];
      let maxDiff = 0;

      for (let i = 0; i < chromiumPos.length; i++) {
        const diff = Math.abs(chromiumPos[i] - correctedCkPos[i]);
        diffs.push(diff);
        maxDiff = Math.max(maxDiff, diff);
      }

      return {
        match: maxDiff <= tolerance,
        maxDiff,
        diffs,
        avgDiff: diffs.reduce((a, b) => a + b, 0) / diffs.length,
        letterSpacingOffset,
        correctedCkPos
      };
    }

    // Run the comparison
    async function runComparison() {
      if (!CanvasKit || !layoutData || !arialTypeface) {
        updateStatus('Not ready yet');
        return;
      }

      updateStatus('Running comparison...');

      // Reset debug log
      debugLogLines = [];
      debugLog('=== Text Shaping Comparison Debug Log ===');
      debugLog(`Timestamp: ${new Date().toISOString()}`);
      debugLog(`CanvasKit version: 0.39.1`);
      debugLog('');

      const textNodes = extractTextNodes(layoutData.layout_tree);
      debugLog(`Total text nodes to process: ${textNodes.length}`);
      debugLog('');

      const results = [];

      let matches = 0;
      let mismatches = 0;

      const tolerance = parseFloat(document.getElementById('tolerance').value) || 0.5;

      for (const node of textNodes) {
        const canvaskitResult = shapeText(node.text, node.style);

        const comparison = comparePositions(
          node.chromiumPositions,
          canvaskitResult.positions,
          tolerance,
          node.style.letterSpacing || 0
        );

        if (comparison.match) {
          matches++;
        } else {
          mismatches++;
          // Log detailed mismatch info
          debugLog(`--- MISMATCH #${mismatches} ---`);
          debugLog(`Text: "${node.text.substring(0, 50)}${node.text.length > 50 ? '...' : ''}"`);
          debugLog(`Original text: "${(node.originalText || '').substring(0, 50)}..."`);
          debugLog(`Style: fontSize=${node.style.fontSize}, letterSpacing=${node.style.letterSpacing}, wordSpacing=${node.style.wordSpacing}`);
          debugLog(`Text length: ${node.text.length}, Chromium glyphs: ${node.chromiumGlyphs.length}, CK glyphs: ${canvaskitResult.glyphs.length}`);
          debugLog(`Char codes: ${node.text.substring(0, 15).split('').map(c => c.charCodeAt(0)).join(', ')}`);
          debugLog(`Chromium glyphs: [${node.chromiumGlyphs.slice(0, 10).join(', ')}${node.chromiumGlyphs.length > 10 ? '...' : ''}]`);
          debugLog(`CanvasKit glyphs: [${canvaskitResult.glyphs.slice(0, 10).join(', ')}${canvaskitResult.glyphs.length > 10 ? '...' : ''}]`);
          debugLog(`Chromium positions: [${node.chromiumPositions.slice(0, 10).map(p => p.toFixed(3)).join(', ')}]`);
          debugLog(`CanvasKit positions: [${canvaskitResult.positions.slice(0, 10).map(p => p.toFixed(3)).join(', ')}]`);
          if (comparison.letterSpacingOffset > 0) {
            debugLog(`Letter-spacing offset correction: ${comparison.letterSpacingOffset.toFixed(3)} (letterSpacing/2)`);
            debugLog(`CK positions (corrected): [${comparison.correctedCkPos.slice(0, 10).map(p => p.toFixed(3)).join(', ')}]`);
          }

          // Calculate advances
          if (comparison.reason !== 'length mismatch') {
            const crAdvances = [];
            const ckAdvances = [];
            for (let i = 1; i < Math.min(node.chromiumPositions.length, 10); i++) {
              crAdvances.push((node.chromiumPositions[i] - node.chromiumPositions[i-1]).toFixed(3));
              ckAdvances.push((canvaskitResult.positions[i] - canvaskitResult.positions[i-1]).toFixed(3));
            }
            debugLog(`Chromium advances: [${crAdvances.join(', ')}]`);
            debugLog(`CanvasKit advances: [${ckAdvances.join(', ')}]`);
            debugLog(`Advance diffs: [${crAdvances.map((a, i) => (parseFloat(a) - parseFloat(ckAdvances[i])).toFixed(3)).join(', ')}]`);
            debugLog(`Max diff: ${comparison.maxDiff.toFixed(3)}, Avg diff: ${comparison.avgDiff.toFixed(3)}`);
          } else {
            debugLog(`Reason: ${comparison.reason} (Chromium: ${node.chromiumPositions.length}, CK: ${canvaskitResult.positions.length})`);
          }
          debugLog('');
        }

        results.push({
          ...node,
          canvaskitGlyphs: canvaskitResult.glyphs,
          canvaskitPositions: canvaskitResult.positions,
          comparison
        });
      }

      // Analyze mismatch patterns
      const mismatchAnalysis = analyzeMismatches(results.filter(r => !r.comparison.match));

      // Add summary to debug log
      debugLog('=== SUMMARY ===');
      debugLog(`Total: ${results.length}, Matches: ${matches}, Mismatches: ${mismatches}`);
      debugLog(`Match rate: ${((matches / results.length) * 100).toFixed(1)}%`);
      debugLog(`Length mismatches: ${mismatchAnalysis.lengthMismatch}`);
      debugLog(`Glyph ID mismatches: ${mismatchAnalysis.glyphMismatch}`);
      debugLog(`Small diffs (<1px): ${mismatchAnalysis.smallDiff}`);
      debugLog(`Medium diffs (1-5px): ${mismatchAnalysis.mediumDiff}`);
      debugLog(`Large diffs (>5px): ${mismatchAnalysis.largeDiff}`);
      debugLog(`Fractional font sizes: ${mismatchAnalysis.fractionalFontSize || 0}`);
      debugLog(`By font: ${JSON.stringify(mismatchAnalysis.byFont)}`);

      // Write debug log to file
      if (debugOutFileHandle) {
        writeTextToFileHandle(debugOutFileHandle, debugLogLines.join('\n')).then(success => {
          if (success) console.log('Debug log written');
        });
      }

      // Render results
      renderResults(results, matches, mismatches, mismatchAnalysis);
      updateStatus(`Comparison complete: ${matches} matches, ${mismatches} mismatches`);
    }

    function analyzeMismatches(mismatches) {
      const analysis = {
        lengthMismatch: 0,
        glyphMismatch: 0,
        positionDrift: 0,
        firstPosDiff: 0,
        smallDiff: 0,    // < 1px
        mediumDiff: 0,   // 1-5px
        largeDiff: 0,    // > 5px
        byFont: {},
        examples: []
      };

      for (const m of mismatches) {
        // Check for glyph ID mismatches
        const glyphsMatch = m.chromiumGlyphs.length === m.canvaskitGlyphs.length &&
          m.chromiumGlyphs.every((g, i) => g === m.canvaskitGlyphs[i]);
        if (!glyphsMatch) {
          analysis.glyphMismatch++;
        }

        if (m.comparison.reason === 'length mismatch') {
          analysis.lengthMismatch++;
          analysis.examples.push({
            text: m.text,
            reason: `Length: Chromium=${m.chromiumPositions.length}, CK=${m.canvaskitPositions.length}`,
            chromiumGlyphs: m.chromiumGlyphs.slice(0, 10),
            canvaskitGlyphs: m.canvaskitGlyphs.slice(0, 10)
          });
        } else {
          const maxDiff = m.comparison.maxDiff;
          if (maxDiff < 1) analysis.smallDiff++;
          else if (maxDiff < 5) analysis.mediumDiff++;
          else analysis.largeDiff++;

          // Check if first position differs (offset issue)
          if (m.comparison.diffs[0] > 0.1) {
            analysis.firstPosDiff++;
          }

          // Track cumulative drift
          const lastDiff = m.comparison.diffs[m.comparison.diffs.length - 1];
          if (lastDiff > maxDiff * 0.8) {
            analysis.positionDrift++;
          }

          // Track by font
          const fontKey = `${m.style.fontFamily}-${m.style.fontSize}`;
          analysis.byFont[fontKey] = (analysis.byFont[fontKey] || 0) + 1;

          // Check for fractional font sizes
          if (m.style.fontSize % 1 !== 0) {
            analysis.fractionalFontSize = (analysis.fractionalFontSize || 0) + 1;
          }

          if (analysis.examples.length < 10) {
            // Calculate per-glyph advance differences
            const chromiumAdvances = [];
            const canvaskitAdvances = [];
            const advanceDiffs = [];
            for (let i = 1; i < Math.min(m.chromiumPositions.length, 8); i++) {
              const crAdv = m.chromiumPositions[i] - m.chromiumPositions[i-1];
              const ckAdv = m.canvaskitPositions[i] - m.canvaskitPositions[i-1];
              chromiumAdvances.push(crAdv.toFixed(2));
              canvaskitAdvances.push(ckAdv.toFixed(2));
              advanceDiffs.push((crAdv - ckAdv).toFixed(3));
            }
            // Show character codes for debugging
            const charCodes = m.text.substring(0, 8).split('').map(c =>
              `'${c}'(${c.charCodeAt(0)})`
            );
            analysis.examples.push({
              text: m.text.substring(0, 30),
              chars: charCodes.join(' '),
              reason: `maxDiff=${maxDiff.toFixed(2)}, firstDiff=${m.comparison.diffs[0]?.toFixed(2)}`,
              fontSize: m.style.fontSize,
              letterSpacing: m.style.letterSpacing,
              wordSpacing: m.style.wordSpacing,
              chromiumPos: m.chromiumPositions.slice(0, 8).map(p => p.toFixed(2)),
              canvaskitPos: m.canvaskitPositions.slice(0, 8).map(p => p.toFixed(2)),
              chromiumAdvances,
              canvaskitAdvances,
              advanceDiffs
            });
          }
        }
      }

      return analysis;
    }

    function renderResults(results, matches, mismatches, mismatchAnalysis) {
      const container = document.getElementById('results');

      // Stats
      let statsHtml = `
        <div class="stats">
          <strong>Results:</strong> ${matches} matches, ${mismatches} mismatches
          (${((matches / results.length) * 100).toFixed(1)}% match rate)
        </div>
      `;

      // Mismatch analysis
      if (mismatchAnalysis && mismatches > 0) {
        statsHtml += `
          <div class="stats" style="background: #ffebee; margin-top: 10px;">
            <strong>Mismatch Analysis:</strong><br>
            - Length mismatches: ${mismatchAnalysis.lengthMismatch}<br>
            - Small diffs (&lt;1px): ${mismatchAnalysis.smallDiff}<br>
            - Medium diffs (1-5px): ${mismatchAnalysis.mediumDiff}<br>
            - Large diffs (&gt;5px): ${mismatchAnalysis.largeDiff}<br>
            - First position differs: ${mismatchAnalysis.firstPosDiff}<br>
            - Cumulative drift: ${mismatchAnalysis.positionDrift}<br>
            - Fractional font sizes: ${mismatchAnalysis.fractionalFontSize || 0}<br>
            - Glyph ID mismatches: ${mismatchAnalysis.glyphMismatch}<br>
            <br><strong>By Font:</strong> ${JSON.stringify(mismatchAnalysis.byFont)}<br>
            <br><strong>Examples:</strong><br>
            <pre style="font-size: 10px; max-height: 200px; overflow: auto;">${JSON.stringify(mismatchAnalysis.examples, null, 2)}</pre>
          </div>
        `
      }

      // Generate pre-shaping JSON (without positions)
      const preShapingData = {
        layout_tree: layoutData.layout_tree.map(node => {
          if (!node.fragments) return node;

          return {
            ...node,
            fragments: node.fragments.map(frag => ({
              ...frag,
              runs: frag.runs?.map(run => ({
                glyphs: null,
                positions: null
              }))
            }))
          };
        })
      };

      // Store data and write to file handles if available
      window._preShapingData = preShapingData;
      window._reconstructedData = reconstructLayoutTree(results);

      // Write to file handles if selected
      let writeStatus = '';
      if (preShapeFileHandle) {
        writeToFileHandle(preShapeFileHandle, preShapingData).then(success => {
          if (success) console.log('Written to pre-shape file');
        });
        writeStatus += `Pre-shape: ${preShapeFileHandle.name} ✓ `;
      }
      if (reconFileHandle) {
        writeToFileHandle(reconFileHandle, window._reconstructedData).then(success => {
          if (success) console.log('Written to reconstructed file');
        });
        writeStatus += `Reconstructed: ${reconFileHandle.name} ✓`;
      }

      // Download buttons (fallback)
      const downloadHtml = `
        <div style="margin-bottom: 20px;">
          ${writeStatus ? `<div style="color: #2e7d32; margin-bottom: 10px;">Files written: ${writeStatus}</div>` : ''}
          <button id="downloadPreBtn">Download layout_tree_pre_shape.json</button>
          <button id="downloadReconBtn">Download layout_tree_reconstructed.json</button>
        </div>
      `;

      // Results table
      let resultsHtml = '<div class="comparison"><div class="panel"><h3>Chromium (Original)</h3>';

      for (const r of results.slice(0, 50)) {
        const matchClass = r.comparison.match ? 'match' : 'mismatch';
        resultsHtml += `
          <div class="text-item ${matchClass}">
            <div class="text-content">"${escapeHtml(r.text)}"</div>
            <div>Font: ${r.style.fontFamily} ${r.style.fontSize}px, weight: ${r.style.fontWeight}</div>
            <div>Letter-spacing: ${r.style.letterSpacing}, Word-spacing: ${r.style.wordSpacing}</div>
            <div class="positions">Glyphs: [${r.chromiumGlyphs.slice(0, 10).join(', ')}${r.chromiumGlyphs.length > 10 ? '...' : ''}]</div>
            <div class="positions">Positions: [${r.chromiumPositions.slice(0, 10).map(p => p.toFixed(2)).join(', ')}${r.chromiumPositions.length > 10 ? '...' : ''}]</div>
          </div>
        `;
      }
      resultsHtml += '</div><div class="panel"><h3>CanvasKit (Reconstructed)</h3>';

      for (const r of results.slice(0, 50)) {
        const matchClass = r.comparison.match ? 'match' : 'mismatch';
        resultsHtml += `
          <div class="text-item ${matchClass}">
            <div class="text-content">"${escapeHtml(r.text)}"</div>
            <div>Max diff: ${r.comparison.maxDiff?.toFixed(2) || 'N/A'}, Avg diff: ${r.comparison.avgDiff?.toFixed(2) || 'N/A'}</div>
            <div class="positions">Glyphs: [${r.canvaskitGlyphs.slice(0, 10).join(', ')}${r.canvaskitGlyphs.length > 10 ? '...' : ''}]</div>
            <div class="positions">Positions: [${r.canvaskitPositions.slice(0, 10).map(p => (p ?? 0).toFixed(2)).join(', ')}${r.canvaskitPositions.length > 10 ? '...' : ''}]</div>
          </div>
        `;
      }
      resultsHtml += '</div></div>';

      if (results.length > 50) {
        resultsHtml += `<p>Showing first 50 of ${results.length} text fragments...</p>`;
      }

      container.innerHTML = statsHtml + downloadHtml + resultsHtml;

      document.getElementById('downloadPreBtn').addEventListener('click', downloadPreShaping);
      document.getElementById('downloadReconBtn').addEventListener('click', downloadReconstructed);
    }

    function reconstructLayoutTree(results) {
      const reconstructedByNode = new Map();
      for (const r of results) {
        if (!reconstructedByNode.has(r.id)) {
          reconstructedByNode.set(r.id, []);
        }
        reconstructedByNode.get(r.id).push({
          start: r.start,
          end: r.end,
          glyphs: r.canvaskitGlyphs,
          positions: r.canvaskitPositions
        });
      }

      return {
        layout_tree: layoutData.layout_tree.map(node => {
          if (!node.fragments) return node;

          const reconstructed = reconstructedByNode.get(node.id) || [];
          let fragIndex = 0;

          return {
            ...node,
            fragments: node.fragments.map(frag => ({
              ...frag,
              runs: frag.runs?.map(run => {
                const recon = reconstructed[fragIndex++];
                return {
                  glyphs: recon?.glyphs || run.glyphs,
                  positions: recon?.positions || run.positions,
                  positioning: run.positioning
                };
              })
            }))
          };
        })
      };
    }

    function downloadPreShaping() {
      downloadJson(window._preShapingData, 'layout_tree_pre_shape.json');
    }

    function downloadReconstructed() {
      downloadJson(window._reconstructedData, 'layout_tree_reconstructed.json');
    }

    function downloadJson(data, filename) {
      const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = filename;
      a.click();
      URL.revokeObjectURL(url);
    }

    function escapeHtml(text) {
      return text.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
    }

    // Set up event listeners and initialize
    document.getElementById('compareBtn').addEventListener('click', runComparison);
    document.getElementById('layoutFile').addEventListener('change', handleLayoutFile);
    document.getElementById('debugFile').addEventListener('change', handleDebugFile);
    document.getElementById('selectPreShapeBtn').addEventListener('click', selectPreShapeFile);
    document.getElementById('selectReconBtn').addEventListener('click', selectReconFile);
    document.getElementById('selectDebugOutBtn').addEventListener('click', selectDebugOutFile);
    init();
  </script>
</body>
</html>
