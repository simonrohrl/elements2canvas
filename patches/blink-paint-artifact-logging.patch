diff --git a/cc/paint/draw_looper.h b/cc/paint/draw_looper.h
index c04a907ff8..5c977caf3e 100644
--- a/cc/paint/draw_looper.h
+++ b/cc/paint/draw_looper.h
@@ -36,6 +36,18 @@ class CC_PAINT_EXPORT DrawLooper : public SkRefCnt {
     kDontModifyPaintFlag = 1 << 2,
   };
 
+  // Layer struct (moved to public for JSON serialization access)
+  struct Layer {
+    SkPoint offset;
+    float blur_sigma;
+    SkColor4f color;
+    uint32_t flags;
+
+    bool operator==(const Layer& other) const = default;
+
+    void Apply(SkCanvas* canvas, SkPaint* paint) const;
+  };
+
   ~DrawLooper() override;
 
   //  The callback will be invoked for each "layer" in the looper, each time
@@ -64,6 +76,9 @@ class CC_PAINT_EXPORT DrawLooper : public SkRefCnt {
 
   bool EqualsForTesting(const DrawLooper& other) const;
 
+  // Public accessor for JSON serialization
+  const std::vector<Layer>& GetLayers() const { return layers_; }
+
  private:
   // Keep this in sync with the fields in Flags
   // Used to mask out illegal bits when constructing Layer
@@ -72,16 +87,6 @@ class CC_PAINT_EXPORT DrawLooper : public SkRefCnt {
         kPostTransformFlag | kOverrideAlphaFlag | kDontModifyPaintFlag,
   };
 
-  struct Layer {
-    SkPoint offset;
-    float blur_sigma;
-    SkColor4f color;
-    uint32_t flags;
-
-    bool operator==(const Layer& other) const = default;
-
-    void Apply(SkCanvas* canvas, SkPaint* paint) const;
-  };
   std::vector<Layer> layers_;
 
   explicit DrawLooper(std::vector<Layer> l);
diff --git a/third_party/blink/renderer/platform/graphics/compositing/paint_artifact_compositor.cc b/third_party/blink/renderer/platform/graphics/compositing/paint_artifact_compositor.cc
index d52098547f..b8f2fa5a22 100644
--- a/third_party/blink/renderer/platform/graphics/compositing/paint_artifact_compositor.cc
+++ b/third_party/blink/renderer/platform/graphics/compositing/paint_artifact_compositor.cc
@@ -5,6 +5,7 @@
 #include "third_party/blink/renderer/platform/graphics/compositing/paint_artifact_compositor.h"
 
 #include <algorithm>
+#include "third_party/blink/renderer/platform/graphics/compositing/paint_artifact_json_serializer.h"
 #include <memory>
 #include <utility>
 
@@ -1021,6 +1022,13 @@ void PaintArtifactCompositor::Update(
   OldPendingLayerMatcher old_pending_layer_matcher(std::move(pending_layers_));
   CHECK(painted_scroll_translations_.empty());
 
+  // Log raw PaintArtifact BEFORE layerization
+  auto paint_artifact_json = SerializePaintArtifact(artifact);
+  auto paint_artifact_props_json = SerializePaintArtifactPropertyTrees(artifact);
+  LOG(ERROR) << "PAINT_ARTIFACT: " << paint_artifact_json->ToJSONString().Utf8();
+  LOG(ERROR) << "PAINT_ARTIFACT_PROPERTY_TREES: "
+             << paint_artifact_props_json->ToJSONString().Utf8();
+
   // Make compositing decisions, storing the result in |pending_layers_|.
   pending_layers_ = Layerizer(*this, artifact, old_size).Layerize();
   PendingLayer::DecompositeTransforms(pending_layers_);
@@ -1160,6 +1168,19 @@ void PaintArtifactCompositor::Update(
            << GetLayersAsJSON(VLOG_IS_ON(3) ? 0xffffffff : 0)
                   ->ToPrettyJSONString()
                   .Utf8();
+
+  // Log Blink-level layer and property tree data for debugging/analysis
+  auto blink_layers_json =
+      SerializePendingLayersWithPaintOps(pending_layers_, artifact);
+  auto blink_property_trees_json =
+      SerializeBlinkPropertyTrees(pending_layers_, artifact);
+  LOG(ERROR) << "BLINK_LAYERS: " << blink_layers_json->ToJSONString().Utf8();
+  LOG(ERROR) << "BLINK_PROPERTY_TREES: "
+             << blink_property_trees_json->ToJSONString().Utf8();
+
+  // Log raw paint ops WITHOUT chunk grouping - flat list in paint order
+  auto raw_paint_ops_json = SerializeRawPaintOps(artifact);
+  LOG(ERROR) << "RAW_PAINT_OPS: " << raw_paint_ops_json->ToJSONString().Utf8();
 }
 
 bool PaintArtifactCompositor::TryFastPathUpdate(
diff --git a/third_party/blink/renderer/platform/graphics/compositing/paint_artifact_json_serializer.cc b/third_party/blink/renderer/platform/graphics/compositing/paint_artifact_json_serializer.cc
index 7282912e5b..0161e2eeb1 100644
--- a/third_party/blink/renderer/platform/graphics/compositing/paint_artifact_json_serializer.cc
+++ b/third_party/blink/renderer/platform/graphics/compositing/paint_artifact_json_serializer.cc
@@ -7,6 +7,8 @@
 #include <unordered_map>
 
 #include "base/compiler_specific.h"
+#include "cc/paint/draw_looper.h"
+#include "cc/paint/paint_filter.h"
 #include "cc/paint/paint_op.h"
 #include "cc/paint/paint_op_buffer_iterator.h"
 #include "third_party/blink/renderer/platform/allow_discouraged_type.h"
@@ -19,9 +21,14 @@
 #include "third_party/blink/renderer/platform/graphics/paint/transform_paint_property_node.h"
 #include "third_party/blink/renderer/platform/json/json_values.h"
 #include "third_party/blink/renderer/platform/wtf/text/string_builder.h"
+#include "third_party/skia/include/core/SkFont.h"
+#include "third_party/skia/include/core/SkFontStyle.h"
 #include "third_party/skia/include/core/SkPath.h"
+#include "third_party/skia/include/core/SkRSXform.h"
 #include "third_party/skia/include/core/SkTextBlob.h"
+#include "third_party/skia/include/core/SkTypeface.h"
 #include "third_party/skia/include/utils/SkParsePath.h"
+#include "third_party/skia/src/core/SkTextBlobPriv.h"
 #include "ui/gfx/geometry/transform.h"
 
 namespace blink {
@@ -152,6 +159,24 @@ std::unique_ptr<JSONObject> SerializePaintFlags(const cc::PaintFlags& flags) {
     }
   }
 
+  // Handle draw looper (shadows)
+  if (const auto& looper = flags.getLooper()) {
+    auto shadows_array = std::make_unique<JSONArray>();
+    for (const auto& layer : looper->GetLayers()) {
+      auto shadow_json = std::make_unique<JSONObject>();
+      shadow_json->SetDouble("offsetX", layer.offset.x());
+      shadow_json->SetDouble("offsetY", layer.offset.y());
+      shadow_json->SetDouble("blurSigma", layer.blur_sigma);
+      shadow_json->SetDouble("r", layer.color.fR);
+      shadow_json->SetDouble("g", layer.color.fG);
+      shadow_json->SetDouble("b", layer.color.fB);
+      shadow_json->SetDouble("a", layer.color.fA);
+      shadow_json->SetInteger("flags", layer.flags);
+      shadows_array->PushObject(std::move(shadow_json));
+    }
+    json->SetArray("shadows", std::move(shadows_array));
+  }
+
   return json;
 }
 
@@ -259,13 +284,142 @@ void SerializePaintOpRecursive(const cc::PaintOp& op, JSONObject* json) {
       json->SetObject("flags", SerializePaintFlags(draw_op.flags));
       break;
     }
+    case cc::PaintOpType::kDrawDRRect: {
+      // DrawDRRect draws between outer and inner rounded rects (used for borders, box-shadow inset)
+      const auto& draw_op = static_cast<const cc::DrawDRRectOp&>(op);
+      // Outer rrect
+      json->SetArray("outer_rect", SerializeRectLTRB(draw_op.outer.rect()));
+      auto outer_radii = std::make_unique<JSONArray>();
+      outer_radii->PushDouble(draw_op.outer.radii(SkRRect::kUpperLeft_Corner).x());
+      outer_radii->PushDouble(draw_op.outer.radii(SkRRect::kUpperLeft_Corner).y());
+      outer_radii->PushDouble(draw_op.outer.radii(SkRRect::kUpperRight_Corner).x());
+      outer_radii->PushDouble(draw_op.outer.radii(SkRRect::kUpperRight_Corner).y());
+      outer_radii->PushDouble(draw_op.outer.radii(SkRRect::kLowerRight_Corner).x());
+      outer_radii->PushDouble(draw_op.outer.radii(SkRRect::kLowerRight_Corner).y());
+      outer_radii->PushDouble(draw_op.outer.radii(SkRRect::kLowerLeft_Corner).x());
+      outer_radii->PushDouble(draw_op.outer.radii(SkRRect::kLowerLeft_Corner).y());
+      json->SetArray("outer_radii", std::move(outer_radii));
+      // Inner rrect
+      json->SetArray("inner_rect", SerializeRectLTRB(draw_op.inner.rect()));
+      auto inner_radii = std::make_unique<JSONArray>();
+      inner_radii->PushDouble(draw_op.inner.radii(SkRRect::kUpperLeft_Corner).x());
+      inner_radii->PushDouble(draw_op.inner.radii(SkRRect::kUpperLeft_Corner).y());
+      inner_radii->PushDouble(draw_op.inner.radii(SkRRect::kUpperRight_Corner).x());
+      inner_radii->PushDouble(draw_op.inner.radii(SkRRect::kUpperRight_Corner).y());
+      inner_radii->PushDouble(draw_op.inner.radii(SkRRect::kLowerRight_Corner).x());
+      inner_radii->PushDouble(draw_op.inner.radii(SkRRect::kLowerRight_Corner).y());
+      inner_radii->PushDouble(draw_op.inner.radii(SkRRect::kLowerLeft_Corner).x());
+      inner_radii->PushDouble(draw_op.inner.radii(SkRRect::kLowerLeft_Corner).y());
+      json->SetArray("inner_radii", std::move(inner_radii));
+      json->SetObject("flags", SerializePaintFlags(draw_op.flags));
+      break;
+    }
     case cc::PaintOpType::kDrawTextBlob: {
       const auto& draw_op = static_cast<const cc::DrawTextBlobOp&>(op);
       json->SetDouble("x", draw_op.x);
       json->SetDouble("y", draw_op.y);
       json->SetInteger("nodeId", draw_op.node_id);
       json->SetObject("flags", SerializePaintFlags(draw_op.flags));
-      // Note: Text blob serialization omitted for simplicity
+
+      // Serialize text blob runs with glyph data using SkTextBlobRunIterator
+      // which properly handles different positioning types
+      if (draw_op.blob) {
+        json->SetArray("bounds", SerializeRectLTRB(draw_op.blob->bounds()));
+
+        auto runs_array = std::make_unique<JSONArray>();
+        for (SkTextBlobRunIterator iter(draw_op.blob.get()); !iter.done();
+             iter.next()) {
+          auto run_json = std::make_unique<JSONObject>();
+          const uint32_t count = iter.glyphCount();
+          run_json->SetInteger("glyphCount", static_cast<int>(count));
+
+          // Serialize glyph IDs
+          // SAFETY: glyphs points to count elements as guaranteed by iter.glyphCount()
+          auto glyphs_array = std::make_unique<JSONArray>();
+          const SkGlyphID* glyphs = iter.glyphs();
+          for (uint32_t i = 0; i < count; ++i) {
+            glyphs_array->PushInteger(UNSAFE_TODO(glyphs[i]));
+          }
+          run_json->SetArray("glyphs", std::move(glyphs_array));
+
+          // Serialize positioning type and data
+          auto positioning = iter.positioning();
+          run_json->SetInteger("positioning", static_cast<int>(positioning));
+
+          // Serialize run offset (baseline position for horizontal runs)
+          const SkPoint& offset = iter.offset();
+          run_json->SetDouble("offsetX", offset.x());
+          run_json->SetDouble("offsetY", offset.y());
+
+          if (positioning == SkTextBlobRunIterator::kRSXform_Positioning) {
+            // RSXform: [scos, ssin, tx, ty] per glyph
+            // SAFETY: xforms has count elements for RSXform positioning
+            auto rsxforms_array = std::make_unique<JSONArray>();
+            const SkRSXform* xforms = iter.xforms();
+            for (uint32_t i = 0; i < count; ++i) {
+              auto xform_json = std::make_unique<JSONObject>();
+              xform_json->SetDouble("scos", UNSAFE_TODO(xforms[i]).fSCos);
+              xform_json->SetDouble("ssin", UNSAFE_TODO(xforms[i]).fSSin);
+              xform_json->SetDouble("tx", UNSAFE_TODO(xforms[i]).fTx);
+              xform_json->SetDouble("ty", UNSAFE_TODO(xforms[i]).fTy);
+              rsxforms_array->PushObject(std::move(xform_json));
+            }
+            run_json->SetArray("rsxforms", std::move(rsxforms_array));
+          } else if (positioning == SkTextBlobRunIterator::kFull_Positioning) {
+            // Full positioning: x,y pairs
+            // SAFETY: points has count elements for full positioning
+            auto positions_array = std::make_unique<JSONArray>();
+            const SkPoint* points = iter.points();
+            for (uint32_t i = 0; i < count; ++i) {
+              auto pos_json = std::make_unique<JSONObject>();
+              pos_json->SetDouble("x", UNSAFE_TODO(points[i]).x());
+              pos_json->SetDouble("y", UNSAFE_TODO(points[i]).y());
+              positions_array->PushObject(std::move(pos_json));
+            }
+            run_json->SetArray("positions", std::move(positions_array));
+          } else if (positioning ==
+                     SkTextBlobRunIterator::kHorizontal_Positioning) {
+            // Horizontal: x positions only, use iter.pos() for raw scalars
+            // SAFETY: pos has count scalars for horizontal positioning
+            auto positions_array = std::make_unique<JSONArray>();
+            const SkScalar* pos = iter.pos();
+            for (uint32_t i = 0; i < count; ++i) {
+              positions_array->PushDouble(UNSAFE_TODO(pos[i]));
+            }
+            run_json->SetArray("positions", std::move(positions_array));
+          }
+          // kDefault_Positioning has no position data - uses font metrics
+
+          // Serialize font info
+          const SkFont& font = iter.font();
+          auto font_json = std::make_unique<JSONObject>();
+          font_json->SetDouble("size", font.getSize());
+          font_json->SetDouble("scaleX", font.getScaleX());
+          font_json->SetDouble("skewX", font.getSkewX());
+          font_json->SetBoolean("embolden", font.isEmbolden());
+          font_json->SetBoolean("linearMetrics", font.isLinearMetrics());
+          font_json->SetBoolean("subpixel", font.isSubpixel());
+          font_json->SetBoolean("forceAutoHinting", font.isForceAutoHinting());
+
+          // Get typeface info if available
+          if (SkTypeface* typeface = font.getTypeface()) {
+            SkString family_name;
+            typeface->getFamilyName(&family_name);
+            font_json->SetString("family", family_name.c_str());
+            font_json->SetInteger("typefaceId", typeface->uniqueID());
+
+            // Font style
+            SkFontStyle style = typeface->fontStyle();
+            font_json->SetInteger("weight", style.weight());
+            font_json->SetInteger("width", style.width());
+            font_json->SetInteger("slant", static_cast<int>(style.slant()));
+          }
+
+          run_json->SetObject("font", std::move(font_json));
+          runs_array->PushObject(std::move(run_json));
+        }
+        json->SetArray("runs", std::move(runs_array));
+      }
       break;
     }
     case cc::PaintOpType::kDrawRecord: {
@@ -291,6 +445,48 @@ void SerializePaintOpRecursive(const cc::PaintOp& op, JSONObject* json) {
     case cc::PaintOpType::kSaveLayer: {
       const auto& save_op = static_cast<const cc::SaveLayerOp&>(op);
       json->SetArray("bounds", SerializeRectLTRB(save_op.bounds));
+      // Serialize flags including image filter (for shadows/blur)
+      auto flags_json = std::make_unique<JSONObject>();
+      const SkColor4f& color = save_op.flags.getColor4f();
+      flags_json->SetDouble("r", color.fR);
+      flags_json->SetDouble("g", color.fG);
+      flags_json->SetDouble("b", color.fB);
+      flags_json->SetDouble("a", color.fA);
+      // Check for image filter (used for blur, drop shadow, etc.)
+      const auto& image_filter = save_op.flags.getImageFilter();
+      if (image_filter) {
+        auto filter_json = std::make_unique<JSONObject>();
+        cc::PaintFilter::Type filter_type = image_filter->type();
+        filter_json->SetInteger("filterType", static_cast<int>(filter_type));
+        if (filter_type == cc::PaintFilter::Type::kBlur) {
+          const auto* blur =
+              static_cast<const cc::BlurPaintFilter*>(image_filter.get());
+          filter_json->SetString("filterName", "blur");
+          filter_json->SetDouble("sigmaX", blur->sigma_x());
+          filter_json->SetDouble("sigmaY", blur->sigma_y());
+        } else if (filter_type == cc::PaintFilter::Type::kDropShadow) {
+          const auto* shadow =
+              static_cast<const cc::DropShadowPaintFilter*>(image_filter.get());
+          filter_json->SetString("filterName", "dropShadow");
+          filter_json->SetDouble("dx", shadow->dx());
+          filter_json->SetDouble("dy", shadow->dy());
+          filter_json->SetDouble("sigmaX", shadow->sigma_x());
+          filter_json->SetDouble("sigmaY", shadow->sigma_y());
+          const SkColor4f& shadow_color = shadow->color();
+          auto shadow_color_json = std::make_unique<JSONObject>();
+          shadow_color_json->SetDouble("r", shadow_color.fR);
+          shadow_color_json->SetDouble("g", shadow_color.fG);
+          shadow_color_json->SetDouble("b", shadow_color.fB);
+          shadow_color_json->SetDouble("a", shadow_color.fA);
+          filter_json->SetObject("shadowColor", std::move(shadow_color_json));
+          filter_json->SetInteger("shadowMode",
+                                  static_cast<int>(shadow->shadow_mode()));
+        } else {
+          filter_json->SetString("filterName", "other");
+        }
+        flags_json->SetObject("imageFilter", std::move(filter_json));
+      }
+      json->SetObject("flags", std::move(flags_json));
       break;
     }
     case cc::PaintOpType::kSaveLayerAlpha: {
@@ -659,4 +855,140 @@ std::unique_ptr<JSONObject> SerializeBlinkPropertyTrees(
   return json;
 }
 
+std::unique_ptr<JSONObject> SerializePaintArtifact(
+    const PaintArtifact& artifact) {
+  auto json = std::make_unique<JSONObject>();
+  auto chunks_array = std::make_unique<JSONArray>();
+
+  PropertyTreeIdMapper id_mapper;
+
+  int chunk_id = 0;
+  for (const PaintChunk& chunk : artifact.GetPaintChunks()) {
+    auto chunk_json = std::make_unique<JSONObject>();
+    chunk_json->SetInteger("chunk_id", chunk_id++);
+    chunk_json->SetArray("bounds", SerializeGfxRect(chunk.bounds));
+    chunk_json->SetArray("drawable_bounds",
+                         SerializeGfxRect(chunk.drawable_bounds));
+
+    // Debug name from the display item id
+    if (chunk.id.client_id) {
+      chunk_json->SetString("debug_name",
+                            chunk.id.ToString(artifact).Utf8().c_str());
+    }
+
+    // Property tree state for this chunk
+    auto props_json = std::make_unique<JSONObject>();
+    props_json->SetInteger("transform_id",
+                           id_mapper.GetOrAssignTransformId(&chunk.properties.Transform().Unalias()));
+    props_json->SetInteger("clip_id",
+                           id_mapper.GetOrAssignClipId(&chunk.properties.Clip().Unalias()));
+    props_json->SetInteger("effect_id",
+                           id_mapper.GetOrAssignEffectId(&chunk.properties.Effect().Unalias()));
+    chunk_json->SetObject("property_tree_state", std::move(props_json));
+
+    // Serialize paint ops from display items in this chunk
+    auto paint_ops_array = std::make_unique<JSONArray>();
+    // Use UNSAFE_TODO to wrap the unsafe buffer access - this is safe because
+    // begin_index and end_index are validated by the PaintChunk structure.
+    auto display_items = UNSAFE_TODO(
+        artifact.GetDisplayItemList().ItemsInRange(chunk.begin_index,
+                                                   chunk.end_index));
+    for (const DisplayItem& item : display_items) {
+      if (item.IsDrawing()) {
+        const auto& drawing = To<DrawingDisplayItem>(item);
+        const cc::PaintRecord& record = drawing.GetPaintRecord();
+        for (cc::PaintOpBuffer::Iterator it(record.buffer()); it; ++it) {
+          auto op_json = std::make_unique<JSONObject>();
+          SerializePaintOpRecursive(*it, op_json.get());
+          paint_ops_array->PushObject(std::move(op_json));
+        }
+      }
+    }
+    chunk_json->SetArray("paint_ops", std::move(paint_ops_array));
+
+    chunks_array->PushObject(std::move(chunk_json));
+  }
+
+  json->SetArray("PaintChunks", std::move(chunks_array));
+  return json;
+}
+
+std::unique_ptr<JSONObject> SerializePaintArtifactPropertyTrees(
+    const PaintArtifact& artifact) {
+  auto json = std::make_unique<JSONObject>();
+
+  // Collect all property tree nodes from all chunks
+  PropertyTreeIdMapper id_mapper;
+  for (const PaintChunk& chunk : artifact.GetPaintChunks()) {
+    id_mapper.GetOrAssignTransformId(&chunk.properties.Transform().Unalias());
+    id_mapper.GetOrAssignClipId(&chunk.properties.Clip().Unalias());
+    id_mapper.GetOrAssignEffectId(&chunk.properties.Effect().Unalias());
+  }
+
+  json->SetObject("transform_tree",
+                  SerializeTransformTree(id_mapper.GetTransformIds()));
+  json->SetObject("clip_tree", SerializeClipTree(id_mapper.GetClipIds()));
+  json->SetObject("effect_tree", SerializeEffectTree(id_mapper.GetEffectIds()));
+
+  return json;
+}
+
+std::unique_ptr<JSONObject> SerializeRawPaintOps(const PaintArtifact& artifact) {
+  auto json = std::make_unique<JSONObject>();
+  auto paint_ops_array = std::make_unique<JSONArray>();
+
+  // We need property tree IDs, so use a mapper
+  PropertyTreeIdMapper id_mapper;
+
+  // First pass: assign IDs to all property tree nodes
+  for (const PaintChunk& chunk : artifact.GetPaintChunks()) {
+    id_mapper.GetOrAssignTransformId(&chunk.properties.Transform().Unalias());
+    id_mapper.GetOrAssignClipId(&chunk.properties.Clip().Unalias());
+    id_mapper.GetOrAssignEffectId(&chunk.properties.Effect().Unalias());
+  }
+
+  // Second pass: iterate through chunks to get property tree state for each op
+  for (const PaintChunk& chunk : artifact.GetPaintChunks()) {
+    // Get property tree IDs for this chunk
+    int transform_id = id_mapper.GetOrAssignTransformId(
+        &chunk.properties.Transform().Unalias());
+    int clip_id = id_mapper.GetOrAssignClipId(
+        &chunk.properties.Clip().Unalias());
+    int effect_id = id_mapper.GetOrAssignEffectId(
+        &chunk.properties.Effect().Unalias());
+
+    // Iterate through display items in this chunk
+    auto display_items = UNSAFE_TODO(
+        artifact.GetDisplayItemList().ItemsInRange(chunk.begin_index,
+                                                   chunk.end_index));
+    for (const DisplayItem& item : display_items) {
+      if (item.IsDrawing()) {
+        const auto& drawing = To<DrawingDisplayItem>(item);
+        const cc::PaintRecord& record = drawing.GetPaintRecord();
+        for (cc::PaintOpBuffer::Iterator it(record.buffer()); it; ++it) {
+          auto op_json = std::make_unique<JSONObject>();
+          SerializePaintOpRecursive(*it, op_json.get());
+
+          // Add property tree state to each paint op
+          op_json->SetInteger("transform_id", transform_id);
+          op_json->SetInteger("clip_id", clip_id);
+          op_json->SetInteger("effect_id", effect_id);
+
+          paint_ops_array->PushObject(std::move(op_json));
+        }
+      }
+    }
+  }
+
+  json->SetArray("paint_ops", std::move(paint_ops_array));
+
+  // Also include the property trees for reference
+  json->SetObject("transform_tree",
+                  SerializeTransformTree(id_mapper.GetTransformIds()));
+  json->SetObject("clip_tree", SerializeClipTree(id_mapper.GetClipIds()));
+  json->SetObject("effect_tree", SerializeEffectTree(id_mapper.GetEffectIds()));
+
+  return json;
+}
+
 }  // namespace blink
diff --git a/third_party/blink/renderer/platform/graphics/compositing/paint_artifact_json_serializer.h b/third_party/blink/renderer/platform/graphics/compositing/paint_artifact_json_serializer.h
index 7e9c66850e..7378e7efc4 100644
--- a/third_party/blink/renderer/platform/graphics/compositing/paint_artifact_json_serializer.h
+++ b/third_party/blink/renderer/platform/graphics/compositing/paint_artifact_json_serializer.h
@@ -27,6 +27,29 @@ PLATFORM_EXPORT std::unique_ptr<JSONObject> SerializeBlinkPropertyTrees(
     const PendingLayers& pending_layers,
     const PaintArtifact& artifact);
 
+// Serializes the raw PaintArtifact (PaintChunks + DisplayItems) BEFORE
+// layerization. This captures the paint data in its most granular form.
+PLATFORM_EXPORT std::unique_ptr<JSONObject> SerializePaintArtifact(
+    const PaintArtifact& artifact);
+
+// Serializes Blink property trees from raw PaintArtifact (before layerization).
+PLATFORM_EXPORT std::unique_ptr<JSONObject> SerializePaintArtifactPropertyTrees(
+    const PaintArtifact& artifact);
+
+// Serializes raw paint operations from PaintArtifact WITHOUT chunk grouping.
+// This outputs a flat list of paint ops in paint order, similar to what would
+// be captured by logging GraphicsContext calls directly.
+// Output format:
+// {
+//   "paint_ops": [
+//     { "type": "DrawRectOp", "rect": [...], "flags": {...} },
+//     { "type": "DrawTextBlobOp", ... },
+//     ...
+//   ]
+// }
+PLATFORM_EXPORT std::unique_ptr<JSONObject> SerializeRawPaintOps(
+    const PaintArtifact& artifact);
+
 }  // namespace blink
 
 #endif  // THIRD_PARTY_BLINK_RENDERER_PLATFORM_GRAPHICS_COMPOSITING_PAINT_ARTIFACT_JSON_SERIALIZER_H_
