diff --git a/cc/layers/picture_layer_impl.cc b/cc/layers/picture_layer_impl.cc
index 033299bc49..f93a7e7cf3 100644
--- a/cc/layers/picture_layer_impl.cc
+++ b/cc/layers/picture_layer_impl.cc
@@ -1897,7 +1897,8 @@ void PictureLayerImpl::AsValueInto(
       LCDTextDisallowedReasonToString(lcd_text_disallowed_reason_));
 
   state->BeginArray("pictures");
-  raster_source_->AsValueInto(state);
+  // Use AsValueIntoWithPaintOps for verbose logging with full paint op details
+  raster_source_->AsValueIntoWithPaintOps(state);
   state->EndArray();
 
   state->BeginArray("invalidation");
diff --git a/cc/paint/draw_looper.h b/cc/paint/draw_looper.h
index c04a907ff8..5c977caf3e 100644
--- a/cc/paint/draw_looper.h
+++ b/cc/paint/draw_looper.h
@@ -36,6 +36,18 @@ class CC_PAINT_EXPORT DrawLooper : public SkRefCnt {
     kDontModifyPaintFlag = 1 << 2,
   };
 
+  // Layer struct (moved to public for JSON serialization access)
+  struct Layer {
+    SkPoint offset;
+    float blur_sigma;
+    SkColor4f color;
+    uint32_t flags;
+
+    bool operator==(const Layer& other) const = default;
+
+    void Apply(SkCanvas* canvas, SkPaint* paint) const;
+  };
+
   ~DrawLooper() override;
 
   //  The callback will be invoked for each "layer" in the looper, each time
@@ -64,6 +76,9 @@ class CC_PAINT_EXPORT DrawLooper : public SkRefCnt {
 
   bool EqualsForTesting(const DrawLooper& other) const;
 
+  // Public accessor for JSON serialization
+  const std::vector<Layer>& GetLayers() const { return layers_; }
+
  private:
   // Keep this in sync with the fields in Flags
   // Used to mask out illegal bits when constructing Layer
@@ -72,16 +87,6 @@ class CC_PAINT_EXPORT DrawLooper : public SkRefCnt {
         kPostTransformFlag | kOverrideAlphaFlag | kDontModifyPaintFlag,
   };
 
-  struct Layer {
-    SkPoint offset;
-    float blur_sigma;
-    SkColor4f color;
-    uint32_t flags;
-
-    bool operator==(const Layer& other) const = default;
-
-    void Apply(SkCanvas* canvas, SkPaint* paint) const;
-  };
   std::vector<Layer> layers_;
 
   explicit DrawLooper(std::vector<Layer> l);
diff --git a/cc/paint/paint_op_json_serializer.cc b/cc/paint/paint_op_json_serializer.cc
new file mode 100644
index 0000000000..c707dd7a8c
--- /dev/null
+++ b/cc/paint/paint_op_json_serializer.cc
@@ -0,0 +1,550 @@
+// Copyright 2024 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "cc/paint/paint_op_json_serializer.h"
+
+#include <sstream>
+
+#include "base/trace_event/traced_value.h"
+#include "base/trace_event/traced_value_support.h"
+#include "cc/paint/display_item_list.h"
+#include "cc/paint/paint_flags.h"
+#include "cc/paint/paint_op.h"
+#include "cc/paint/paint_op_buffer.h"
+#include "third_party/skia/include/core/SkBlendMode.h"
+#include "third_party/skia/include/core/SkM44.h"
+#include "third_party/skia/include/core/SkPath.h"
+#include "third_party/skia/include/core/SkRRect.h"
+#include "third_party/skia/include/core/SkRect.h"
+#include "third_party/skia/include/core/SkTextBlob.h"
+#include "third_party/skia/include/utils/SkParsePath.h"
+
+namespace cc {
+
+namespace {
+
+const char* BlendModeToString(SkBlendMode mode) {
+  switch (mode) {
+    case SkBlendMode::kClear: return "clear";
+    case SkBlendMode::kSrc: return "src";
+    case SkBlendMode::kDst: return "dst";
+    case SkBlendMode::kSrcOver: return "src-over";
+    case SkBlendMode::kDstOver: return "dst-over";
+    case SkBlendMode::kSrcIn: return "src-in";
+    case SkBlendMode::kDstIn: return "dst-in";
+    case SkBlendMode::kSrcOut: return "src-out";
+    case SkBlendMode::kDstOut: return "dst-out";
+    case SkBlendMode::kSrcATop: return "src-atop";
+    case SkBlendMode::kDstATop: return "dst-atop";
+    case SkBlendMode::kXor: return "xor";
+    case SkBlendMode::kPlus: return "plus";
+    case SkBlendMode::kModulate: return "modulate";
+    case SkBlendMode::kScreen: return "screen";
+    case SkBlendMode::kOverlay: return "overlay";
+    case SkBlendMode::kDarken: return "darken";
+    case SkBlendMode::kLighten: return "lighten";
+    case SkBlendMode::kColorDodge: return "color-dodge";
+    case SkBlendMode::kColorBurn: return "color-burn";
+    case SkBlendMode::kHardLight: return "hard-light";
+    case SkBlendMode::kSoftLight: return "soft-light";
+    case SkBlendMode::kDifference: return "difference";
+    case SkBlendMode::kExclusion: return "exclusion";
+    case SkBlendMode::kMultiply: return "multiply";
+    case SkBlendMode::kHue: return "hue";
+    case SkBlendMode::kSaturation: return "saturation";
+    case SkBlendMode::kColor: return "color";
+    case SkBlendMode::kLuminosity: return "luminosity";
+  }
+  return "unknown";
+}
+
+const char* StyleToString(PaintFlags::Style style) {
+  switch (style) {
+    case PaintFlags::kFill_Style: return "fill";
+    case PaintFlags::kStroke_Style: return "stroke";
+  }
+  return "unknown";
+}
+
+const char* ClipOpToString(SkClipOp op) {
+  switch (op) {
+    case SkClipOp::kDifference: return "difference";
+    case SkClipOp::kIntersect: return "intersect";
+  }
+  return "unknown";
+}
+
+const char* PathFillTypeToString(SkPathFillType type) {
+  switch (type) {
+    case SkPathFillType::kWinding: return "winding";
+    case SkPathFillType::kEvenOdd: return "evenodd";
+    case SkPathFillType::kInverseWinding: return "inverse-winding";
+    case SkPathFillType::kInverseEvenOdd: return "inverse-evenodd";
+  }
+  return "unknown";
+}
+
+}  // namespace
+
+// static
+void PaintOpJsonSerializer::SerializeSkRect(
+    const char* name,
+    const SkRect& rect,
+    base::trace_event::TracedValue* value) {
+  value->BeginArray(name);
+  value->AppendDouble(rect.left());
+  value->AppendDouble(rect.top());
+  value->AppendDouble(rect.right());
+  value->AppendDouble(rect.bottom());
+  value->EndArray();
+}
+
+// static
+void PaintOpJsonSerializer::SerializeSkRRect(
+    const char* name,
+    const SkRRect& rrect,
+    base::trace_event::TracedValue* value) {
+  value->BeginDictionary(name);
+  SerializeSkRect("rect", rrect.rect(), value);
+  // Serialize corner radii [tlX, tlY, trX, trY, brX, brY, blX, blY]
+  value->BeginArray("radii");
+  value->AppendDouble(rrect.radii(SkRRect::kUpperLeft_Corner).x());
+  value->AppendDouble(rrect.radii(SkRRect::kUpperLeft_Corner).y());
+  value->AppendDouble(rrect.radii(SkRRect::kUpperRight_Corner).x());
+  value->AppendDouble(rrect.radii(SkRRect::kUpperRight_Corner).y());
+  value->AppendDouble(rrect.radii(SkRRect::kLowerRight_Corner).x());
+  value->AppendDouble(rrect.radii(SkRRect::kLowerRight_Corner).y());
+  value->AppendDouble(rrect.radii(SkRRect::kLowerLeft_Corner).x());
+  value->AppendDouble(rrect.radii(SkRRect::kLowerLeft_Corner).y());
+  value->EndArray();
+  value->EndDictionary();
+}
+
+// static
+void PaintOpJsonSerializer::SerializeSkM44(
+    const char* name,
+    const SkM44& matrix,
+    base::trace_event::TracedValue* value) {
+  // Serialize as a flat 16-element array in row-major order
+  value->BeginArray(name);
+  for (int row = 0; row < 4; ++row) {
+    for (int col = 0; col < 4; ++col) {
+      value->AppendDouble(matrix.rc(row, col));
+    }
+  }
+  value->EndArray();
+}
+
+// static
+void PaintOpJsonSerializer::SerializeSkColor4f(
+    const char* name,
+    const SkColor4f& color,
+    base::trace_event::TracedValue* value) {
+  value->BeginDictionary(name);
+  value->SetDouble("r", color.fR);
+  value->SetDouble("g", color.fG);
+  value->SetDouble("b", color.fB);
+  value->SetDouble("a", color.fA);
+  value->EndDictionary();
+}
+
+// static
+void PaintOpJsonSerializer::SerializeSkBlendMode(
+    const char* name,
+    SkBlendMode mode,
+    base::trace_event::TracedValue* value) {
+  value->SetString(name, BlendModeToString(mode));
+}
+
+// static
+void PaintOpJsonSerializer::SerializeSkPath(
+    const char* name,
+    const SkPath& path,
+    base::trace_event::TracedValue* value) {
+  // Serialize path as SVG path data string
+  SkString svg_path;
+  SkParsePath::ToSVGString(path, &svg_path);
+  value->SetString(name, std::string(svg_path.c_str(), svg_path.size()));
+
+  // Also include fill type
+  value->SetString("fillType", PathFillTypeToString(path.getFillType()));
+}
+
+// static
+void PaintOpJsonSerializer::SerializeCorePaintFlags(
+    const CorePaintFlags& flags,
+    base::trace_event::TracedValue* value) {
+  value->BeginDictionary("flags");
+  SerializeSkColor4f("color", flags.getColor4f(), value);
+  value->SetString("style", StyleToString(flags.getStyle()));
+  SerializeSkBlendMode("blendMode", flags.getBlendMode(), value);
+  value->SetBoolean("antiAlias", flags.isAntiAlias());
+  value->EndDictionary();
+}
+
+// static
+void PaintOpJsonSerializer::SerializePaintFlags(
+    const PaintFlags& flags,
+    base::trace_event::TracedValue* value) {
+  value->BeginDictionary("flags");
+  SerializeSkColor4f("color", flags.getColor4f(), value);
+  value->SetString("style", StyleToString(flags.getStyle()));
+  SerializeSkBlendMode("blendMode", flags.getBlendMode(), value);
+  value->SetBoolean("antiAlias", flags.isAntiAlias());
+  value->SetDouble("strokeWidth", flags.getStrokeWidth());
+  value->SetDouble("strokeMiter", flags.getStrokeMiter());
+
+  // Cap and Join
+  const char* cap_names[] = {"butt", "round", "square"};
+  const char* join_names[] = {"miter", "round", "bevel"};
+  value->SetString("strokeCap", cap_names[static_cast<int>(flags.getStrokeCap())]);
+  value->SetString("strokeJoin", join_names[static_cast<int>(flags.getStrokeJoin())]);
+
+  // Note: Shaders, filters, and other complex objects are not serialized
+  // as they would require extensive handling. Add HasShader() etc. for debugging.
+  value->SetBoolean("hasShader", !!flags.getShader());
+  value->SetBoolean("hasColorFilter", !!flags.getColorFilter());
+  value->SetBoolean("hasImageFilter", !!flags.getImageFilter());
+  value->SetBoolean("hasPathEffect", !!flags.getPathEffect());
+
+  value->EndDictionary();
+}
+
+// static
+void PaintOpJsonSerializer::SerializePaintOp(
+    const PaintOp& op,
+    base::trace_event::TracedValue* value) {
+  value->SetString("type", PaintOpTypeToString(op.GetType()));
+
+  switch (op.GetType()) {
+    case PaintOpType::kClipRect: {
+      const auto& clip_op = static_cast<const ClipRectOp&>(op);
+      SerializeSkRect("rect", clip_op.rect, value);
+      value->SetString("op", ClipOpToString(clip_op.op));
+      value->SetBoolean("antiAlias", clip_op.antialias);
+      break;
+    }
+    case PaintOpType::kClipRRect: {
+      const auto& clip_op = static_cast<const ClipRRectOp&>(op);
+      SerializeSkRRect("rrect", clip_op.rrect, value);
+      value->SetString("op", ClipOpToString(clip_op.op));
+      value->SetBoolean("antiAlias", clip_op.antialias);
+      break;
+    }
+    case PaintOpType::kClipPath: {
+      const auto& clip_op = static_cast<const ClipPathOp&>(op);
+      SerializeSkPath("path", clip_op.path, value);
+      value->SetString("op", ClipOpToString(clip_op.op));
+      value->SetBoolean("antiAlias", clip_op.antialias);
+      break;
+    }
+    case PaintOpType::kConcat: {
+      const auto& concat_op = static_cast<const ConcatOp&>(op);
+      SerializeSkM44("matrix", concat_op.matrix, value);
+      break;
+    }
+    case PaintOpType::kDrawColor: {
+      const auto& draw_op = static_cast<const DrawColorOp&>(op);
+      SerializeSkColor4f("color", draw_op.color, value);
+      SerializeSkBlendMode("mode", draw_op.mode, value);
+      break;
+    }
+    case PaintOpType::kDrawLine: {
+      const auto& draw_op = static_cast<const DrawLineOp&>(op);
+      value->SetDouble("x0", draw_op.x0);
+      value->SetDouble("y0", draw_op.y0);
+      value->SetDouble("x1", draw_op.x1);
+      value->SetDouble("y1", draw_op.y1);
+      SerializePaintFlags(draw_op.flags, value);
+      break;
+    }
+    case PaintOpType::kDrawLineLite: {
+      const auto& draw_op = static_cast<const DrawLineLiteOp&>(op);
+      value->SetDouble("x0", draw_op.x0);
+      value->SetDouble("y0", draw_op.y0);
+      value->SetDouble("x1", draw_op.x1);
+      value->SetDouble("y1", draw_op.y1);
+      SerializeCorePaintFlags(draw_op.core_paint_flags, value);
+      break;
+    }
+    case PaintOpType::kDrawRect: {
+      const auto& draw_op = static_cast<const DrawRectOp&>(op);
+      SerializeSkRect("rect", draw_op.rect, value);
+      SerializePaintFlags(draw_op.flags, value);
+      break;
+    }
+    case PaintOpType::kDrawIRect: {
+      const auto& draw_op = static_cast<const DrawIRectOp&>(op);
+      value->BeginArray("rect");
+      value->AppendInteger(draw_op.rect.left());
+      value->AppendInteger(draw_op.rect.top());
+      value->AppendInteger(draw_op.rect.right());
+      value->AppendInteger(draw_op.rect.bottom());
+      value->EndArray();
+      SerializePaintFlags(draw_op.flags, value);
+      break;
+    }
+    case PaintOpType::kDrawRRect: {
+      const auto& draw_op = static_cast<const DrawRRectOp&>(op);
+      SerializeSkRRect("rrect", draw_op.rrect, value);
+      SerializePaintFlags(draw_op.flags, value);
+      break;
+    }
+    case PaintOpType::kDrawDRRect: {
+      const auto& draw_op = static_cast<const DrawDRRectOp&>(op);
+      SerializeSkRRect("outer", draw_op.outer, value);
+      SerializeSkRRect("inner", draw_op.inner, value);
+      SerializePaintFlags(draw_op.flags, value);
+      break;
+    }
+    case PaintOpType::kDrawOval: {
+      const auto& draw_op = static_cast<const DrawOvalOp&>(op);
+      SerializeSkRect("oval", draw_op.oval, value);
+      SerializePaintFlags(draw_op.flags, value);
+      break;
+    }
+    case PaintOpType::kDrawArc: {
+      const auto& draw_op = static_cast<const DrawArcOp&>(op);
+      SerializeSkRect("oval", draw_op.oval, value);
+      value->SetDouble("startAngle", draw_op.start_angle_degrees);
+      value->SetDouble("sweepAngle", draw_op.sweep_angle_degrees);
+      SerializePaintFlags(draw_op.flags, value);
+      break;
+    }
+    case PaintOpType::kDrawArcLite: {
+      const auto& draw_op = static_cast<const DrawArcLiteOp&>(op);
+      SerializeSkRect("oval", draw_op.oval, value);
+      value->SetDouble("startAngle", draw_op.start_angle_degrees);
+      value->SetDouble("sweepAngle", draw_op.sweep_angle_degrees);
+      SerializeCorePaintFlags(draw_op.core_paint_flags, value);
+      break;
+    }
+    case PaintOpType::kDrawPath: {
+      const auto& draw_op = static_cast<const DrawPathOp&>(op);
+      SerializeSkPath("path", draw_op.path, value);
+      value->SetString("skPathFillType",
+                       PathFillTypeToString(draw_op.sk_path_fill_type));
+      SerializePaintFlags(draw_op.flags, value);
+      break;
+    }
+    case PaintOpType::kDrawImage: {
+      const auto& draw_op = static_cast<const DrawImageOp&>(op);
+      value->SetDouble("left", draw_op.left);
+      value->SetDouble("top", draw_op.top);
+      // Image dimensions if available
+      if (draw_op.image) {
+        value->SetInteger("imageWidth", draw_op.image.width());
+        value->SetInteger("imageHeight", draw_op.image.height());
+      }
+      SerializePaintFlags(draw_op.flags, value);
+      break;
+    }
+    case PaintOpType::kDrawImageRect: {
+      const auto& draw_op = static_cast<const DrawImageRectOp&>(op);
+      SerializeSkRect("src", draw_op.src, value);
+      SerializeSkRect("dst", draw_op.dst, value);
+      if (draw_op.image) {
+        value->SetInteger("imageWidth", draw_op.image.width());
+        value->SetInteger("imageHeight", draw_op.image.height());
+      }
+      SerializePaintFlags(draw_op.flags, value);
+      break;
+    }
+    case PaintOpType::kDrawTextBlob: {
+      const auto& draw_op = static_cast<const DrawTextBlobOp&>(op);
+      value->SetDouble("x", draw_op.x);
+      value->SetDouble("y", draw_op.y);
+      value->SetInteger("nodeId", draw_op.node_id);
+
+      // Serialize glyph IDs and positions from the text blob
+      if (draw_op.blob) {
+        SerializeSkRect("bounds", draw_op.blob->bounds(), value);
+
+        value->BeginArray("runs");
+        SkTextBlob::Iter iter(*draw_op.blob);
+        SkTextBlob::Iter::ExperimentalRun run;
+        while (iter.experimentalNext(&run)) {
+          value->BeginDictionary();
+          value->SetInteger("glyphCount", run.count);
+
+          // Serialize glyph IDs
+          value->BeginArray("glyphs");
+          for (int i = 0; i < run.count; ++i) {
+            value->AppendInteger(run.glyphs[i]);
+          }
+          value->EndArray();
+
+          // Serialize glyph positions (each position is an SkPoint with x, y)
+          value->BeginArray("positions");
+          for (int i = 0; i < run.count; ++i) {
+            value->AppendDouble(run.positions[i].x());
+            value->AppendDouble(run.positions[i].y());
+          }
+          value->EndArray();
+
+          // Serialize font info
+          value->SetDouble("fontSize", run.font.getSize());
+          if (run.font.getTypeface()) {
+            SkString family_name;
+            run.font.getTypeface()->getFamilyName(&family_name);
+            value->SetString("fontFamily",
+                             std::string(family_name.c_str(), family_name.size()));
+          }
+
+          value->EndDictionary();
+        }
+        value->EndArray();
+      }
+
+      SerializePaintFlags(draw_op.flags, value);
+      break;
+    }
+    case PaintOpType::kDrawRecord: {
+      const auto& draw_op = static_cast<const DrawRecordOp&>(op);
+      // Recursively serialize the nested record
+      value->BeginArray("record");
+      for (const PaintOp& nested_op : draw_op.record.buffer()) {
+        value->BeginDictionary();
+        SerializePaintOp(nested_op, value);
+        value->EndDictionary();
+      }
+      value->EndArray();
+      break;
+    }
+    case PaintOpType::kSave: {
+      // No additional data
+      break;
+    }
+    case PaintOpType::kSaveLayer: {
+      const auto& save_op = static_cast<const SaveLayerOp&>(op);
+      SerializeSkRect("bounds", save_op.bounds, value);
+      SerializePaintFlags(save_op.flags, value);
+      break;
+    }
+    case PaintOpType::kSaveLayerAlpha: {
+      const auto& save_op = static_cast<const SaveLayerAlphaOp&>(op);
+      SerializeSkRect("bounds", save_op.bounds, value);
+      value->SetDouble("alpha", save_op.alpha);
+      break;
+    }
+    case PaintOpType::kSaveLayerFilters: {
+      const auto& save_op = static_cast<const SaveLayerFiltersOp&>(op);
+      SerializeSkRect("bounds", save_op.bounds, value);
+      SerializePaintFlags(save_op.flags, value);
+      // Note: Filters are complex objects, just note their presence
+      value->SetBoolean("hasFilters", !save_op.filters.IsEmpty());
+      value->SetBoolean("hasBackdropFilter", !!save_op.backdrop_filter);
+      break;
+    }
+    case PaintOpType::kRestore: {
+      // No additional data
+      break;
+    }
+    case PaintOpType::kRotate: {
+      const auto& rotate_op = static_cast<const RotateOp&>(op);
+      value->SetDouble("degrees", rotate_op.degrees);
+      break;
+    }
+    case PaintOpType::kScale: {
+      const auto& scale_op = static_cast<const ScaleOp&>(op);
+      value->SetDouble("sx", scale_op.sx);
+      value->SetDouble("sy", scale_op.sy);
+      break;
+    }
+    case PaintOpType::kTranslate: {
+      const auto& translate_op = static_cast<const TranslateOp&>(op);
+      value->SetDouble("dx", translate_op.dx);
+      value->SetDouble("dy", translate_op.dy);
+      break;
+    }
+    case PaintOpType::kSetMatrix: {
+      const auto& matrix_op = static_cast<const SetMatrixOp&>(op);
+      SerializeSkM44("matrix", matrix_op.matrix, value);
+      break;
+    }
+    case PaintOpType::kSetNodeId: {
+      const auto& node_op = static_cast<const SetNodeIdOp&>(op);
+      value->SetInteger("nodeId", node_op.node_id);
+      break;
+    }
+    case PaintOpType::kNoop: {
+      // No additional data
+      break;
+    }
+    case PaintOpType::kAnnotate: {
+      const auto& annotate_op = static_cast<const AnnotateOp&>(op);
+      value->SetInteger("annotationType",
+                        static_cast<int>(annotate_op.annotation_type));
+      SerializeSkRect("rect", annotate_op.rect, value);
+      break;
+    }
+    case PaintOpType::kCustomData: {
+      const auto& custom_op = static_cast<const CustomDataOp&>(op);
+      value->SetInteger("id", custom_op.id);
+      break;
+    }
+    case PaintOpType::kDrawScrollingContents: {
+      // Complex type - just note its presence
+      value->SetString("note", "DrawScrollingContents (not fully serialized)");
+      break;
+    }
+    case PaintOpType::kDrawSkottie: {
+      // Animation - complex type
+      value->SetString("note", "DrawSkottie (not fully serialized)");
+      break;
+    }
+    case PaintOpType::kDrawSlug: {
+      // GPU-side text - complex type
+      value->SetString("note", "DrawSlug (not fully serialized)");
+      break;
+    }
+    case PaintOpType::kDrawVertices: {
+      // Mesh drawing - complex type
+      value->SetString("note", "DrawVertices (not fully serialized)");
+      break;
+    }
+  }
+}
+
+// static
+void PaintOpJsonSerializer::SerializePaintOpBuffer(
+    const PaintOpBuffer& buffer,
+    base::trace_event::TracedValue* value) {
+  value->BeginArray("ops");
+  for (const PaintOp& op : buffer) {
+    value->BeginDictionary();
+    SerializePaintOp(op, value);
+    value->EndDictionary();
+  }
+  value->EndArray();
+  value->SetInteger("opCount", static_cast<int>(buffer.size()));
+  value->SetInteger("totalOpCount", static_cast<int>(buffer.total_op_count()));
+}
+
+// static
+void PaintOpJsonSerializer::SerializeDisplayItemList(
+    const DisplayItemList& list,
+    base::trace_event::TracedValue* value) {
+  SerializePaintOpBuffer(list.paint_op_buffer(), value);
+
+  // Add bounds if available
+  if (list.bounds().has_value()) {
+    value->BeginArray("bounds");
+    value->AppendInteger(list.bounds()->x());
+    value->AppendInteger(list.bounds()->y());
+    value->AppendInteger(list.bounds()->width());
+    value->AppendInteger(list.bounds()->height());
+    value->EndArray();
+  }
+}
+
+// static
+std::string PaintOpJsonSerializer::DisplayItemListToJson(
+    const DisplayItemList& list) {
+  base::trace_event::TracedValueJSON traced_value;
+  SerializeDisplayItemList(list, &traced_value);
+  return traced_value.ToFormattedJSON();
+}
+
+}  // namespace cc
diff --git a/cc/paint/paint_op_json_serializer.h b/cc/paint/paint_op_json_serializer.h
new file mode 100644
index 0000000000..23d4de8b13
--- /dev/null
+++ b/cc/paint/paint_op_json_serializer.h
@@ -0,0 +1,83 @@
+// Copyright 2024 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CC_PAINT_PAINT_OP_JSON_SERIALIZER_H_
+#define CC_PAINT_PAINT_OP_JSON_SERIALIZER_H_
+
+#include <string>
+
+#include "base/trace_event/traced_value.h"
+#include "cc/paint/paint_export.h"
+
+namespace cc {
+
+class DisplayItemList;
+class PaintOp;
+class PaintOpBuffer;
+class PaintFlags;
+class CorePaintFlags;
+
+// Serializes paint operations to JSON format for debugging/tracing.
+// This provides human-readable output of paint ops, unlike the binary
+// SKP format used in production tracing.
+class CC_PAINT_EXPORT PaintOpJsonSerializer {
+ public:
+  // Serialize a single paint op to the traced value.
+  static void SerializePaintOp(const PaintOp& op,
+                               base::trace_event::TracedValue* value);
+
+  // Serialize an entire PaintOpBuffer to the traced value as an array.
+  static void SerializePaintOpBuffer(const PaintOpBuffer& buffer,
+                                     base::trace_event::TracedValue* value);
+
+  // Serialize a DisplayItemList's paint ops to the traced value.
+  static void SerializeDisplayItemList(const DisplayItemList& list,
+                                       base::trace_event::TracedValue* value);
+
+  // Convert a DisplayItemList to a JSON string.
+  static std::string DisplayItemListToJson(const DisplayItemList& list);
+
+ private:
+  // Helper to serialize PaintFlags to JSON.
+  static void SerializePaintFlags(const PaintFlags& flags,
+                                  base::trace_event::TracedValue* value);
+
+  // Helper to serialize CorePaintFlags to JSON.
+  static void SerializeCorePaintFlags(const CorePaintFlags& flags,
+                                      base::trace_event::TracedValue* value);
+
+  // Helper to serialize an SkRect.
+  static void SerializeSkRect(const char* name,
+                              const SkRect& rect,
+                              base::trace_event::TracedValue* value);
+
+  // Helper to serialize an SkRRect.
+  static void SerializeSkRRect(const char* name,
+                               const SkRRect& rrect,
+                               base::trace_event::TracedValue* value);
+
+  // Helper to serialize an SkM44 matrix.
+  static void SerializeSkM44(const char* name,
+                             const SkM44& matrix,
+                             base::trace_event::TracedValue* value);
+
+  // Helper to serialize an SkColor4f.
+  static void SerializeSkColor4f(const char* name,
+                                 const SkColor4f& color,
+                                 base::trace_event::TracedValue* value);
+
+  // Helper to serialize SkBlendMode.
+  static void SerializeSkBlendMode(const char* name,
+                                   SkBlendMode mode,
+                                   base::trace_event::TracedValue* value);
+
+  // Helper to serialize SkPath as SVG path string.
+  static void SerializeSkPath(const char* name,
+                              const SkPath& path,
+                              base::trace_event::TracedValue* value);
+};
+
+}  // namespace cc
+
+#endif  // CC_PAINT_PAINT_OP_JSON_SERIALIZER_H_
diff --git a/cc/paint/paint_shader.h b/cc/paint/paint_shader.h
index 29dc5c26dd..95dd6333f7 100644
--- a/cc/paint/paint_shader.h
+++ b/cc/paint/paint_shader.h
@@ -196,6 +196,15 @@ class CC_PAINT_EXPORT PaintShader : public SkRefCnt {
   SkTileMode ty() const { return ty_; }
   SkRect tile() const { return tile_; }
 
+  // Gradient accessors for serialization
+  const std::vector<SkColor4f>& colors() const { return colors_; }
+  const std::vector<SkScalar>& positions() const { return positions_; }
+  SkPoint start_point() const { return start_point_; }
+  SkPoint end_point() const { return end_point_; }
+  SkPoint center() const { return center_; }
+  SkScalar start_radius() const { return start_radius_; }
+  SkScalar end_radius() const { return end_radius_; }
+
   bool IsOpaque() const;
 
   // Returns true if the shader looks like it is valid (ie the members required
diff --git a/cc/raster/raster_source.cc b/cc/raster/raster_source.cc
index 2aabb687de..514b389400 100644
--- a/cc/raster/raster_source.cc
+++ b/cc/raster/raster_source.cc
@@ -8,6 +8,8 @@
 
 #include <algorithm>
 
+#include "base/compiler_specific.h"
+
 #include "base/metrics/histogram_macros.h"
 #include "base/trace_event/trace_event.h"
 #include "cc/base/math_util.h"
@@ -16,9 +18,19 @@
 #include "cc/paint/clear_for_opaque_raster.h"
 #include "cc/paint/display_item_list.h"
 #include "cc/paint/image_provider.h"
+#include "cc/paint/paint_op.h"
+#include "cc/paint/paint_shader.h"
+#include "cc/paint/paint_filter.h"
+#include "cc/paint/paint_op_buffer.h"
+#include "cc/paint/paint_op_buffer_iterator.h"
 #include "cc/paint/skia_paint_canvas.h"
 #include "components/viz/common/traced_value.h"
 #include "third_party/skia/include/core/SkCanvas.h"
+#include "third_party/skia/include/core/SkRRect.h"
+#include "third_party/skia/include/core/SkTextBlob.h"
+#include "third_party/skia/include/core/SkRSXform.h"
+#include "third_party/skia/include/utils/SkParsePath.h"
+#include "third_party/skia/src/core/SkTextBlobPriv.h"
 #include "ui/gfx/geometry/axis_transform2d.h"
 #include "ui/gfx/geometry/rect_conversions.h"
 
@@ -174,6 +186,564 @@ void RasterSource::AsValueInto(base::trace_event::TracedValue* array) const {
                                   array);
 }
 
+namespace {
+
+// Forward declaration for recursive serialization
+void SerializePaintOpRecursive(const PaintOp& op,
+                               base::trace_event::TracedValue* state);
+
+void SerializeTextBlob(const SkTextBlob* blob,
+                       base::trace_event::TracedValue* state) {
+  if (!blob) {
+    return;
+  }
+
+  // Serialize bounds
+  const SkRect& bounds = blob->bounds();
+  state->BeginArray("bounds");
+  state->AppendDouble(bounds.left());
+  state->AppendDouble(bounds.top());
+  state->AppendDouble(bounds.right());
+  state->AppendDouble(bounds.bottom());
+  state->EndArray();
+
+  // Serialize runs with glyph IDs and positions using SkTextBlobRunIterator
+  // which gives us access to the positioning type (horizontal, full, rsxform)
+  state->BeginArray("runs");
+  for (SkTextBlobRunIterator iter(blob); !iter.done(); iter.next()) {
+    state->BeginDictionary();
+    const uint32_t count = iter.glyphCount();
+    state->SetInteger("glyphCount", count);
+
+    // Serialize glyph IDs
+    state->BeginArray("glyphs");
+    const SkGlyphID* glyphs = iter.glyphs();
+    for (uint32_t i = 0; i < count; ++i) {
+      state->AppendInteger(UNSAFE_BUFFERS(glyphs[i]));
+    }
+    state->EndArray();
+
+    // Serialize positioning type and data
+    auto positioning = iter.positioning();
+    state->SetInteger("positioning", static_cast<int>(positioning));
+
+    if (positioning == SkTextBlobRunIterator::kRSXform_Positioning) {
+      // RSXform: [scos, ssin, tx, ty] per glyph - complete transform info
+      state->BeginArray("rsxforms");
+      const SkRSXform* xforms = iter.xforms();
+      for (uint32_t i = 0; i < count; ++i) {
+        state->BeginDictionary();
+        state->SetDouble("scos", UNSAFE_BUFFERS(xforms[i].fSCos));
+        state->SetDouble("ssin", UNSAFE_BUFFERS(xforms[i].fSSin));
+        state->SetDouble("tx", UNSAFE_BUFFERS(xforms[i].fTx));
+        state->SetDouble("ty", UNSAFE_BUFFERS(xforms[i].fTy));
+        state->EndDictionary();
+      }
+      state->EndArray();
+    } else if (positioning == SkTextBlobRunIterator::kFull_Positioning) {
+      // Full positioning: x,y pairs
+      state->BeginArray("positions");
+      const SkPoint* points = iter.points();
+      for (uint32_t i = 0; i < count; ++i) {
+        state->BeginDictionary();
+        state->SetDouble("x", UNSAFE_BUFFERS(points[i].x()));
+        state->SetDouble("y", UNSAFE_BUFFERS(points[i].y()));
+        state->EndDictionary();
+      }
+      state->EndArray();
+    } else if (positioning == SkTextBlobRunIterator::kHorizontal_Positioning) {
+      // Horizontal: x positions only
+      state->BeginArray("positions");
+      const SkScalar* pos = iter.pos();
+      for (uint32_t i = 0; i < count; ++i) {
+        state->AppendDouble(UNSAFE_BUFFERS(pos[i]));
+      }
+      state->EndArray();
+    }
+    // kDefault_Positioning has no position data (uses font advances)
+
+    // Serialize run offset
+    const SkPoint& offset = iter.offset();
+    state->SetDouble("offsetX", offset.x());
+    state->SetDouble("offsetY", offset.y());
+
+    // Serialize font info
+    const SkFont& font = iter.font();
+    state->SetDouble("fontSize", font.getSize());
+    if (font.getTypeface()) {
+      SkString family_name;
+      font.getTypeface()->getFamilyName(&family_name);
+      state->SetString("fontFamily",
+                       std::string(family_name.c_str(), family_name.size()));
+      state->SetInteger("fontWeight",
+                        font.getTypeface()->fontStyle().weight());
+    }
+
+    state->EndDictionary();
+  }
+  state->EndArray();
+}
+
+void SerializePaintOpRecursive(const PaintOp& op,
+                               base::trace_event::TracedValue* state) {
+  state->SetString("type", PaintOpTypeToString(op.GetType()));
+
+  switch (op.GetType()) {
+    case PaintOpType::kClipRect: {
+      const auto& clip_op = static_cast<const ClipRectOp&>(op);
+      state->BeginArray("rect");
+      state->AppendDouble(clip_op.rect.left());
+      state->AppendDouble(clip_op.rect.top());
+      state->AppendDouble(clip_op.rect.right());
+      state->AppendDouble(clip_op.rect.bottom());
+      state->EndArray();
+      state->SetBoolean("antiAlias", clip_op.antialias);
+      break;
+    }
+    case PaintOpType::kClipRRect: {
+      const auto& clip_op = static_cast<const ClipRRectOp&>(op);
+      state->BeginArray("rect");
+      state->AppendDouble(clip_op.rrect.rect().left());
+      state->AppendDouble(clip_op.rrect.rect().top());
+      state->AppendDouble(clip_op.rrect.rect().right());
+      state->AppendDouble(clip_op.rrect.rect().bottom());
+      state->EndArray();
+      state->BeginArray("radii");
+      state->AppendDouble(clip_op.rrect.radii(SkRRect::kUpperLeft_Corner).x());
+      state->AppendDouble(clip_op.rrect.radii(SkRRect::kUpperLeft_Corner).y());
+      state->AppendDouble(clip_op.rrect.radii(SkRRect::kUpperRight_Corner).x());
+      state->AppendDouble(clip_op.rrect.radii(SkRRect::kUpperRight_Corner).y());
+      state->AppendDouble(clip_op.rrect.radii(SkRRect::kLowerRight_Corner).x());
+      state->AppendDouble(clip_op.rrect.radii(SkRRect::kLowerRight_Corner).y());
+      state->AppendDouble(clip_op.rrect.radii(SkRRect::kLowerLeft_Corner).x());
+      state->AppendDouble(clip_op.rrect.radii(SkRRect::kLowerLeft_Corner).y());
+      state->EndArray();
+      state->SetBoolean("antiAlias", clip_op.antialias);
+      break;
+    }
+    case PaintOpType::kClipPath: {
+      const auto& clip_op = static_cast<const ClipPathOp&>(op);
+      state->SetBoolean("antiAlias", clip_op.antialias);
+      // Serialize path as SVG path string
+      SkString path_str = SkParsePath::ToSVGString(clip_op.path);
+      state->SetString("path", std::string(path_str.c_str(), path_str.size()));
+      // Also serialize path bounds
+      const SkRect& bounds = clip_op.path.getBounds();
+      state->BeginArray("bounds");
+      state->AppendDouble(bounds.left());
+      state->AppendDouble(bounds.top());
+      state->AppendDouble(bounds.right());
+      state->AppendDouble(bounds.bottom());
+      state->EndArray();
+      break;
+    }
+    case PaintOpType::kDrawRect: {
+      const auto& draw_op = static_cast<const DrawRectOp&>(op);
+      state->BeginArray("rect");
+      state->AppendDouble(draw_op.rect.left());
+      state->AppendDouble(draw_op.rect.top());
+      state->AppendDouble(draw_op.rect.right());
+      state->AppendDouble(draw_op.rect.bottom());
+      state->EndArray();
+      state->BeginDictionary("flags");
+      const SkColor4f& color = draw_op.flags.getColor4f();
+      state->SetDouble("r", color.fR);
+      state->SetDouble("g", color.fG);
+      state->SetDouble("b", color.fB);
+      state->SetDouble("a", color.fA);
+      // Check for shader (gradient)
+      if (draw_op.flags.HasShader()) {
+        const PaintShader* shader = draw_op.flags.getShader();
+        if (shader) {
+          PaintShader::Type type = shader->shader_type();
+          if (type == PaintShader::Type::kLinearGradient) {
+            state->SetString("shaderType", "kLinearGradient");
+            // Serialize linear gradient start/end points
+            state->BeginArray("startPoint");
+            state->AppendDouble(shader->start_point().x());
+            state->AppendDouble(shader->start_point().y());
+            state->EndArray();
+            state->BeginArray("endPoint");
+            state->AppendDouble(shader->end_point().x());
+            state->AppendDouble(shader->end_point().y());
+            state->EndArray();
+          } else if (type == PaintShader::Type::kRadialGradient) {
+            state->SetString("shaderType", "kRadialGradient");
+            state->BeginArray("center");
+            state->AppendDouble(shader->center().x());
+            state->AppendDouble(shader->center().y());
+            state->EndArray();
+            state->SetDouble("radius", shader->end_radius());
+          } else if (type == PaintShader::Type::kTwoPointConicalGradient) {
+            state->SetString("shaderType", "kTwoPointConicalGradient");
+          } else if (type == PaintShader::Type::kSweepGradient) {
+            state->SetString("shaderType", "kSweepGradient");
+          } else {
+            state->SetString("shaderType", "other");
+          }
+          // Serialize gradient colors and positions
+          const auto& colors = shader->colors();
+          const auto& positions = shader->positions();
+          if (!colors.empty()) {
+            state->BeginArray("gradientColors");
+            for (const auto& c : colors) {
+              state->BeginDictionary();
+              state->SetDouble("r", c.fR);
+              state->SetDouble("g", c.fG);
+              state->SetDouble("b", c.fB);
+              state->SetDouble("a", c.fA);
+              state->EndDictionary();
+            }
+            state->EndArray();
+            state->BeginArray("gradientPositions");
+            for (const auto& pos : positions) {
+              state->AppendDouble(pos);
+            }
+            state->EndArray();
+          }
+          state->SetBoolean("hasShader", true);
+        }
+      }
+      state->EndDictionary();
+      break;
+    }
+    case PaintOpType::kDrawRRect: {
+      const auto& draw_op = static_cast<const DrawRRectOp&>(op);
+      state->BeginArray("rect");
+      state->AppendDouble(draw_op.rrect.rect().left());
+      state->AppendDouble(draw_op.rrect.rect().top());
+      state->AppendDouble(draw_op.rrect.rect().right());
+      state->AppendDouble(draw_op.rrect.rect().bottom());
+      state->EndArray();
+      // Serialize corner radii [tlX, tlY, trX, trY, brX, brY, blX, blY]
+      state->BeginArray("radii");
+      state->AppendDouble(draw_op.rrect.radii(SkRRect::kUpperLeft_Corner).x());
+      state->AppendDouble(draw_op.rrect.radii(SkRRect::kUpperLeft_Corner).y());
+      state->AppendDouble(draw_op.rrect.radii(SkRRect::kUpperRight_Corner).x());
+      state->AppendDouble(draw_op.rrect.radii(SkRRect::kUpperRight_Corner).y());
+      state->AppendDouble(draw_op.rrect.radii(SkRRect::kLowerRight_Corner).x());
+      state->AppendDouble(draw_op.rrect.radii(SkRRect::kLowerRight_Corner).y());
+      state->AppendDouble(draw_op.rrect.radii(SkRRect::kLowerLeft_Corner).x());
+      state->AppendDouble(draw_op.rrect.radii(SkRRect::kLowerLeft_Corner).y());
+      state->EndArray();
+      // Serialize paint flags (color, style, stroke width)
+      state->BeginDictionary("flags");
+      const SkColor4f& color = draw_op.flags.getColor4f();
+      state->SetDouble("r", color.fR);
+      state->SetDouble("g", color.fG);
+      state->SetDouble("b", color.fB);
+      state->SetDouble("a", color.fA);
+      // Style: 0 = Fill, 1 = Stroke, 2 = StrokeAndFill
+      state->SetInteger("style", static_cast<int>(draw_op.flags.getStyle()));
+      state->SetDouble("strokeWidth", draw_op.flags.getStrokeWidth());
+      // Check for shader (gradient)
+      if (draw_op.flags.HasShader()) {
+        const PaintShader* shader = draw_op.flags.getShader();
+        if (shader) {
+          PaintShader::Type type = shader->shader_type();
+          if (type == PaintShader::Type::kLinearGradient) {
+            state->SetString("shaderType", "kLinearGradient");
+            // Serialize linear gradient start/end points
+            state->BeginArray("startPoint");
+            state->AppendDouble(shader->start_point().x());
+            state->AppendDouble(shader->start_point().y());
+            state->EndArray();
+            state->BeginArray("endPoint");
+            state->AppendDouble(shader->end_point().x());
+            state->AppendDouble(shader->end_point().y());
+            state->EndArray();
+          } else if (type == PaintShader::Type::kRadialGradient) {
+            state->SetString("shaderType", "kRadialGradient");
+            state->BeginArray("center");
+            state->AppendDouble(shader->center().x());
+            state->AppendDouble(shader->center().y());
+            state->EndArray();
+            state->SetDouble("radius", shader->end_radius());
+          } else if (type == PaintShader::Type::kTwoPointConicalGradient) {
+            state->SetString("shaderType", "kTwoPointConicalGradient");
+          } else if (type == PaintShader::Type::kSweepGradient) {
+            state->SetString("shaderType", "kSweepGradient");
+          } else {
+            state->SetString("shaderType", "other");
+          }
+          // Serialize gradient colors and positions
+          const auto& colors = shader->colors();
+          const auto& positions = shader->positions();
+          if (!colors.empty()) {
+            state->BeginArray("gradientColors");
+            for (const auto& c : colors) {
+              state->BeginDictionary();
+              state->SetDouble("r", c.fR);
+              state->SetDouble("g", c.fG);
+              state->SetDouble("b", c.fB);
+              state->SetDouble("a", c.fA);
+              state->EndDictionary();
+            }
+            state->EndArray();
+            state->BeginArray("gradientPositions");
+            for (const auto& pos : positions) {
+              state->AppendDouble(pos);
+            }
+            state->EndArray();
+          }
+          state->SetBoolean("hasShader", true);
+        }
+      }
+      state->EndDictionary();
+      break;
+    }
+    case PaintOpType::kDrawColor: {
+      const auto& draw_op = static_cast<const DrawColorOp&>(op);
+      state->SetDouble("r", draw_op.color.fR);
+      state->SetDouble("g", draw_op.color.fG);
+      state->SetDouble("b", draw_op.color.fB);
+      state->SetDouble("a", draw_op.color.fA);
+      break;
+    }
+    case PaintOpType::kDrawLine: {
+      const auto& draw_op = static_cast<const DrawLineOp&>(op);
+      state->SetDouble("x0", draw_op.x0);
+      state->SetDouble("y0", draw_op.y0);
+      state->SetDouble("x1", draw_op.x1);
+      state->SetDouble("y1", draw_op.y1);
+      break;
+    }
+    case PaintOpType::kDrawOval: {
+      const auto& draw_op = static_cast<const DrawOvalOp&>(op);
+      state->BeginArray("oval");
+      state->AppendDouble(draw_op.oval.left());
+      state->AppendDouble(draw_op.oval.top());
+      state->AppendDouble(draw_op.oval.right());
+      state->AppendDouble(draw_op.oval.bottom());
+      state->EndArray();
+      break;
+    }
+    case PaintOpType::kDrawPath: {
+      const auto& draw_op = static_cast<const DrawPathOp&>(op);
+      // Serialize path as SVG path string
+      SkString path_str = SkParsePath::ToSVGString(draw_op.path);
+      state->SetString("path", std::string(path_str.c_str(), path_str.size()));
+      // Serialize path fill type
+      state->SetInteger("fillType", static_cast<int>(draw_op.sk_path_fill_type));
+      // Serialize path bounds
+      const SkRect& bounds = draw_op.path.getBounds();
+      state->BeginArray("bounds");
+      state->AppendDouble(bounds.left());
+      state->AppendDouble(bounds.top());
+      state->AppendDouble(bounds.right());
+      state->AppendDouble(bounds.bottom());
+      state->EndArray();
+      // Serialize paint flags
+      state->BeginDictionary("flags");
+      const SkColor4f& color = draw_op.flags.getColor4f();
+      state->SetDouble("r", color.fR);
+      state->SetDouble("g", color.fG);
+      state->SetDouble("b", color.fB);
+      state->SetDouble("a", color.fA);
+      // Style: 0 = Fill, 1 = Stroke, 2 = StrokeAndFill
+      state->SetInteger("style", static_cast<int>(draw_op.flags.getStyle()));
+      state->SetDouble("strokeWidth", draw_op.flags.getStrokeWidth());
+      state->EndDictionary();
+      break;
+    }
+    case PaintOpType::kDrawTextBlob: {
+      const auto& draw_op = static_cast<const DrawTextBlobOp&>(op);
+      state->SetDouble("x", draw_op.x);
+      state->SetDouble("y", draw_op.y);
+      state->SetInteger("nodeId", draw_op.node_id);
+      // Serialize paint flags (color)
+      state->BeginDictionary("flags");
+      const SkColor4f& color = draw_op.flags.getColor4f();
+      state->SetDouble("r", color.fR);
+      state->SetDouble("g", color.fG);
+      state->SetDouble("b", color.fB);
+      state->SetDouble("a", color.fA);
+      state->EndDictionary();
+      // Serialize glyph data from the text blob
+      if (draw_op.blob) {
+        SerializeTextBlob(draw_op.blob.get(), state);
+      }
+      break;
+    }
+    case PaintOpType::kDrawRecord: {
+      const auto& draw_op = static_cast<const DrawRecordOp&>(op);
+      // Recursively serialize the nested record
+      state->BeginArray("record");
+      for (const PaintOp& nested_op : draw_op.record.buffer()) {
+        state->BeginDictionary();
+        SerializePaintOpRecursive(nested_op, state);
+        state->EndDictionary();
+      }
+      state->EndArray();
+      break;
+    }
+    case PaintOpType::kTranslate: {
+      const auto& translate_op = static_cast<const TranslateOp&>(op);
+      state->SetDouble("dx", translate_op.dx);
+      state->SetDouble("dy", translate_op.dy);
+      break;
+    }
+    case PaintOpType::kScale: {
+      const auto& scale_op = static_cast<const ScaleOp&>(op);
+      state->SetDouble("sx", scale_op.sx);
+      state->SetDouble("sy", scale_op.sy);
+      break;
+    }
+    case PaintOpType::kRotate: {
+      const auto& rotate_op = static_cast<const RotateOp&>(op);
+      state->SetDouble("degrees", rotate_op.degrees);
+      break;
+    }
+    case PaintOpType::kConcat: {
+      const auto& concat_op = static_cast<const ConcatOp&>(op);
+      state->BeginArray("matrix");
+      for (int row = 0; row < 4; ++row) {
+        for (int col = 0; col < 4; ++col) {
+          state->AppendDouble(concat_op.matrix.rc(row, col));
+        }
+      }
+      state->EndArray();
+      break;
+    }
+    case PaintOpType::kSetMatrix: {
+      const auto& matrix_op = static_cast<const SetMatrixOp&>(op);
+      state->BeginArray("matrix");
+      for (int row = 0; row < 4; ++row) {
+        for (int col = 0; col < 4; ++col) {
+          state->AppendDouble(matrix_op.matrix.rc(row, col));
+        }
+      }
+      state->EndArray();
+      break;
+    }
+    case PaintOpType::kSave:
+    case PaintOpType::kRestore:
+    case PaintOpType::kNoop:
+      // No additional data
+      break;
+    case PaintOpType::kSaveLayerAlpha: {
+      const auto& save_op = static_cast<const SaveLayerAlphaOp&>(op);
+      state->BeginArray("bounds");
+      state->AppendDouble(save_op.bounds.left());
+      state->AppendDouble(save_op.bounds.top());
+      state->AppendDouble(save_op.bounds.right());
+      state->AppendDouble(save_op.bounds.bottom());
+      state->EndArray();
+      state->SetDouble("alpha", save_op.alpha);
+      break;
+    }
+    case PaintOpType::kSaveLayer: {
+      const auto& save_op = static_cast<const SaveLayerOp&>(op);
+      // Serialize bounds
+      state->BeginArray("bounds");
+      state->AppendDouble(save_op.bounds.left());
+      state->AppendDouble(save_op.bounds.top());
+      state->AppendDouble(save_op.bounds.right());
+      state->AppendDouble(save_op.bounds.bottom());
+      state->EndArray();
+      // Serialize flags including image filter (for shadows/blur)
+      state->BeginDictionary("flags");
+      const SkColor4f& color = save_op.flags.getColor4f();
+      state->SetDouble("r", color.fR);
+      state->SetDouble("g", color.fG);
+      state->SetDouble("b", color.fB);
+      state->SetDouble("a", color.fA);
+      // Check for image filter (used for blur, drop shadow, etc.)
+      const auto& image_filter = save_op.flags.getImageFilter();
+      if (image_filter) {
+        state->BeginDictionary("imageFilter");
+        PaintFilter::Type filter_type = image_filter->type();
+        state->SetInteger("filterType", static_cast<int>(filter_type));
+        if (filter_type == PaintFilter::Type::kBlur) {
+          const auto* blur = static_cast<const BlurPaintFilter*>(image_filter.get());
+          state->SetString("filterName", "blur");
+          state->SetDouble("sigmaX", blur->sigma_x());
+          state->SetDouble("sigmaY", blur->sigma_y());
+        } else if (filter_type == PaintFilter::Type::kDropShadow) {
+          const auto* shadow = static_cast<const DropShadowPaintFilter*>(image_filter.get());
+          state->SetString("filterName", "dropShadow");
+          state->SetDouble("dx", shadow->dx());
+          state->SetDouble("dy", shadow->dy());
+          state->SetDouble("sigmaX", shadow->sigma_x());
+          state->SetDouble("sigmaY", shadow->sigma_y());
+          const SkColor4f& shadow_color = shadow->color();
+          state->BeginDictionary("shadowColor");
+          state->SetDouble("r", shadow_color.fR);
+          state->SetDouble("g", shadow_color.fG);
+          state->SetDouble("b", shadow_color.fB);
+          state->SetDouble("a", shadow_color.fA);
+          state->EndDictionary();
+          state->SetInteger("shadowMode", static_cast<int>(shadow->shadow_mode()));
+        } else {
+          state->SetString("filterName", "other");
+        }
+        state->EndDictionary();
+      }
+      state->EndDictionary();
+      break;
+    }
+    case PaintOpType::kDrawImageRect: {
+      const auto& draw_op = static_cast<const DrawImageRectOp&>(op);
+      state->BeginArray("src");
+      state->AppendDouble(draw_op.src.left());
+      state->AppendDouble(draw_op.src.top());
+      state->AppendDouble(draw_op.src.right());
+      state->AppendDouble(draw_op.src.bottom());
+      state->EndArray();
+      state->BeginArray("dst");
+      state->AppendDouble(draw_op.dst.left());
+      state->AppendDouble(draw_op.dst.top());
+      state->AppendDouble(draw_op.dst.right());
+      state->AppendDouble(draw_op.dst.bottom());
+      state->EndArray();
+      if (draw_op.image) {
+        state->SetInteger("imageWidth", draw_op.image.width());
+        state->SetInteger("imageHeight", draw_op.image.height());
+      }
+      break;
+    }
+    default:
+      // For other ops, just output type (already done above)
+      break;
+  }
+}
+
+}  // namespace
+
+void RasterSource::AsValueIntoWithPaintOps(
+    base::trace_event::TracedValue* state) const {
+  if (!display_list_.get()) {
+    return;
+  }
+
+  state->BeginDictionary();
+  viz::TracedValue::SetIDRef(viz::TracedValue::Id(display_list_.get()), state,
+                             "id");
+
+  // Include bounds
+  state->BeginArray("recorded_bounds");
+  state->AppendInteger(recorded_bounds_.x());
+  state->AppendInteger(recorded_bounds_.y());
+  state->AppendInteger(recorded_bounds_.width());
+  state->AppendInteger(recorded_bounds_.height());
+  state->EndArray();
+
+  // Serialize paint ops using the recursive helper
+  const PaintOpBuffer& buffer = display_list_->paint_op_buffer();
+  state->SetInteger("op_count", static_cast<int>(buffer.size()));
+  state->SetInteger("total_op_count", static_cast<int>(buffer.total_op_count()));
+
+  state->BeginArray("paint_ops");
+  for (const PaintOp& op : buffer) {
+    state->BeginDictionary();
+    SerializePaintOpRecursive(op, state);
+    state->EndDictionary();
+  }
+  state->EndArray();
+
+  state->EndDictionary();
+}
+
 void RasterSource::DidBeginTracing() {
   if (display_list_.get())
     display_list_->EmitTraceSnapshot();
diff --git a/cc/raster/raster_source.h b/cc/raster/raster_source.h
index c932d003d0..4a6a505d72 100644
--- a/cc/raster/raster_source.h
+++ b/cc/raster/raster_source.h
@@ -125,6 +125,8 @@ class CC_EXPORT RasterSource : public base::RefCountedThreadSafe<RasterSource> {
   // Tracing functionality.
   void DidBeginTracing();
   void AsValueInto(base::trace_event::TracedValue* array) const;
+  // Serialize with full paint op details for debugging.
+  void AsValueIntoWithPaintOps(base::trace_event::TracedValue* state) const;
 
   const scoped_refptr<const DisplayItemList>& GetDisplayItemList() const {
     return display_list_;
diff --git a/chrome/app/chrome_main_delegate.cc b/chrome/app/chrome_main_delegate.cc
index 1cbcce0303..c0b1154ab8 100644
--- a/chrome/app/chrome_main_delegate.cc
+++ b/chrome/app/chrome_main_delegate.cc
@@ -10,6 +10,7 @@
 #include <variant>
 
 #include "base/base_paths.h"
+#include "base/base_switches.h"
 #include "base/check.h"
 #include "base/command_line.h"
 #include "base/compiler_specific.h"
@@ -75,12 +76,14 @@
 #include "components/memory_system/initializer.h"
 #include "components/memory_system/parameters.h"
 #include "components/metrics/persistent_histograms.h"
+#include "components/os_crypt/common/os_crypt_switches.h"
 #include "components/sampling_profiler/thread_profiler.h"
 #include "components/startup_metric_utils/common/startup_metric_utils.h"
 #include "components/variations/service/variations_network_clock.h"
 #include "components/variations/variations_ids_provider.h"
 #include "components/version_info/channel.h"
 #include "components/version_info/version_info.h"
+#include "components/viz/common/switches.h"
 #include "content/public/app/initialize_mojo_core.h"
 #include "content/public/common/content_client.h"
 #include "content/public/common/content_constants.h"
@@ -1063,6 +1066,36 @@ std::optional<int> ChromeMainDelegate::BasicStartupComplete() {
   ash::BootTimesRecorder::Get()->SaveChromeMainStats();
 #endif
 
+  // Append default flags so users don't need to pass them on the CLI.
+  base::CommandLine* cmd = base::CommandLine::ForCurrentProcess();
+
+  if (!cmd->HasSwitch(switches::kRunAllCompositorStagesBeforeDraw))
+    cmd->AppendSwitch(switches::kRunAllCompositorStagesBeforeDraw);
+
+  if (!cmd->HasSwitch(switches::kEnableLogging))
+    cmd->AppendSwitch(switches::kEnableLogging);
+
+  if (!cmd->HasSwitch(switches::kV))
+    cmd->AppendSwitchASCII(switches::kV, "0");
+
+  // Enable verbose logging for layer tree and property trees on every commit
+  if (!cmd->HasSwitch(switches::kVModule))
+    cmd->AppendSwitchASCII(switches::kVModule, "layer_tree_host_impl=3");
+
+#if BUILDFLAG(IS_MAC)
+  if (!cmd->HasSwitch(os_crypt::switches::kUseMockKeychain))
+    cmd->AppendSwitch(os_crypt::switches::kUseMockKeychain);
+#endif
+
+  std::string disable_features =
+      cmd->GetSwitchValueASCII(switches::kDisableFeatures);
+  if (disable_features.find("DialMediaRouteProvider") == std::string::npos) {
+    if (!disable_features.empty())
+      disable_features += ",";
+    disable_features += "DialMediaRouteProvider";
+    cmd->AppendSwitchASCII(switches::kDisableFeatures, disable_features);
+  }
+
   const base::CommandLine& command_line =
       *base::CommandLine::ForCurrentProcess();
 
diff --git a/third_party/blink/renderer/core/dom/node.cc b/third_party/blink/renderer/core/dom/node.cc
index c580313c33..5426191d2c 100644
--- a/third_party/blink/renderer/core/dom/node.cc
+++ b/third_party/blink/renderer/core/dom/node.cc
@@ -2685,12 +2685,12 @@ String Node::ToString() const {
   return builder.ReleaseString();
 }
 
-#if DCHECK_IS_ON()
-
 String Node::ToTreeStringForThis() const {
   return ToMarkedTreeString(this, "*");
 }
 
+#if DCHECK_IS_ON()
+
 String Node::ToFlatTreeStringForThis() const {
   return ToMarkedFlatTreeString(this, "*");
 }
@@ -2746,6 +2746,8 @@ void Node::PrintNodePathTo(std::ostream& stream) const {
   }
 }
 
+#endif
+
 static void AppendMarkedTree(const String& base_indent,
                              const Node* root_node,
                              const Node* marked_node1,
@@ -2829,6 +2831,8 @@ static void AppendMarkedTree(const String& base_indent,
   }
 }
 
+#if DCHECK_IS_ON()
+
 static void AppendMarkedFlatTree(const String& base_indent,
                                  const Node* root_node,
                                  const Node* marked_node1,
@@ -2855,6 +2859,8 @@ static void AppendMarkedFlatTree(const String& base_indent,
   }
 }
 
+#endif
+
 String Node::ToMarkedTreeString(const Node* marked_node1,
                                 const char* marked_label1,
                                 const Node* marked_node2,
@@ -2872,6 +2878,8 @@ String Node::ToMarkedTreeString(const Node* marked_node1,
   return builder.ReleaseString();
 }
 
+#if DCHECK_IS_ON()
+
 String Node::ToMarkedFlatTreeString(const Node* marked_node1,
                                     const char* marked_label1,
                                     const Node* marked_node2,
@@ -3768,6 +3776,13 @@ void Node::Trace(Visitor* visitor) const {
 
 }  // namespace blink
 
+void ShowTree(const blink::Node* node) {
+  if (node)
+    LOG(INFO) << "\n" << node->ToTreeStringForThis().Utf8();
+  else
+    LOG(INFO) << "Cannot showTree for <null>";
+}
+
 #if DCHECK_IS_ON()
 
 void ShowNode(const blink::Node* node) {
@@ -3777,13 +3792,6 @@ void ShowNode(const blink::Node* node) {
     LOG(INFO) << "Cannot showNode for <null>";
 }
 
-void ShowTree(const blink::Node* node) {
-  if (node)
-    LOG(INFO) << "\n" << node->ToTreeStringForThis().Utf8();
-  else
-    LOG(INFO) << "Cannot showTree for <null>";
-}
-
 void ShowNodePath(const blink::Node* node) {
   if (node) {
     std::stringstream stream;
diff --git a/third_party/blink/renderer/core/dom/node.h b/third_party/blink/renderer/core/dom/node.h
index c637e01b20..012dc58331 100644
--- a/third_party/blink/renderer/core/dom/node.h
+++ b/third_party/blink/renderer/core/dom/node.h
@@ -900,14 +900,14 @@ class CORE_EXPORT Node : public EventTarget {
 
   String ToString() const;
 
-#if DCHECK_IS_ON()
   String ToTreeStringForThis() const;
-  String ToFlatTreeStringForThis() const;
-  void PrintNodePathTo(std::ostream&) const;
   String ToMarkedTreeString(const Node* marked_node1,
                             const char* marked_label1,
                             const Node* marked_node2 = nullptr,
                             const char* marked_label2 = nullptr) const;
+#if DCHECK_IS_ON()
+  String ToFlatTreeStringForThis() const;
+  void PrintNodePathTo(std::ostream&) const;
   String ToMarkedFlatTreeString(const Node* marked_node1,
                                 const char* marked_label1,
                                 const Node* marked_node2 = nullptr,
@@ -1398,10 +1398,11 @@ CORE_EXPORT std::ostream& operator<<(std::ostream&, const Node*);
 
 }  // namespace blink
 
+void ShowTree(const blink::Node*);
+
 #if DCHECK_IS_ON()
 // Outside the blink namespace for ease of invocation from gdb.
 void ShowNode(const blink::Node*);
-void ShowTree(const blink::Node*);
 void ShowNodePath(const blink::Node*);
 #endif
 
diff --git a/third_party/blink/renderer/core/paint/pre_paint_tree_walk.cc b/third_party/blink/renderer/core/paint/pre_paint_tree_walk.cc
index c2589ef87b..8c137b87fe 100644
--- a/third_party/blink/renderer/core/paint/pre_paint_tree_walk.cc
+++ b/third_party/blink/renderer/core/paint/pre_paint_tree_walk.cc
@@ -4,9 +4,14 @@
 
 #include "third_party/blink/renderer/core/paint/pre_paint_tree_walk.h"
 
+#include "base/command_line.h"
 #include "base/debug/dump_without_crashing.h"
+#include "base/logging.h"
+#include "base/time/time.h"
 #include "base/types/optional_util.h"
+#include "third_party/blink/renderer/core/dom/document.h"
 #include "third_party/blink/renderer/core/dom/document_lifecycle.h"
+#include "third_party/blink/renderer/core/dom/node.h"
 #include "third_party/blink/renderer/core/editing/frame_selection.h"
 #include "third_party/blink/renderer/core/frame/event_handler_registry.h"
 #include "third_party/blink/renderer/core/frame/local_dom_window.h"
@@ -69,8 +74,23 @@ void PrePaintTreeWalk::WalkTree(LocalFrameView& root_frame_view) {
     return;
   }
 
-  DCHECK_EQ(root_frame_view.GetFrame().GetDocument()->Lifecycle().GetState(),
-            DocumentLifecycle::kInPrePaint);
+  Document* document = root_frame_view.GetFrame().GetDocument();
+  if (!document) {
+    return;
+  }
+
+  DCHECK_EQ(document->Lifecycle().GetState(), DocumentLifecycle::kInPrePaint);
+
+  if (base::CommandLine::ForCurrentProcess()->GetSwitchValueASCII("type") ==
+          "renderer" &&
+      document->IsInMainFrame()) {
+    const int64_t timestamp_ms =
+        base::TimeTicks::Now().since_origin().InMilliseconds();
+    LOG(INFO) << "PrePaint URL: " << document->Url().GetString().Utf8()
+              << " State: " << document->Lifecycle().GetState()
+              << " timestamp (ms): " << timestamp_ms;
+    ShowTree(document);
+  }
 
   PrePaintTreeWalkContext context;
 
diff --git a/third_party/blink/renderer/platform/BUILD.gn b/third_party/blink/renderer/platform/BUILD.gn
index e2256766d7..351700eb0b 100644
--- a/third_party/blink/renderer/platform/BUILD.gn
+++ b/third_party/blink/renderer/platform/BUILD.gn
@@ -920,6 +920,8 @@ component("platform") {
     "graphics/compositing/layers_as_json.h",
     "graphics/compositing/paint_artifact_compositor.cc",
     "graphics/compositing/paint_artifact_compositor.h",
+    "graphics/compositing/paint_artifact_json_serializer.cc",
+    "graphics/compositing/paint_artifact_json_serializer.h",
     "graphics/compositing/paint_chunks_to_cc_layer.cc",
     "graphics/compositing/paint_chunks_to_cc_layer.h",
     "graphics/compositing/pending_layer.cc",
diff --git a/third_party/blink/renderer/platform/fonts/shaping/text_blob_serializer.cc b/third_party/blink/renderer/platform/fonts/shaping/text_blob_serializer.cc
new file mode 100644
index 0000000000..36cbff9230
--- /dev/null
+++ b/third_party/blink/renderer/platform/fonts/shaping/text_blob_serializer.cc
@@ -0,0 +1,128 @@
+// Copyright 2024 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "third_party/blink/renderer/platform/fonts/shaping/text_blob_serializer.h"
+
+#include "base/logging.h"
+#include "base/values.h"
+#include "base/json/json_writer.h"
+#include "third_party/skia/include/core/SkFont.h"
+#include "third_party/skia/include/core/SkRSXform.h"
+#include "third_party/skia/src/core/SkTextBlobPriv.h"
+
+namespace blink {
+
+void SerializeTextBlobToLog(const SkTextBlob* blob,
+                            const gfx::PointF& point,
+                            const cc::PaintFlags& flags,
+                            cc::NodeId node_id) {
+  if (!blob) {
+    return;
+  }
+
+  base::Value::Dict root;
+  root.Set("type", "DrawTextBlobOp");
+  root.Set("x", static_cast<double>(point.x()));
+  root.Set("y", static_cast<double>(point.y()));
+  root.Set("nodeId", static_cast<int>(node_id));
+
+  // Serialize paint flags (color)
+  base::Value::Dict flags_dict;
+  const SkColor4f& color = flags.getColor4f();
+  flags_dict.Set("r", static_cast<double>(color.fR));
+  flags_dict.Set("g", static_cast<double>(color.fG));
+  flags_dict.Set("b", static_cast<double>(color.fB));
+  flags_dict.Set("a", static_cast<double>(color.fA));
+  root.Set("flags", std::move(flags_dict));
+
+  // Serialize bounds
+  const SkRect& bounds = blob->bounds();
+  base::Value::List bounds_list;
+  bounds_list.Append(static_cast<double>(bounds.left()));
+  bounds_list.Append(static_cast<double>(bounds.top()));
+  bounds_list.Append(static_cast<double>(bounds.right()));
+  bounds_list.Append(static_cast<double>(bounds.bottom()));
+  root.Set("bounds", std::move(bounds_list));
+
+  // Serialize runs using SkTextBlobRunIterator
+  base::Value::List runs_list;
+  for (SkTextBlobRunIterator iter(blob); !iter.done(); iter.next()) {
+    base::Value::Dict run_dict;
+    const uint32_t count = iter.glyphCount();
+    run_dict.Set("glyphCount", static_cast<int>(count));
+
+    // Serialize glyph IDs
+    base::Value::List glyphs_list;
+    const SkGlyphID* glyphs = iter.glyphs();
+    for (uint32_t i = 0; i < count; ++i) {
+      glyphs_list.Append(static_cast<int>(glyphs[i]));
+    }
+    run_dict.Set("glyphs", std::move(glyphs_list));
+
+    // Serialize positioning type and data
+    auto positioning = iter.positioning();
+    run_dict.Set("positioning", static_cast<int>(positioning));
+
+    if (positioning == SkTextBlobRunIterator::kRSXform_Positioning) {
+      // RSXform: [scos, ssin, tx, ty] per glyph
+      base::Value::List rsxforms_list;
+      const SkRSXform* xforms = iter.xforms();
+      for (uint32_t i = 0; i < count; ++i) {
+        base::Value::Dict xform_dict;
+        xform_dict.Set("scos", static_cast<double>(xforms[i].fSCos));
+        xform_dict.Set("ssin", static_cast<double>(xforms[i].fSSin));
+        xform_dict.Set("tx", static_cast<double>(xforms[i].fTx));
+        xform_dict.Set("ty", static_cast<double>(xforms[i].fTy));
+        rsxforms_list.Append(std::move(xform_dict));
+      }
+      run_dict.Set("rsxforms", std::move(rsxforms_list));
+    } else if (positioning == SkTextBlobRunIterator::kFull_Positioning) {
+      // Full positioning: x,y pairs
+      base::Value::List positions_list;
+      const SkPoint* points = iter.points();
+      for (uint32_t i = 0; i < count; ++i) {
+        base::Value::Dict pos_dict;
+        pos_dict.Set("x", static_cast<double>(points[i].x()));
+        pos_dict.Set("y", static_cast<double>(points[i].y()));
+        positions_list.Append(std::move(pos_dict));
+      }
+      run_dict.Set("positions", std::move(positions_list));
+    } else if (positioning == SkTextBlobRunIterator::kHorizontal_Positioning) {
+      // Horizontal: x positions only
+      base::Value::List positions_list;
+      const SkScalar* pos = iter.pos();
+      for (uint32_t i = 0; i < count; ++i) {
+        positions_list.Append(static_cast<double>(pos[i]));
+      }
+      run_dict.Set("positions", std::move(positions_list));
+    }
+    // kDefault_Positioning has no position data
+
+    // Serialize run offset
+    const SkPoint& offset = iter.offset();
+    run_dict.Set("offsetX", static_cast<double>(offset.x()));
+    run_dict.Set("offsetY", static_cast<double>(offset.y()));
+
+    // Serialize font info
+    const SkFont& font = iter.font();
+    run_dict.Set("fontSize", static_cast<double>(font.getSize()));
+    if (font.getTypeface()) {
+      SkString family_name;
+      font.getTypeface()->getFamilyName(&family_name);
+      run_dict.Set("fontFamily", std::string(family_name.c_str(), family_name.size()));
+      run_dict.Set("fontWeight", font.getTypeface()->fontStyle().weight());
+    }
+
+    runs_list.Append(std::move(run_dict));
+  }
+  root.Set("runs", std::move(runs_list));
+
+  // Serialize to JSON string and log
+  std::string json_output;
+  if (base::JSONWriter::Write(root, &json_output)) {
+    LOG(ERROR) << "BLINK_TEXT_BLOB: " << json_output;
+  }
+}
+
+}  // namespace blink
diff --git a/third_party/blink/renderer/platform/fonts/shaping/text_blob_serializer.h b/third_party/blink/renderer/platform/fonts/shaping/text_blob_serializer.h
new file mode 100644
index 0000000000..f9a06e987b
--- /dev/null
+++ b/third_party/blink/renderer/platform/fonts/shaping/text_blob_serializer.h
@@ -0,0 +1,26 @@
+// Copyright 2024 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef THIRD_PARTY_BLINK_RENDERER_PLATFORM_FONTS_SHAPING_TEXT_BLOB_SERIALIZER_H_
+#define THIRD_PARTY_BLINK_RENDERER_PLATFORM_FONTS_SHAPING_TEXT_BLOB_SERIALIZER_H_
+
+#include "cc/paint/node_id.h"
+#include "cc/paint/paint_flags.h"
+#include "third_party/blink/renderer/platform/platform_export.h"
+#include "third_party/skia/include/core/SkTextBlob.h"
+#include "ui/gfx/geometry/point_f.h"
+
+namespace blink {
+
+// Serializes text blob data to JSON format for debugging/tracing.
+// Output format matches DrawTextBlobOp in layers.json.
+// Logs via LOG(ERROR) with "BLINK_TEXT_BLOB:" prefix for extraction.
+PLATFORM_EXPORT void SerializeTextBlobToLog(const SkTextBlob* blob,
+                                            const gfx::PointF& point,
+                                            const cc::PaintFlags& flags,
+                                            cc::NodeId node_id);
+
+}  // namespace blink
+
+#endif  // THIRD_PARTY_BLINK_RENDERER_PLATFORM_FONTS_SHAPING_TEXT_BLOB_SERIALIZER_H_
diff --git a/third_party/blink/renderer/platform/graphics/compositing/paint_artifact_compositor.cc b/third_party/blink/renderer/platform/graphics/compositing/paint_artifact_compositor.cc
index d52098547f..b8f2fa5a22 100644
--- a/third_party/blink/renderer/platform/graphics/compositing/paint_artifact_compositor.cc
+++ b/third_party/blink/renderer/platform/graphics/compositing/paint_artifact_compositor.cc
@@ -5,6 +5,7 @@
 #include "third_party/blink/renderer/platform/graphics/compositing/paint_artifact_compositor.h"
 
 #include <algorithm>
+#include "third_party/blink/renderer/platform/graphics/compositing/paint_artifact_json_serializer.h"
 #include <memory>
 #include <utility>
 
@@ -1021,6 +1022,13 @@ void PaintArtifactCompositor::Update(
   OldPendingLayerMatcher old_pending_layer_matcher(std::move(pending_layers_));
   CHECK(painted_scroll_translations_.empty());
 
+  // Log raw PaintArtifact BEFORE layerization
+  auto paint_artifact_json = SerializePaintArtifact(artifact);
+  auto paint_artifact_props_json = SerializePaintArtifactPropertyTrees(artifact);
+  LOG(ERROR) << "PAINT_ARTIFACT: " << paint_artifact_json->ToJSONString().Utf8();
+  LOG(ERROR) << "PAINT_ARTIFACT_PROPERTY_TREES: "
+             << paint_artifact_props_json->ToJSONString().Utf8();
+
   // Make compositing decisions, storing the result in |pending_layers_|.
   pending_layers_ = Layerizer(*this, artifact, old_size).Layerize();
   PendingLayer::DecompositeTransforms(pending_layers_);
@@ -1160,6 +1168,19 @@ void PaintArtifactCompositor::Update(
            << GetLayersAsJSON(VLOG_IS_ON(3) ? 0xffffffff : 0)
                   ->ToPrettyJSONString()
                   .Utf8();
+
+  // Log Blink-level layer and property tree data for debugging/analysis
+  auto blink_layers_json =
+      SerializePendingLayersWithPaintOps(pending_layers_, artifact);
+  auto blink_property_trees_json =
+      SerializeBlinkPropertyTrees(pending_layers_, artifact);
+  LOG(ERROR) << "BLINK_LAYERS: " << blink_layers_json->ToJSONString().Utf8();
+  LOG(ERROR) << "BLINK_PROPERTY_TREES: "
+             << blink_property_trees_json->ToJSONString().Utf8();
+
+  // Log raw paint ops WITHOUT chunk grouping - flat list in paint order
+  auto raw_paint_ops_json = SerializeRawPaintOps(artifact);
+  LOG(ERROR) << "RAW_PAINT_OPS: " << raw_paint_ops_json->ToJSONString().Utf8();
 }
 
 bool PaintArtifactCompositor::TryFastPathUpdate(
diff --git a/third_party/blink/renderer/platform/graphics/compositing/paint_artifact_json_serializer.cc b/third_party/blink/renderer/platform/graphics/compositing/paint_artifact_json_serializer.cc
new file mode 100644
index 0000000000..8981fabef7
--- /dev/null
+++ b/third_party/blink/renderer/platform/graphics/compositing/paint_artifact_json_serializer.cc
@@ -0,0 +1,1018 @@
+// Copyright 2024 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "third_party/blink/renderer/platform/graphics/compositing/paint_artifact_json_serializer.h"
+
+#include <unordered_map>
+
+#include "base/compiler_specific.h"
+#include "cc/paint/draw_looper.h"
+#include "cc/paint/paint_filter.h"
+#include "cc/paint/paint_op.h"
+#include "cc/paint/path_effect.h"
+#include "third_party/skia/src/core/SkPathEffectBase.h"
+#include "cc/paint/paint_op_buffer_iterator.h"
+#include "third_party/blink/renderer/platform/allow_discouraged_type.h"
+#include "third_party/blink/renderer/platform/graphics/compositing/pending_layer.h"
+#include "third_party/blink/renderer/platform/graphics/paint/clip_paint_property_node.h"
+#include "third_party/blink/renderer/platform/graphics/paint/drawing_display_item.h"
+#include "third_party/blink/renderer/platform/graphics/paint/effect_paint_property_node.h"
+#include "third_party/blink/renderer/platform/graphics/paint/paint_artifact.h"
+#include "third_party/blink/renderer/platform/graphics/paint/paint_chunk_subset.h"
+#include "third_party/blink/renderer/platform/graphics/paint/transform_paint_property_node.h"
+#include "third_party/blink/renderer/platform/json/json_values.h"
+#include "third_party/blink/renderer/platform/wtf/text/string_builder.h"
+#include "third_party/skia/include/core/SkFont.h"
+#include "third_party/skia/include/core/SkPaint.h"
+#include "third_party/skia/include/core/SkFontStyle.h"
+#include "third_party/skia/include/core/SkPath.h"
+#include "third_party/skia/include/core/SkRSXform.h"
+#include "third_party/skia/include/core/SkTextBlob.h"
+#include "third_party/skia/include/core/SkTypeface.h"
+#include "third_party/skia/include/utils/SkParsePath.h"
+#include "third_party/skia/src/core/SkTextBlobPriv.h"
+#include "ui/gfx/geometry/transform.h"
+
+namespace blink {
+
+namespace {
+
+// Helper to serialize color from SkColor4f
+std::unique_ptr<JSONObject> SerializeColor(const SkColor4f& color) {
+  auto json = std::make_unique<JSONObject>();
+  json->SetDouble("r", color.fR);
+  json->SetDouble("g", color.fG);
+  json->SetDouble("b", color.fB);
+  json->SetDouble("a", color.fA);
+  return json;
+}
+
+// Helper to serialize a rect as array [left, top, right, bottom]
+std::unique_ptr<JSONArray> SerializeRectLTRB(const SkRect& rect) {
+  auto json = std::make_unique<JSONArray>();
+  json->PushDouble(rect.left());
+  json->PushDouble(rect.top());
+  json->PushDouble(rect.right());
+  json->PushDouble(rect.bottom());
+  return json;
+}
+
+// Helper to serialize gfx::Rect
+std::unique_ptr<JSONArray> SerializeGfxRect(const gfx::Rect& rect) {
+  auto json = std::make_unique<JSONArray>();
+  json->PushInteger(rect.x());
+  json->PushInteger(rect.y());
+  json->PushInteger(rect.width());
+  json->PushInteger(rect.height());
+  return json;
+}
+
+// Helper to serialize gfx::RectF
+std::unique_ptr<JSONArray> SerializeGfxRectF(const gfx::RectF& rect) {
+  auto json = std::make_unique<JSONArray>();
+  json->PushDouble(rect.x());
+  json->PushDouble(rect.y());
+  json->PushDouble(rect.width());
+  json->PushDouble(rect.height());
+  return json;
+}
+
+// Helper to serialize a 4x4 matrix from SkM44
+std::unique_ptr<JSONArray> SerializeSkM44(const SkM44& matrix) {
+  auto json = std::make_unique<JSONArray>();
+  for (int row = 0; row < 4; ++row) {
+    for (int col = 0; col < 4; ++col) {
+      json->PushDouble(matrix.rc(row, col));
+    }
+  }
+  return json;
+}
+
+// Helper to serialize gfx::Transform
+std::unique_ptr<JSONArray> SerializeTransform(const gfx::Transform& transform) {
+  auto json = std::make_unique<JSONArray>();
+  // gfx::Transform stores as column-major, output as row-major for readability
+  for (int row = 0; row < 4; ++row) {
+    for (int col = 0; col < 4; ++col) {
+      json->PushDouble(transform.rc(row, col));
+    }
+  }
+  return json;
+}
+
+// Helper to serialize paint flags (color, style, stroke)
+std::unique_ptr<JSONObject> SerializePaintFlags(const cc::PaintFlags& flags) {
+  auto json = std::make_unique<JSONObject>();
+  const SkColor4f& color = flags.getColor4f();
+  json->SetDouble("r", color.fR);
+  json->SetDouble("g", color.fG);
+  json->SetDouble("b", color.fB);
+  json->SetDouble("a", color.fA);
+  json->SetInteger("style", static_cast<int>(flags.getStyle()));
+  json->SetDouble("strokeWidth", flags.getStrokeWidth());
+
+  // Handle shaders (gradients)
+  if (flags.HasShader()) {
+    const cc::PaintShader* shader = flags.getShader();
+    if (shader) {
+      cc::PaintShader::Type type = shader->shader_type();
+      if (type == cc::PaintShader::Type::kLinearGradient) {
+        json->SetString("shaderType", "kLinearGradient");
+        auto start = std::make_unique<JSONArray>();
+        start->PushDouble(shader->start_point().x());
+        start->PushDouble(shader->start_point().y());
+        json->SetArray("startPoint", std::move(start));
+        auto end = std::make_unique<JSONArray>();
+        end->PushDouble(shader->end_point().x());
+        end->PushDouble(shader->end_point().y());
+        json->SetArray("endPoint", std::move(end));
+      } else if (type == cc::PaintShader::Type::kRadialGradient) {
+        json->SetString("shaderType", "kRadialGradient");
+        auto center = std::make_unique<JSONArray>();
+        center->PushDouble(shader->center().x());
+        center->PushDouble(shader->center().y());
+        json->SetArray("center", std::move(center));
+        json->SetDouble("radius", shader->end_radius());
+      } else if (type == cc::PaintShader::Type::kTwoPointConicalGradient) {
+        json->SetString("shaderType", "kTwoPointConicalGradient");
+      } else if (type == cc::PaintShader::Type::kSweepGradient) {
+        json->SetString("shaderType", "kSweepGradient");
+      } else {
+        json->SetString("shaderType", "other");
+      }
+
+      // Serialize gradient colors and positions
+      const auto& colors = shader->colors();
+      const auto& positions = shader->positions();
+      if (!colors.empty()) {
+        auto colors_array = std::make_unique<JSONArray>();
+        for (const auto& c : colors) {
+          colors_array->PushObject(SerializeColor(c));
+        }
+        json->SetArray("gradientColors", std::move(colors_array));
+
+        auto positions_array = std::make_unique<JSONArray>();
+        for (const auto& pos : positions) {
+          positions_array->PushDouble(pos);
+        }
+        json->SetArray("gradientPositions", std::move(positions_array));
+      }
+      json->SetBoolean("hasShader", true);
+    }
+  }
+
+  // Handle draw looper (shadows)
+  if (const auto& looper = flags.getLooper()) {
+    auto shadows_array = std::make_unique<JSONArray>();
+    for (const auto& layer : looper->GetLayers()) {
+      auto shadow_json = std::make_unique<JSONObject>();
+      shadow_json->SetDouble("offsetX", layer.offset.x());
+      shadow_json->SetDouble("offsetY", layer.offset.y());
+      shadow_json->SetDouble("blurSigma", layer.blur_sigma);
+      shadow_json->SetDouble("r", layer.color.fR);
+      shadow_json->SetDouble("g", layer.color.fG);
+      shadow_json->SetDouble("b", layer.color.fB);
+      shadow_json->SetDouble("a", layer.color.fA);
+      shadow_json->SetInteger("flags", layer.flags);
+      shadows_array->PushObject(std::move(shadow_json));
+    }
+    json->SetArray("shadows", std::move(shadows_array));
+  }
+
+  // Handle path effect (dash patterns for dotted/dashed outlines)
+  if (const auto& path_effect = flags.getPathEffect()) {
+    // Convert to SkPaint to get access to SkPathEffect
+    SkPaint sk_paint = flags.ToSkPaint();
+    sk_sp<SkPathEffect> sk_effect = sk_paint.refPathEffect();
+    if (sk_effect) {
+      auto* effect_base = static_cast<SkPathEffectBase*>(sk_effect.get());
+      auto dash_info = effect_base->asADash();
+      if (dash_info.has_value()) {
+        auto dash_json = std::make_unique<JSONObject>();
+        auto intervals_array = std::make_unique<JSONArray>();
+        for (size_t i = 0; i < dash_info->fIntervals.size(); ++i) {
+          intervals_array->PushDouble(dash_info->fIntervals[i]);
+        }
+        dash_json->SetArray("intervals", std::move(intervals_array));
+        dash_json->SetDouble("phase", dash_info->fPhase);
+        json->SetObject("dashPattern", std::move(dash_json));
+      }
+    }
+  }
+
+  return json;
+}
+
+// Forward declaration for recursive serialization
+void SerializePaintOpRecursive(const cc::PaintOp& op, JSONObject* json);
+
+// Serialize a PaintRecord (collection of paint ops)
+std::unique_ptr<JSONArray> SerializePaintRecord(const cc::PaintRecord& record) {
+  auto json = std::make_unique<JSONArray>();
+  for (cc::PaintOpBuffer::Iterator it(record.buffer()); it; ++it) {
+    auto op_json = std::make_unique<JSONObject>();
+    SerializePaintOpRecursive(*it, op_json.get());
+    json->PushObject(std::move(op_json));
+  }
+  return json;
+}
+
+// Serialize a single paint op
+void SerializePaintOpRecursive(const cc::PaintOp& op, JSONObject* json) {
+  json->SetString("type", cc::PaintOpTypeToString(op.GetType()).c_str());
+
+  switch (op.GetType()) {
+    case cc::PaintOpType::kClipRect: {
+      const auto& clip_op = static_cast<const cc::ClipRectOp&>(op);
+      json->SetArray("rect", SerializeRectLTRB(clip_op.rect));
+      json->SetBoolean("antiAlias", clip_op.antialias);
+      break;
+    }
+    case cc::PaintOpType::kClipRRect: {
+      const auto& clip_op = static_cast<const cc::ClipRRectOp&>(op);
+      json->SetArray("rect", SerializeRectLTRB(clip_op.rrect.rect()));
+      // Serialize corner radii
+      auto radii = std::make_unique<JSONArray>();
+      radii->PushDouble(clip_op.rrect.radii(SkRRect::kUpperLeft_Corner).x());
+      radii->PushDouble(clip_op.rrect.radii(SkRRect::kUpperLeft_Corner).y());
+      radii->PushDouble(clip_op.rrect.radii(SkRRect::kUpperRight_Corner).x());
+      radii->PushDouble(clip_op.rrect.radii(SkRRect::kUpperRight_Corner).y());
+      radii->PushDouble(clip_op.rrect.radii(SkRRect::kLowerRight_Corner).x());
+      radii->PushDouble(clip_op.rrect.radii(SkRRect::kLowerRight_Corner).y());
+      radii->PushDouble(clip_op.rrect.radii(SkRRect::kLowerLeft_Corner).x());
+      radii->PushDouble(clip_op.rrect.radii(SkRRect::kLowerLeft_Corner).y());
+      json->SetArray("radii", std::move(radii));
+      json->SetBoolean("antiAlias", clip_op.antialias);
+      break;
+    }
+    case cc::PaintOpType::kClipPath: {
+      const auto& clip_op = static_cast<const cc::ClipPathOp&>(op);
+      SkString path_str = SkParsePath::ToSVGString(clip_op.path);
+      json->SetString("path", path_str.c_str());
+      json->SetArray("bounds", SerializeRectLTRB(clip_op.path.getBounds()));
+      json->SetBoolean("antiAlias", clip_op.antialias);
+      break;
+    }
+    case cc::PaintOpType::kDrawColor: {
+      const auto& draw_op = static_cast<const cc::DrawColorOp&>(op);
+      json->SetDouble("r", draw_op.color.fR);
+      json->SetDouble("g", draw_op.color.fG);
+      json->SetDouble("b", draw_op.color.fB);
+      json->SetDouble("a", draw_op.color.fA);
+      break;
+    }
+    case cc::PaintOpType::kDrawLine: {
+      const auto& draw_op = static_cast<const cc::DrawLineOp&>(op);
+      json->SetDouble("x0", draw_op.x0);
+      json->SetDouble("y0", draw_op.y0);
+      json->SetDouble("x1", draw_op.x1);
+      json->SetDouble("y1", draw_op.y1);
+      break;
+    }
+    case cc::PaintOpType::kDrawOval: {
+      const auto& draw_op = static_cast<const cc::DrawOvalOp&>(op);
+      json->SetArray("oval", SerializeRectLTRB(draw_op.oval));
+      break;
+    }
+    case cc::PaintOpType::kDrawPath: {
+      const auto& draw_op = static_cast<const cc::DrawPathOp&>(op);
+      SkString path_str = SkParsePath::ToSVGString(draw_op.path);
+      json->SetString("path", path_str.c_str());
+      json->SetInteger("fillType",
+                       static_cast<int>(draw_op.path.getFillType()));
+      json->SetArray("bounds", SerializeRectLTRB(draw_op.path.getBounds()));
+      json->SetObject("flags", SerializePaintFlags(draw_op.flags));
+      break;
+    }
+    case cc::PaintOpType::kDrawRect: {
+      const auto& draw_op = static_cast<const cc::DrawRectOp&>(op);
+      json->SetArray("rect", SerializeRectLTRB(draw_op.rect));
+      json->SetObject("flags", SerializePaintFlags(draw_op.flags));
+      break;
+    }
+    case cc::PaintOpType::kDrawRRect: {
+      const auto& draw_op = static_cast<const cc::DrawRRectOp&>(op);
+      json->SetArray("rect", SerializeRectLTRB(draw_op.rrect.rect()));
+      // Serialize corner radii
+      auto radii = std::make_unique<JSONArray>();
+      radii->PushDouble(draw_op.rrect.radii(SkRRect::kUpperLeft_Corner).x());
+      radii->PushDouble(draw_op.rrect.radii(SkRRect::kUpperLeft_Corner).y());
+      radii->PushDouble(draw_op.rrect.radii(SkRRect::kUpperRight_Corner).x());
+      radii->PushDouble(draw_op.rrect.radii(SkRRect::kUpperRight_Corner).y());
+      radii->PushDouble(draw_op.rrect.radii(SkRRect::kLowerRight_Corner).x());
+      radii->PushDouble(draw_op.rrect.radii(SkRRect::kLowerRight_Corner).y());
+      radii->PushDouble(draw_op.rrect.radii(SkRRect::kLowerLeft_Corner).x());
+      radii->PushDouble(draw_op.rrect.radii(SkRRect::kLowerLeft_Corner).y());
+      json->SetArray("radii", std::move(radii));
+      json->SetObject("flags", SerializePaintFlags(draw_op.flags));
+      break;
+    }
+    case cc::PaintOpType::kDrawDRRect: {
+      // DrawDRRect draws between outer and inner rounded rects (used for borders, box-shadow inset)
+      const auto& draw_op = static_cast<const cc::DrawDRRectOp&>(op);
+      // Outer rrect
+      json->SetArray("outer_rect", SerializeRectLTRB(draw_op.outer.rect()));
+      auto outer_radii = std::make_unique<JSONArray>();
+      outer_radii->PushDouble(draw_op.outer.radii(SkRRect::kUpperLeft_Corner).x());
+      outer_radii->PushDouble(draw_op.outer.radii(SkRRect::kUpperLeft_Corner).y());
+      outer_radii->PushDouble(draw_op.outer.radii(SkRRect::kUpperRight_Corner).x());
+      outer_radii->PushDouble(draw_op.outer.radii(SkRRect::kUpperRight_Corner).y());
+      outer_radii->PushDouble(draw_op.outer.radii(SkRRect::kLowerRight_Corner).x());
+      outer_radii->PushDouble(draw_op.outer.radii(SkRRect::kLowerRight_Corner).y());
+      outer_radii->PushDouble(draw_op.outer.radii(SkRRect::kLowerLeft_Corner).x());
+      outer_radii->PushDouble(draw_op.outer.radii(SkRRect::kLowerLeft_Corner).y());
+      json->SetArray("outer_radii", std::move(outer_radii));
+      // Inner rrect
+      json->SetArray("inner_rect", SerializeRectLTRB(draw_op.inner.rect()));
+      auto inner_radii = std::make_unique<JSONArray>();
+      inner_radii->PushDouble(draw_op.inner.radii(SkRRect::kUpperLeft_Corner).x());
+      inner_radii->PushDouble(draw_op.inner.radii(SkRRect::kUpperLeft_Corner).y());
+      inner_radii->PushDouble(draw_op.inner.radii(SkRRect::kUpperRight_Corner).x());
+      inner_radii->PushDouble(draw_op.inner.radii(SkRRect::kUpperRight_Corner).y());
+      inner_radii->PushDouble(draw_op.inner.radii(SkRRect::kLowerRight_Corner).x());
+      inner_radii->PushDouble(draw_op.inner.radii(SkRRect::kLowerRight_Corner).y());
+      inner_radii->PushDouble(draw_op.inner.radii(SkRRect::kLowerLeft_Corner).x());
+      inner_radii->PushDouble(draw_op.inner.radii(SkRRect::kLowerLeft_Corner).y());
+      json->SetArray("inner_radii", std::move(inner_radii));
+      json->SetObject("flags", SerializePaintFlags(draw_op.flags));
+      break;
+    }
+    case cc::PaintOpType::kDrawTextBlob: {
+      const auto& draw_op = static_cast<const cc::DrawTextBlobOp&>(op);
+      json->SetDouble("x", draw_op.x);
+      json->SetDouble("y", draw_op.y);
+      json->SetInteger("nodeId", draw_op.node_id);
+      json->SetObject("flags", SerializePaintFlags(draw_op.flags));
+
+      // Serialize text blob runs with glyph data using SkTextBlobRunIterator
+      // which properly handles different positioning types
+      if (draw_op.blob) {
+        json->SetArray("bounds", SerializeRectLTRB(draw_op.blob->bounds()));
+
+        auto runs_array = std::make_unique<JSONArray>();
+        for (SkTextBlobRunIterator iter(draw_op.blob.get()); !iter.done();
+             iter.next()) {
+          auto run_json = std::make_unique<JSONObject>();
+          const uint32_t count = iter.glyphCount();
+          run_json->SetInteger("glyphCount", static_cast<int>(count));
+
+          // Serialize glyph IDs
+          // SAFETY: glyphs points to count elements as guaranteed by iter.glyphCount()
+          auto glyphs_array = std::make_unique<JSONArray>();
+          const SkGlyphID* glyphs = iter.glyphs();
+          for (uint32_t i = 0; i < count; ++i) {
+            glyphs_array->PushInteger(UNSAFE_TODO(glyphs[i]));
+          }
+          run_json->SetArray("glyphs", std::move(glyphs_array));
+
+          // Serialize positioning type and data
+          auto positioning = iter.positioning();
+          run_json->SetInteger("positioning", static_cast<int>(positioning));
+
+          // Serialize run offset (baseline position for horizontal runs)
+          const SkPoint& offset = iter.offset();
+          run_json->SetDouble("offsetX", offset.x());
+          run_json->SetDouble("offsetY", offset.y());
+
+          if (positioning == SkTextBlobRunIterator::kRSXform_Positioning) {
+            // RSXform: [scos, ssin, tx, ty] per glyph
+            // SAFETY: xforms has count elements for RSXform positioning
+            auto rsxforms_array = std::make_unique<JSONArray>();
+            const SkRSXform* xforms = iter.xforms();
+            for (uint32_t i = 0; i < count; ++i) {
+              auto xform_json = std::make_unique<JSONObject>();
+              xform_json->SetDouble("scos", UNSAFE_TODO(xforms[i]).fSCos);
+              xform_json->SetDouble("ssin", UNSAFE_TODO(xforms[i]).fSSin);
+              xform_json->SetDouble("tx", UNSAFE_TODO(xforms[i]).fTx);
+              xform_json->SetDouble("ty", UNSAFE_TODO(xforms[i]).fTy);
+              rsxforms_array->PushObject(std::move(xform_json));
+            }
+            run_json->SetArray("rsxforms", std::move(rsxforms_array));
+          } else if (positioning == SkTextBlobRunIterator::kFull_Positioning) {
+            // Full positioning: x,y pairs
+            // SAFETY: points has count elements for full positioning
+            auto positions_array = std::make_unique<JSONArray>();
+            const SkPoint* points = iter.points();
+            for (uint32_t i = 0; i < count; ++i) {
+              auto pos_json = std::make_unique<JSONObject>();
+              pos_json->SetDouble("x", UNSAFE_TODO(points[i]).x());
+              pos_json->SetDouble("y", UNSAFE_TODO(points[i]).y());
+              positions_array->PushObject(std::move(pos_json));
+            }
+            run_json->SetArray("positions", std::move(positions_array));
+          } else if (positioning ==
+                     SkTextBlobRunIterator::kHorizontal_Positioning) {
+            // Horizontal: x positions only, use iter.pos() for raw scalars
+            // SAFETY: pos has count scalars for horizontal positioning
+            auto positions_array = std::make_unique<JSONArray>();
+            const SkScalar* pos = iter.pos();
+            for (uint32_t i = 0; i < count; ++i) {
+              positions_array->PushDouble(UNSAFE_TODO(pos[i]));
+            }
+            run_json->SetArray("positions", std::move(positions_array));
+          }
+          // kDefault_Positioning has no position data - uses font metrics
+
+          // Serialize font info
+          const SkFont& font = iter.font();
+          auto font_json = std::make_unique<JSONObject>();
+          font_json->SetDouble("size", font.getSize());
+          font_json->SetDouble("scaleX", font.getScaleX());
+          font_json->SetDouble("skewX", font.getSkewX());
+          font_json->SetBoolean("embolden", font.isEmbolden());
+          font_json->SetBoolean("linearMetrics", font.isLinearMetrics());
+          font_json->SetBoolean("subpixel", font.isSubpixel());
+          font_json->SetBoolean("forceAutoHinting", font.isForceAutoHinting());
+
+          // Get typeface info if available
+          if (SkTypeface* typeface = font.getTypeface()) {
+            SkString family_name;
+            typeface->getFamilyName(&family_name);
+            font_json->SetString("family", family_name.c_str());
+            font_json->SetInteger("typefaceId", typeface->uniqueID());
+
+            // Font style
+            SkFontStyle style = typeface->fontStyle();
+            font_json->SetInteger("weight", style.weight());
+            font_json->SetInteger("width", style.width());
+            font_json->SetInteger("slant", static_cast<int>(style.slant()));
+          }
+
+          run_json->SetObject("font", std::move(font_json));
+          runs_array->PushObject(std::move(run_json));
+        }
+        json->SetArray("runs", std::move(runs_array));
+      }
+      break;
+    }
+    case cc::PaintOpType::kDrawRecord: {
+      const auto& draw_op = static_cast<const cc::DrawRecordOp&>(op);
+      json->SetArray("record", SerializePaintRecord(draw_op.record));
+      break;
+    }
+    case cc::PaintOpType::kDrawImageRect: {
+      const auto& draw_op = static_cast<const cc::DrawImageRectOp&>(op);
+      json->SetArray("src", SerializeRectLTRB(draw_op.src));
+      json->SetArray("dst", SerializeRectLTRB(draw_op.dst));
+      if (draw_op.image) {
+        json->SetInteger("imageWidth", draw_op.image.width());
+        json->SetInteger("imageHeight", draw_op.image.height());
+      }
+      break;
+    }
+    case cc::PaintOpType::kSave:
+    case cc::PaintOpType::kRestore:
+    case cc::PaintOpType::kNoop:
+      // No additional data
+      break;
+    case cc::PaintOpType::kSaveLayer: {
+      const auto& save_op = static_cast<const cc::SaveLayerOp&>(op);
+      json->SetArray("bounds", SerializeRectLTRB(save_op.bounds));
+      // Serialize flags including image filter (for shadows/blur)
+      auto flags_json = std::make_unique<JSONObject>();
+      const SkColor4f& color = save_op.flags.getColor4f();
+      flags_json->SetDouble("r", color.fR);
+      flags_json->SetDouble("g", color.fG);
+      flags_json->SetDouble("b", color.fB);
+      flags_json->SetDouble("a", color.fA);
+      // Check for image filter (used for blur, drop shadow, etc.)
+      const auto& image_filter = save_op.flags.getImageFilter();
+      if (image_filter) {
+        auto filter_json = std::make_unique<JSONObject>();
+        cc::PaintFilter::Type filter_type = image_filter->type();
+        filter_json->SetInteger("filterType", static_cast<int>(filter_type));
+        if (filter_type == cc::PaintFilter::Type::kBlur) {
+          const auto* blur =
+              static_cast<const cc::BlurPaintFilter*>(image_filter.get());
+          filter_json->SetString("filterName", "blur");
+          filter_json->SetDouble("sigmaX", blur->sigma_x());
+          filter_json->SetDouble("sigmaY", blur->sigma_y());
+        } else if (filter_type == cc::PaintFilter::Type::kDropShadow) {
+          const auto* shadow =
+              static_cast<const cc::DropShadowPaintFilter*>(image_filter.get());
+          filter_json->SetString("filterName", "dropShadow");
+          filter_json->SetDouble("dx", shadow->dx());
+          filter_json->SetDouble("dy", shadow->dy());
+          filter_json->SetDouble("sigmaX", shadow->sigma_x());
+          filter_json->SetDouble("sigmaY", shadow->sigma_y());
+          const SkColor4f& shadow_color = shadow->color();
+          auto shadow_color_json = std::make_unique<JSONObject>();
+          shadow_color_json->SetDouble("r", shadow_color.fR);
+          shadow_color_json->SetDouble("g", shadow_color.fG);
+          shadow_color_json->SetDouble("b", shadow_color.fB);
+          shadow_color_json->SetDouble("a", shadow_color.fA);
+          filter_json->SetObject("shadowColor", std::move(shadow_color_json));
+          filter_json->SetInteger("shadowMode",
+                                  static_cast<int>(shadow->shadow_mode()));
+        } else {
+          filter_json->SetString("filterName", "other");
+        }
+        flags_json->SetObject("imageFilter", std::move(filter_json));
+      }
+      json->SetObject("flags", std::move(flags_json));
+      break;
+    }
+    case cc::PaintOpType::kSaveLayerAlpha: {
+      const auto& save_op = static_cast<const cc::SaveLayerAlphaOp&>(op);
+      json->SetArray("bounds", SerializeRectLTRB(save_op.bounds));
+      json->SetDouble("alpha", save_op.alpha);
+      break;
+    }
+    case cc::PaintOpType::kTranslate: {
+      const auto& translate_op = static_cast<const cc::TranslateOp&>(op);
+      json->SetDouble("dx", translate_op.dx);
+      json->SetDouble("dy", translate_op.dy);
+      break;
+    }
+    case cc::PaintOpType::kScale: {
+      const auto& scale_op = static_cast<const cc::ScaleOp&>(op);
+      json->SetDouble("sx", scale_op.sx);
+      json->SetDouble("sy", scale_op.sy);
+      break;
+    }
+    case cc::PaintOpType::kRotate: {
+      const auto& rotate_op = static_cast<const cc::RotateOp&>(op);
+      json->SetDouble("degrees", rotate_op.degrees);
+      break;
+    }
+    case cc::PaintOpType::kConcat: {
+      const auto& concat_op = static_cast<const cc::ConcatOp&>(op);
+      json->SetArray("matrix", SerializeSkM44(concat_op.matrix));
+      break;
+    }
+    case cc::PaintOpType::kSetMatrix: {
+      const auto& matrix_op = static_cast<const cc::SetMatrixOp&>(op);
+      json->SetArray("matrix", SerializeSkM44(matrix_op.matrix));
+      break;
+    }
+    default:
+      // For other ops, just output type (already done above)
+      break;
+  }
+}
+
+// Property tree node ID assignment helpers.
+// Uses void* to avoid blink-gc checker issues with GC-managed pointers.
+// This is safe because we only use these maps during serialization within
+// a single stack frame - no GC can occur during this time.
+class PropertyTreeIdMapper {
+ public:
+  int GetOrAssignTransformId(const TransformPaintPropertyNode* node) {
+    if (!node) return -1;
+    const void* key = static_cast<const void*>(node);
+    auto it = transform_ids_.find(key);
+    if (it != transform_ids_.end()) {
+      return it->second;
+    }
+    // First assign IDs to parents (use UnaliasedParent to get correct type)
+    if (auto* parent = node->UnaliasedParent()) {
+      GetOrAssignTransformId(parent);
+    }
+    int id = next_transform_id_++;
+    transform_ids_[key] = id;
+    return id;
+  }
+
+  int GetOrAssignClipId(const ClipPaintPropertyNode* node) {
+    if (!node) return -1;
+    const void* key = static_cast<const void*>(node);
+    auto it = clip_ids_.find(key);
+    if (it != clip_ids_.end()) {
+      return it->second;
+    }
+    // First assign IDs to parents (use UnaliasedParent to get correct type)
+    if (auto* parent = node->UnaliasedParent()) {
+      GetOrAssignClipId(parent);
+    }
+    int id = next_clip_id_++;
+    clip_ids_[key] = id;
+    return id;
+  }
+
+  int GetOrAssignEffectId(const EffectPaintPropertyNode* node) {
+    if (!node) return -1;
+    const void* key = static_cast<const void*>(node);
+    auto it = effect_ids_.find(key);
+    if (it != effect_ids_.end()) {
+      return it->second;
+    }
+    // First assign IDs to parents (use UnaliasedParent to get correct type)
+    if (auto* parent = node->UnaliasedParent()) {
+      GetOrAssignEffectId(parent);
+    }
+    int id = next_effect_id_++;
+    effect_ids_[key] = id;
+    return id;
+  }
+
+  const std::unordered_map<const void*, int>& GetTransformIds() const {
+    return transform_ids_;
+  }
+  const std::unordered_map<const void*, int>& GetClipIds() const {
+    return clip_ids_;
+  }
+  const std::unordered_map<const void*, int>& GetEffectIds() const {
+    return effect_ids_;
+  }
+
+ private:
+  std::unordered_map<const void*, int> transform_ids_
+      ALLOW_DISCOURAGED_TYPE("Using void* to avoid blink-gc issues with GC pointers");
+  std::unordered_map<const void*, int> clip_ids_
+      ALLOW_DISCOURAGED_TYPE("Using void* to avoid blink-gc issues with GC pointers");
+  std::unordered_map<const void*, int> effect_ids_
+      ALLOW_DISCOURAGED_TYPE("Using void* to avoid blink-gc issues with GC pointers");
+  int next_transform_id_ = 0;
+  int next_clip_id_ = 0;
+  int next_effect_id_ = 0;
+};
+
+// Serialize a single PendingLayer
+std::unique_ptr<JSONObject> SerializePendingLayer(
+    const PendingLayer& layer,
+    int layer_id,
+    PropertyTreeIdMapper& id_mapper) {
+  auto json = std::make_unique<JSONObject>();
+
+  json->SetInteger("layer_id", layer_id);
+  json->SetString("debug_name", layer.DebugName());
+
+  // Bounds
+  const gfx::RectF& bounds = layer.BoundsForTesting();
+  auto bounds_json = std::make_unique<JSONObject>();
+  bounds_json->SetDouble("x", bounds.x());
+  bounds_json->SetDouble("y", bounds.y());
+  bounds_json->SetDouble("width", bounds.width());
+  bounds_json->SetDouble("height", bounds.height());
+  json->SetObject("bounds", std::move(bounds_json));
+
+  // Property tree state
+  const PropertyTreeState& state = layer.GetPropertyTreeState();
+  auto props_json = std::make_unique<JSONObject>();
+  props_json->SetInteger("transform_id",
+                         id_mapper.GetOrAssignTransformId(&state.Transform()));
+  props_json->SetInteger("clip_id",
+                         id_mapper.GetOrAssignClipId(&state.Clip()));
+  props_json->SetInteger("effect_id",
+                         id_mapper.GetOrAssignEffectId(&state.Effect()));
+  json->SetObject("property_tree_state", std::move(props_json));
+
+  json->SetBoolean("draws_content", layer.DrawsContent());
+
+  // Paint chunks and their paint ops
+  auto chunks_array = std::make_unique<JSONArray>();
+  int chunk_id = 0;
+  for (const auto& chunk : layer.Chunks()) {
+    auto chunk_json = std::make_unique<JSONObject>();
+    chunk_json->SetInteger("chunk_id", chunk_id++);
+    chunk_json->SetArray("bounds", SerializeGfxRect(chunk.bounds));
+    chunk_json->SetArray("drawable_bounds",
+                         SerializeGfxRect(chunk.drawable_bounds));
+
+    // Serialize paint ops from display items in this chunk
+    auto paint_ops_array = std::make_unique<JSONArray>();
+    const PaintArtifact& artifact = layer.Chunks().GetPaintArtifact();
+    // Use UNSAFE_TODO to wrap the unsafe buffer access - this is safe because
+    // begin_index and end_index are validated by the PaintChunk structure.
+    auto display_items = UNSAFE_TODO(
+        artifact.GetDisplayItemList().ItemsInRange(chunk.begin_index,
+                                                   chunk.end_index));
+    for (const DisplayItem& item : display_items) {
+      if (item.IsDrawing()) {
+        const auto& drawing = To<DrawingDisplayItem>(item);
+        const cc::PaintRecord& record = drawing.GetPaintRecord();
+        for (cc::PaintOpBuffer::Iterator it(record.buffer()); it; ++it) {
+          auto op_json = std::make_unique<JSONObject>();
+          SerializePaintOpRecursive(*it, op_json.get());
+          paint_ops_array->PushObject(std::move(op_json));
+        }
+      }
+    }
+    chunk_json->SetArray("paint_ops", std::move(paint_ops_array));
+
+    chunks_array->PushObject(std::move(chunk_json));
+  }
+  json->SetArray("paint_chunks", std::move(chunks_array));
+
+  return json;
+}
+
+// Serialize transform tree nodes - takes the id map that stores void* keys
+std::unique_ptr<JSONObject> SerializeTransformTree(
+    const std::unordered_map<const void*, int>& node_ids) {
+  auto json = std::make_unique<JSONObject>();
+  auto nodes_array = std::make_unique<JSONArray>();
+
+  // Create a vector of (id, void*) pairs for sorting by id
+  std::vector<std::pair<int, const void*>> sorted_nodes;
+  for (const auto& entry : node_ids) {
+    sorted_nodes.push_back({entry.second, entry.first});
+  }
+  std::sort(sorted_nodes.begin(), sorted_nodes.end(),
+            [](const auto& a, const auto& b) { return a.first < b.first; });
+
+  for (const auto& entry : sorted_nodes) {
+    int id = entry.first;
+    const auto* node =
+        static_cast<const TransformPaintPropertyNode*>(entry.second);
+
+    auto node_json = std::make_unique<JSONObject>();
+    node_json->SetInteger("id", id);
+
+    // Parent ID (use UnaliasedParent to get correct type)
+    if (auto* parent = node->UnaliasedParent()) {
+      const void* parent_key = static_cast<const void*>(parent);
+      auto parent_it = node_ids.find(parent_key);
+      node_json->SetInteger(
+          "parent_id", parent_it != node_ids.end() ? parent_it->second : -1);
+    } else {
+      node_json->SetInteger("parent_id", -1);
+    }
+
+    // Transform matrix
+    if (node->IsIdentityOr2dTranslation()) {
+      gfx::Vector2dF translation = node->Get2dTranslation();
+      if (!translation.IsZero()) {
+        auto translation_array = std::make_unique<JSONArray>();
+        translation_array->PushDouble(translation.x());
+        translation_array->PushDouble(translation.y());
+        node_json->SetArray("translation2d", std::move(translation_array));
+      }
+    } else {
+      node_json->SetArray("matrix", SerializeTransform(node->Matrix()));
+    }
+
+    nodes_array->PushObject(std::move(node_json));
+  }
+
+  json->SetArray("nodes", std::move(nodes_array));
+  return json;
+}
+
+// Serialize clip tree nodes
+std::unique_ptr<JSONObject> SerializeClipTree(
+    const std::unordered_map<const void*, int>& node_ids) {
+  auto json = std::make_unique<JSONObject>();
+  auto nodes_array = std::make_unique<JSONArray>();
+
+  // Create a vector of (id, void*) pairs for sorting by id
+  std::vector<std::pair<int, const void*>> sorted_nodes;
+  for (const auto& entry : node_ids) {
+    sorted_nodes.push_back({entry.second, entry.first});
+  }
+  std::sort(sorted_nodes.begin(), sorted_nodes.end(),
+            [](const auto& a, const auto& b) { return a.first < b.first; });
+
+  for (const auto& entry : sorted_nodes) {
+    int id = entry.first;
+    const auto* node = static_cast<const ClipPaintPropertyNode*>(entry.second);
+
+    auto node_json = std::make_unique<JSONObject>();
+    node_json->SetInteger("id", id);
+
+    // Parent ID (use UnaliasedParent to get correct type)
+    if (auto* parent = node->UnaliasedParent()) {
+      const void* parent_key = static_cast<const void*>(parent);
+      auto parent_it = node_ids.find(parent_key);
+      node_json->SetInteger(
+          "parent_id", parent_it != node_ids.end() ? parent_it->second : -1);
+    } else {
+      node_json->SetInteger("parent_id", -1);
+    }
+
+    // Clip rect
+    node_json->SetArray("clip_rect",
+                        SerializeGfxRectF(node->PaintClipRect().Rect()));
+
+    nodes_array->PushObject(std::move(node_json));
+  }
+
+  json->SetArray("nodes", std::move(nodes_array));
+  return json;
+}
+
+// Serialize effect tree nodes
+std::unique_ptr<JSONObject> SerializeEffectTree(
+    const std::unordered_map<const void*, int>& node_ids) {
+  auto json = std::make_unique<JSONObject>();
+  auto nodes_array = std::make_unique<JSONArray>();
+
+  // Create a vector of (id, void*) pairs for sorting by id
+  std::vector<std::pair<int, const void*>> sorted_nodes;
+  for (const auto& entry : node_ids) {
+    sorted_nodes.push_back({entry.second, entry.first});
+  }
+  std::sort(sorted_nodes.begin(), sorted_nodes.end(),
+            [](const auto& a, const auto& b) { return a.first < b.first; });
+
+  for (const auto& entry : sorted_nodes) {
+    int id = entry.first;
+    const auto* node =
+        static_cast<const EffectPaintPropertyNode*>(entry.second);
+
+    auto node_json = std::make_unique<JSONObject>();
+    node_json->SetInteger("id", id);
+
+    // Parent ID (use UnaliasedParent to get correct type)
+    if (auto* parent = node->UnaliasedParent()) {
+      const void* parent_key = static_cast<const void*>(parent);
+      auto parent_it = node_ids.find(parent_key);
+      node_json->SetInteger(
+          "parent_id", parent_it != node_ids.end() ? parent_it->second : -1);
+    } else {
+      node_json->SetInteger("parent_id", -1);
+    }
+
+    // Opacity
+    node_json->SetDouble("opacity", node->Opacity());
+
+    // Blend mode
+    node_json->SetString("blend_mode", SkBlendMode_Name(node->BlendMode()));
+
+    nodes_array->PushObject(std::move(node_json));
+  }
+
+  json->SetArray("nodes", std::move(nodes_array));
+  return json;
+}
+
+}  // namespace
+
+std::unique_ptr<JSONObject> SerializePendingLayersWithPaintOps(
+    const PendingLayers& pending_layers,
+    const PaintArtifact& artifact) {
+  auto json = std::make_unique<JSONObject>();
+  auto layers_array = std::make_unique<JSONArray>();
+
+  PropertyTreeIdMapper id_mapper;
+
+  int layer_id = 0;
+  for (const PendingLayer& layer : pending_layers) {
+    layers_array->PushObject(
+        SerializePendingLayer(layer, layer_id++, id_mapper));
+  }
+
+  json->SetArray("BlinkLayers", std::move(layers_array));
+  return json;
+}
+
+std::unique_ptr<JSONObject> SerializeBlinkPropertyTrees(
+    const PendingLayers& pending_layers,
+    const PaintArtifact& artifact) {
+  auto json = std::make_unique<JSONObject>();
+
+  // First, collect all property tree nodes from all layers
+  PropertyTreeIdMapper id_mapper;
+  for (const PendingLayer& layer : pending_layers) {
+    const PropertyTreeState& state = layer.GetPropertyTreeState();
+    id_mapper.GetOrAssignTransformId(&state.Transform());
+    id_mapper.GetOrAssignClipId(&state.Clip());
+    id_mapper.GetOrAssignEffectId(&state.Effect());
+  }
+
+  json->SetObject("transform_tree",
+                  SerializeTransformTree(id_mapper.GetTransformIds()));
+  json->SetObject("clip_tree", SerializeClipTree(id_mapper.GetClipIds()));
+  json->SetObject("effect_tree", SerializeEffectTree(id_mapper.GetEffectIds()));
+
+  return json;
+}
+
+std::unique_ptr<JSONObject> SerializePaintArtifact(
+    const PaintArtifact& artifact) {
+  auto json = std::make_unique<JSONObject>();
+  auto chunks_array = std::make_unique<JSONArray>();
+
+  PropertyTreeIdMapper id_mapper;
+
+  int chunk_id = 0;
+  for (const PaintChunk& chunk : artifact.GetPaintChunks()) {
+    auto chunk_json = std::make_unique<JSONObject>();
+    chunk_json->SetInteger("chunk_id", chunk_id++);
+    chunk_json->SetArray("bounds", SerializeGfxRect(chunk.bounds));
+    chunk_json->SetArray("drawable_bounds",
+                         SerializeGfxRect(chunk.drawable_bounds));
+
+    // Debug name from the display item id
+    if (chunk.id.client_id) {
+      chunk_json->SetString("debug_name",
+                            chunk.id.ToString(artifact).Utf8().c_str());
+    }
+
+    // Property tree state for this chunk
+    auto props_json = std::make_unique<JSONObject>();
+    props_json->SetInteger("transform_id",
+                           id_mapper.GetOrAssignTransformId(&chunk.properties.Transform().Unalias()));
+    props_json->SetInteger("clip_id",
+                           id_mapper.GetOrAssignClipId(&chunk.properties.Clip().Unalias()));
+    props_json->SetInteger("effect_id",
+                           id_mapper.GetOrAssignEffectId(&chunk.properties.Effect().Unalias()));
+    chunk_json->SetObject("property_tree_state", std::move(props_json));
+
+    // Serialize paint ops from display items in this chunk
+    auto paint_ops_array = std::make_unique<JSONArray>();
+    // Use UNSAFE_TODO to wrap the unsafe buffer access - this is safe because
+    // begin_index and end_index are validated by the PaintChunk structure.
+    auto display_items = UNSAFE_TODO(
+        artifact.GetDisplayItemList().ItemsInRange(chunk.begin_index,
+                                                   chunk.end_index));
+    for (const DisplayItem& item : display_items) {
+      if (item.IsDrawing()) {
+        const auto& drawing = To<DrawingDisplayItem>(item);
+        const cc::PaintRecord& record = drawing.GetPaintRecord();
+        for (cc::PaintOpBuffer::Iterator it(record.buffer()); it; ++it) {
+          auto op_json = std::make_unique<JSONObject>();
+          SerializePaintOpRecursive(*it, op_json.get());
+          paint_ops_array->PushObject(std::move(op_json));
+        }
+      }
+    }
+    chunk_json->SetArray("paint_ops", std::move(paint_ops_array));
+
+    chunks_array->PushObject(std::move(chunk_json));
+  }
+
+  json->SetArray("PaintChunks", std::move(chunks_array));
+  return json;
+}
+
+std::unique_ptr<JSONObject> SerializePaintArtifactPropertyTrees(
+    const PaintArtifact& artifact) {
+  auto json = std::make_unique<JSONObject>();
+
+  // Collect all property tree nodes from all chunks
+  PropertyTreeIdMapper id_mapper;
+  for (const PaintChunk& chunk : artifact.GetPaintChunks()) {
+    id_mapper.GetOrAssignTransformId(&chunk.properties.Transform().Unalias());
+    id_mapper.GetOrAssignClipId(&chunk.properties.Clip().Unalias());
+    id_mapper.GetOrAssignEffectId(&chunk.properties.Effect().Unalias());
+  }
+
+  json->SetObject("transform_tree",
+                  SerializeTransformTree(id_mapper.GetTransformIds()));
+  json->SetObject("clip_tree", SerializeClipTree(id_mapper.GetClipIds()));
+  json->SetObject("effect_tree", SerializeEffectTree(id_mapper.GetEffectIds()));
+
+  return json;
+}
+
+std::unique_ptr<JSONObject> SerializeRawPaintOps(const PaintArtifact& artifact) {
+  auto json = std::make_unique<JSONObject>();
+  auto paint_ops_array = std::make_unique<JSONArray>();
+
+  // We need property tree IDs, so use a mapper
+  PropertyTreeIdMapper id_mapper;
+
+  // First pass: assign IDs to all property tree nodes
+  for (const PaintChunk& chunk : artifact.GetPaintChunks()) {
+    id_mapper.GetOrAssignTransformId(&chunk.properties.Transform().Unalias());
+    id_mapper.GetOrAssignClipId(&chunk.properties.Clip().Unalias());
+    id_mapper.GetOrAssignEffectId(&chunk.properties.Effect().Unalias());
+  }
+
+  // Second pass: iterate through chunks to get property tree state for each op
+  for (const PaintChunk& chunk : artifact.GetPaintChunks()) {
+    // Get property tree IDs for this chunk
+    int transform_id = id_mapper.GetOrAssignTransformId(
+        &chunk.properties.Transform().Unalias());
+    int clip_id = id_mapper.GetOrAssignClipId(
+        &chunk.properties.Clip().Unalias());
+    int effect_id = id_mapper.GetOrAssignEffectId(
+        &chunk.properties.Effect().Unalias());
+
+    // Iterate through display items in this chunk
+    auto display_items = UNSAFE_TODO(
+        artifact.GetDisplayItemList().ItemsInRange(chunk.begin_index,
+                                                   chunk.end_index));
+    for (const DisplayItem& item : display_items) {
+      if (item.IsDrawing()) {
+        const auto& drawing = To<DrawingDisplayItem>(item);
+        const cc::PaintRecord& record = drawing.GetPaintRecord();
+        for (cc::PaintOpBuffer::Iterator it(record.buffer()); it; ++it) {
+          auto op_json = std::make_unique<JSONObject>();
+          SerializePaintOpRecursive(*it, op_json.get());
+
+          // Add property tree state to each paint op
+          op_json->SetInteger("transform_id", transform_id);
+          op_json->SetInteger("clip_id", clip_id);
+          op_json->SetInteger("effect_id", effect_id);
+
+          paint_ops_array->PushObject(std::move(op_json));
+        }
+      }
+    }
+  }
+
+  json->SetArray("paint_ops", std::move(paint_ops_array));
+
+  // Also include the property trees for reference
+  json->SetObject("transform_tree",
+                  SerializeTransformTree(id_mapper.GetTransformIds()));
+  json->SetObject("clip_tree", SerializeClipTree(id_mapper.GetClipIds()));
+  json->SetObject("effect_tree", SerializeEffectTree(id_mapper.GetEffectIds()));
+
+  return json;
+}
+
+}  // namespace blink
diff --git a/third_party/blink/renderer/platform/graphics/compositing/paint_artifact_json_serializer.h b/third_party/blink/renderer/platform/graphics/compositing/paint_artifact_json_serializer.h
new file mode 100644
index 0000000000..7378e7efc4
--- /dev/null
+++ b/third_party/blink/renderer/platform/graphics/compositing/paint_artifact_json_serializer.h
@@ -0,0 +1,55 @@
+// Copyright 2024 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef THIRD_PARTY_BLINK_RENDERER_PLATFORM_GRAPHICS_COMPOSITING_PAINT_ARTIFACT_JSON_SERIALIZER_H_
+#define THIRD_PARTY_BLINK_RENDERER_PLATFORM_GRAPHICS_COMPOSITING_PAINT_ARTIFACT_JSON_SERIALIZER_H_
+
+#include "third_party/blink/renderer/platform/graphics/compositing/pending_layer.h"
+#include "third_party/blink/renderer/platform/platform_export.h"
+#include <memory>
+
+namespace blink {
+
+class JSONObject;
+class PaintArtifact;
+
+// Serializes PendingLayers with paint ops to JSON format compatible with
+// layers.json structure. This captures Blink-level compositor data after
+// layerization but before handoff to CC.
+PLATFORM_EXPORT std::unique_ptr<JSONObject> SerializePendingLayersWithPaintOps(
+    const PendingLayers& pending_layers,
+    const PaintArtifact& artifact);
+
+// Serializes Blink property trees (transform, effect, clip) to JSON format
+// compatible with property_trees.json structure.
+PLATFORM_EXPORT std::unique_ptr<JSONObject> SerializeBlinkPropertyTrees(
+    const PendingLayers& pending_layers,
+    const PaintArtifact& artifact);
+
+// Serializes the raw PaintArtifact (PaintChunks + DisplayItems) BEFORE
+// layerization. This captures the paint data in its most granular form.
+PLATFORM_EXPORT std::unique_ptr<JSONObject> SerializePaintArtifact(
+    const PaintArtifact& artifact);
+
+// Serializes Blink property trees from raw PaintArtifact (before layerization).
+PLATFORM_EXPORT std::unique_ptr<JSONObject> SerializePaintArtifactPropertyTrees(
+    const PaintArtifact& artifact);
+
+// Serializes raw paint operations from PaintArtifact WITHOUT chunk grouping.
+// This outputs a flat list of paint ops in paint order, similar to what would
+// be captured by logging GraphicsContext calls directly.
+// Output format:
+// {
+//   "paint_ops": [
+//     { "type": "DrawRectOp", "rect": [...], "flags": {...} },
+//     { "type": "DrawTextBlobOp", ... },
+//     ...
+//   ]
+// }
+PLATFORM_EXPORT std::unique_ptr<JSONObject> SerializeRawPaintOps(
+    const PaintArtifact& artifact);
+
+}  // namespace blink
+
+#endif  // THIRD_PARTY_BLINK_RENDERER_PLATFORM_GRAPHICS_COMPOSITING_PAINT_ARTIFACT_JSON_SERIALIZER_H_
