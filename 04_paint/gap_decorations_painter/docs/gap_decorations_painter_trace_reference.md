# Gap Decorations Painter Trace Reference

## Overview

This document provides a detailed line-by-line trace of `GapDecorationsPainter::Paint()`, documenting how CSS gap decoration properties are transformed into graphics operations.

## Source File

**File:** `third_party/blink/renderer/core/paint/gap_decorations_painter.cc`
**Copyright:** 2025 The Chromium Authors

## Paint() Method Trace

### Lines 201-206: Method Entry and Style Extraction

```cpp
void GapDecorationsPainter::Paint(GridTrackSizingDirection track_direction,
                                  const PaintInfo& paint_info,
                                  const PhysicalRect& paint_rect,
                                  const GapGeometry& gap_geometry) {
  const ComputedStyle& style = box_fragment_.Style();
  const bool is_column_gap = (track_direction == kForColumns);
```

**Purpose:** Entry point for gap decoration painting.

**Parameters:**
- `track_direction`: Either `kForColumns` (column gaps) or `kForRows` (row gaps)
- `paint_info`: Contains the GraphicsContext and paint phase information
- `paint_rect`: The physical rectangle area to paint within
- `gap_geometry`: Pre-computed gap positions and intersection data

**State:** Extracts computed style from the box fragment; determines if painting column or row gaps.

---

### Lines 208-219: CSS Property Extraction

```cpp
  GapDataList<StyleColor> rule_colors =
      is_column_gap ? style.ColumnRuleColor() : style.RowRuleColor();
  GapDataList<EBorderStyle> rule_styles =
      is_column_gap ? style.ColumnRuleStyle() : style.RowRuleStyle();
  GapDataList<int> rule_widths =
      is_column_gap ? style.ColumnRuleWidth() : style.RowRuleWidth();
  RuleBreak rule_break = CSSGapDecorationUtils::ResolveRuleBreakValue(
      style, gap_geometry.GetContainerType(), track_direction);

  RuleVisibilityItems rule_visibility = is_column_gap
                                            ? style.ColumnRuleVisibilityItems()
                                            : style.RowRuleVisibilityItems();
```

**Purpose:** Read all CSS gap decoration properties for the current direction.

**CSS Properties:**
| Variable | CSS Property |
|----------|--------------|
| `rule_colors` | `column-rule-color` or `row-rule-color` |
| `rule_styles` | `column-rule-style` or `row-rule-style` |
| `rule_widths` | `column-rule-width` or `row-rule-width` |
| `rule_break` | `column-rule-break` or `row-rule-break` (resolved) |
| `rule_visibility` | `column-rule-visibility` or `row-rule-visibility` |

**Note:** `GapDataList` supports repeating patterns like `1px 2px 3px` cycling across gaps.

---

### Lines 221-226: Writing Mode and Dark Mode Setup

```cpp
  WritingModeConverter converter(style.GetWritingDirection(),
                                 box_fragment_.Size());
  AutoDarkMode auto_dark_mode(
      PaintAutoDarkMode(style, DarkModeFilter::ElementRole::kBackground));
  const BoxSide box_side =
      CSSGapDecorationUtils::BoxSideFromDirection(style, track_direction);
```

**Purpose:** Set up coordinate conversion and rendering context.

**Components:**
- `WritingModeConverter`: Handles RTL/LTR and vertical writing modes
- `AutoDarkMode`: Enables automatic dark mode color transformation
- `box_side`: Determines which BoxSide enum to use for DrawBoxSide (affects rendering for styled borders)

---

### Lines 228-241: Gap and Iterator Setup

```cpp
  const LayoutUnit cross_gutter_width = track_direction == kForRows
                                            ? gap_geometry.GetInlineGapSize()
                                            : gap_geometry.GetBlockGapSize();

  const bool is_main = gap_geometry.IsMainDirection(track_direction);
  const wtf_size_t gap_count = is_main ? gap_geometry.GetMainGaps().size()
                                       : gap_geometry.GetCrossGaps().size();

  auto width_iterator =
      GapDataListIterator<int>(rule_widths.GetGapDataList(), gap_count);
  auto style_iterator = GapDataListIterator<EBorderStyle>(
      rule_styles.GetGapDataList(), gap_count);
  auto color_iterator =
      GapDataListIterator<StyleColor>(rule_colors.GetGapDataList(), gap_count);
```

**Purpose:** Calculate iteration parameters and create CSS property iterators.

**Key Values:**
- `cross_gutter_width`: Width of the perpendicular gap (used for inset calculations)
- `is_main`: Whether this direction is the main axis of the container
- `gap_count`: Number of gaps to iterate over
- Iterators: Cycle through CSS values (with repeat pattern support)

---

### Lines 243-249: Gap Iteration Loop Start

```cpp
  for (wtf_size_t gap_index = 0; gap_index < gap_count; ++gap_index) {
    // Make sure we skip any multicol `MainGap`s generated by spanners.
    // This is because those `MainGap`s are not painted, and only used to
    // generate the `CrossGap` intersections.
    if (gap_geometry.IsMultiColSpanner(gap_index, track_direction)) {
      continue;
    }
```

**Purpose:** Iterate through each gap, skipping multicol spanner gaps.

**Logic:** Multicol spanners create "virtual" gaps for intersection calculation but are not painted.

---

### Lines 250-258: Per-Gap Property Resolution

```cpp
    const StyleColor rule_color = color_iterator.Next();
    const Color resolved_rule_color =
        style.VisitedDependentGapColor(rule_color, style, is_column_gap);
    const EBorderStyle rule_style =
        ComputedStyle::CollapsedBorderStyle(style_iterator.Next());
    const LayoutUnit rule_thickness = LayoutUnit(width_iterator.Next());

    const LayoutUnit center =
        gap_geometry.GetGapCenterOffset(track_direction, gap_index);
```

**Purpose:** Get CSS properties for this specific gap.

**Color Resolution:**
- `VisitedDependentGapColor`: Handles `:visited` link color adjustments
- Supports `currentColor` keyword resolution

**Style Collapsing:**
- `CollapsedBorderStyle`: Normalizes border styles (e.g., `outset` becomes `solid` for gap rules)

**Geometry:**
- `center`: Offset to the center line of the gap in the primary axis

---

### Lines 260-273: Intersection List and Segment Loop

```cpp
    const Vector<LayoutUnit> intersections =
        gap_geometry.GenerateIntersectionListForGap(track_direction, gap_index);

    const wtf_size_t last_intersection_index = intersections.size() - 1;
    wtf_size_t start = 0;
    while (start < last_intersection_index) {
      wtf_size_t end = start;
      AdjustIntersectionIndexPair(track_direction, start, end,
                                  intersections.size(), gap_index, rule_break,
                                  rule_visibility, gap_geometry, intersections);
      if (start >= end) {
        // Break because there's no gap segment to paint.
        break;
      }
```

**Purpose:** Generate intersection points and iterate through paintable segments.

**Intersections:** Points where this gap intersects with perpendicular gaps or container edges.

**Segment Pairs:** `(start, end)` pairs define which portions of the gap to paint, accounting for:
- Rule visibility (around/between empty cells)
- Rule break (spanning items, intersections)

---

### Lines 275-304: Crossing Gap Width Calculation

```cpp
      // The cross gutter size is used to determine the "crossing gap width" at
      // intersection points. The crossing gap width of an intersection point is
      // defined as:
      // * `0` if the intersection is at the content edge of the container.
      // * The cross gutter size if it is an intersection with another gap.
      // https://drafts.csswg.org/css-gaps-1/#crossing-gap-width
      //
      // TODO(crbug.com/446616449): Recently we have resolved to always use the
      // cross gutter size for resolving the "crossing gap width", however, it
      // is still an open question what this means for multicol containers...
      const LayoutUnit start_width =
          gap_geometry.GetContainerType() ==
                      GapGeometry::ContainerType::kMultiColumn ||
                  gap_geometry.IsEdgeIntersection(gap_index, start,
                                                  intersections.size(), is_main,
                                                  intersections)
              ? LayoutUnit()
              : cross_gutter_width;
      const LayoutUnit end_width =
          gap_geometry.GetContainerType() ==
                      GapGeometry::ContainerType::kMultiColumn ||
                  gap_geometry.IsEdgeIntersection(gap_index, end,
                                                  intersections.size(), is_main,
                                                  intersections)
              ? LayoutUnit()
              : cross_gutter_width;
```

**Purpose:** Determine crossing gap widths at segment endpoints.

**Spec Reference:** https://drafts.csswg.org/css-gaps-1/#crossing-gap-width

**Logic:**
- Edge intersections (at container boundary): width = 0
- Cross-gap intersections: width = cross_gutter_width
- MultiColumn containers: always width = 0 (special case)

---

### Lines 306-321: Inset and Offset Calculation

```cpp
      // Inset values are used to offset the end points of gap decorations.
      // Percentage values are resolved against the crossing gap width of the
      // intersection point.
      // https://drafts.csswg.org/css-gaps-1/#propdef-column-rule-inset
      LayoutUnit start_inset =
          gap_geometry.ComputeInsetStart(style, gap_index, start, intersections,
                                         is_column_gap, is_main, start_width);
      LayoutUnit end_inset =
          gap_geometry.ComputeInsetEnd(style, gap_index, end, intersections,
                                       is_column_gap, is_main, end_width);
      // Compute the gap decorations offset as half of the `crossing_gap_width`
      // plus the inset.
      // https://drafts.csswg.org/css-gaps-1/#compute-the-offset
      const LayoutUnit decoration_start_offset =
          (start_width / 2) + start_inset;
      const LayoutUnit decoration_end_offset = (end_width / 2) + end_inset;
```

**Purpose:** Calculate the final offset for decoration endpoints.

**Spec Reference:** https://drafts.csswg.org/css-gaps-1/#propdef-column-rule-inset

**Formula:**
- `decoration_offset = (crossing_gap_width / 2) + inset`
- Insets can be percentages (resolved against crossing_gap_width)

---

### Lines 323-342: Geometry Calculation

```cpp
      // Compute the primary axis values using the gap offsets.
      const LayoutUnit primary_start = center - (rule_thickness / 2);
      const LayoutUnit primary_size = rule_thickness;

      // Compute the secondary axis values using the intersection offsets.
      const LayoutUnit secondary_start =
          intersections[start] + decoration_start_offset;
      const LayoutUnit secondary_size =
          intersections[end] - secondary_start - decoration_end_offset;

      // Columns paint a vertical strip at the center of the gap while rows
      // paint horizontal strip at the center of the gap
      const LayoutUnit inline_start =
          is_column_gap ? primary_start : secondary_start;
      const LayoutUnit inline_size =
          is_column_gap ? primary_size : secondary_size;
      const LayoutUnit block_start =
          is_column_gap ? secondary_start : primary_start;
      const LayoutUnit block_size =
          is_column_gap ? secondary_size : primary_size;
```

**Purpose:** Compute the decoration rectangle in logical coordinates.

**Axes:**
- **Primary axis**: Along the gap direction (rule thickness)
- **Secondary axis**: Along the gap length (from intersection to intersection)

**Mapping:**
| Direction | Inline | Block |
|-----------|--------|-------|
| Column gap | Primary (horizontal strip) | Secondary (vertical extent) |
| Row gap | Secondary (horizontal extent) | Primary (vertical strip) |

---

### Lines 344-354: Coordinate Conversion and Drawing

```cpp
      const LogicalRect gap_logical(inline_start, block_start, inline_size,
                                    block_size);
      PhysicalRect gap_rect = converter.ToPhysical(gap_logical);
      gap_rect.offset += paint_rect.offset;
      BoxBorderPainter::DrawBoxSide(
          paint_info.context, ToPixelSnappedRect(gap_rect), box_side,
          resolved_rule_color, rule_style, auto_dark_mode);

      start = end;
    }
  }
}
```

**Purpose:** Convert to physical coordinates and draw the decoration.

**Steps:**
1. Create `LogicalRect` from inline/block coordinates
2. Convert to `PhysicalRect` using `WritingModeConverter`
3. Add `paint_rect.offset` for absolute positioning
4. Snap to device pixels with `ToPixelSnappedRect`
5. Draw via `BoxBorderPainter::DrawBoxSide`
6. Advance to next segment (`start = end`)

---

## Graphics Context Operations

### DrawBoxSide Call

The single graphics operation used by GapDecorationsPainter:

```cpp
BoxBorderPainter::DrawBoxSide(
    GraphicsContext& context,        // paint_info.context
    const gfx::Rect& snapped_rect,   // pixel-snapped gap rectangle
    BoxSide side,                    // determines edge style rendering
    Color color,                     // resolved_rule_color
    EBorderStyle style,              // rule_style (solid, dashed, etc.)
    const AutoDarkMode& auto_dark_mode
)
```

**Internally calls:**
```cpp
DrawLineForBoxSide(context, x1, y1, x2, y2, side, color, style, 0, 0, auto_dark_mode)
```

**Supported Styles:**
| EBorderStyle | Rendering |
|--------------|-----------|
| `kNone` | No rendering |
| `kHidden` | No rendering |
| `kSolid` | Filled rectangle |
| `kDashed` | Dashed line pattern |
| `kDotted` | Dotted line pattern |
| `kDouble` | Two parallel lines |
| `kGroove` | 3D groove effect |
| `kRidge` | 3D ridge effect |
| `kInset` | 3D inset effect |
| `kOutset` | 3D outset effect |

---

## Helper Functions

### IsRuleSegmentVisible (Lines 23-48)

**Purpose:** Determines visibility of a gap segment based on cell occupancy.

**Input:** Gap position, segment index, visibility mode, gap geometry
**Output:** Boolean indicating if segment should be painted

**Logic by Visibility Mode:**
- `kAll`: Always `true`
- `kNone`: Always `false`
- `kAround`: `true` if either side has content (not both empty)
- `kBetween`: `true` only if both sides have content

---

### ShouldMoveIntersectionStartForward (Lines 54-77)

**Purpose:** Determines if segment start should advance past current intersection.

**Used for:** Skipping blocked or invisible segment starts.

**Returns true if:**
- Intersection is blocked after by spanning item
- Segment at this intersection is not visible

---

### ShouldMoveIntersectionEndForward (Lines 83-155)

**Purpose:** Determines if segment end should extend past current intersection.

**Rule break behavior:**
- `kNone`: Always extend (no breaking)
- `kSpanningItem`: Stop at T-intersections (blocked after)
- `kIntersection`: Stop at T and cross intersections

**Grid-specific logic:**
- Checks cross-direction blocking to detect true cross-intersections
- Only extends if cross-intersection is flanked by spanners on both sides

---

### AdjustIntersectionIndexPair (Lines 160-195)

**Purpose:** Wrapper that adjusts both start and end indices for a gap segment.

**Algorithm:**
1. Advance `start` while `ShouldMoveIntersectionStartForward` is true
2. If `start` reaches last intersection, no segment to paint
3. Set `end = start + 1`
4. Advance `end` while `ShouldMoveIntersectionEndForward` is true

---

## Data Flow Summary

```
CSS Properties
     |
     v
+--------------------+
| GapDataListIterator|  (cycles through repeating patterns)
+--------------------+
     |
     v
+------------------+
| Gap Geometry     |  (positions, intersections, blocked status)
+------------------+
     |
     v
+-------------------+
| Visibility/Break  |  (segment start/end adjustment)
| Logic             |
+-------------------+
     |
     v
+-------------------+
| Coordinate Math   |  (primary/secondary to inline/block)
+-------------------+
     |
     v
+--------------------+
| WritingModeConverter| (logical to physical)
+--------------------+
     |
     v
+-------------------+
| ToPixelSnappedRect|  (device pixel alignment)
+-------------------+
     |
     v
+-------------------+
| DrawBoxSide       |  (actual graphics operation)
+-------------------+
```
