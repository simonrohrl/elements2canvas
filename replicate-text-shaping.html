<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Replicate Text Shaping</title>
  <style>
    body {
      font-family: system-ui, sans-serif;
      padding: 20px;
      max-width: 1200px;
      margin: 0 auto;
    }
    .controls {
      margin-bottom: 20px;
      padding: 15px;
      background: #f5f5f5;
      border-radius: 8px;
    }
    button {
      padding: 10px 20px;
      margin-right: 10px;
      cursor: pointer;
    }
    #status {
      margin-top: 10px;
      padding: 10px;
      background: #e8f5e9;
      border-radius: 4px;
    }
    .comparison {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 20px;
      margin-top: 20px;
    }
    .panel {
      border: 1px solid #ddd;
      border-radius: 8px;
      padding: 15px;
    }
    .panel h3 {
      margin-top: 0;
      border-bottom: 1px solid #eee;
      padding-bottom: 10px;
    }
    .text-item {
      margin: 10px 0;
      padding: 10px;
      background: #fafafa;
      border-radius: 4px;
      font-size: 12px;
    }
    .text-item .text-content {
      font-weight: bold;
      margin-bottom: 5px;
    }
    .text-item .positions {
      font-family: monospace;
      color: #666;
      word-break: break-all;
    }
    .match { background: #e8f5e9; }
    .mismatch { background: #ffebee; }
    .diff {
      color: #c62828;
      font-weight: bold;
    }
    #results {
      margin-top: 20px;
    }
    .stats {
      padding: 15px;
      background: #e3f2fd;
      border-radius: 8px;
      margin-bottom: 20px;
    }
  </style>
  <script src="https://unpkg.com/canvaskit-wasm@0.39.1/bin/canvaskit.js"></script>
</head>
<body>
  <h1>Text Shaping Replication</h1>

  <div class="controls">
    <button id="compareBtn" disabled>Run Comparison</button>
    <div id="status">Initializing...</div>
  </div>

  <div id="results"></div>

  <script>
    let CanvasKit = null;
    let layoutData = null;
    let arialTypeface = null;
    let fontMgr = null;

    // Initialize everything
    async function init() {
      try {
        updateStatus('Initializing CanvasKit...');
        CanvasKit = await CanvasKitInit({
          locateFile: (file) => `https://unpkg.com/canvaskit-wasm@0.39.1/bin/${file}`
        });

        updateStatus('Loading Arial.ttf...');
        const fontResponse = await fetch('Arial.ttf');
        if (!fontResponse.ok) {
          throw new Error(`Failed to load Arial.ttf: ${fontResponse.status}`);
        }
        const fontData = await fontResponse.arrayBuffer();
        arialTypeface = CanvasKit.Typeface.MakeFreeTypeFaceFromData(fontData);
        if (!arialTypeface) {
          throw new Error('Failed to create typeface from Arial.ttf');
        }

        // Create FontMgr with Arial for Paragraph API
        fontMgr = CanvasKit.FontMgr.FromData([fontData]);
        if (!fontMgr) {
          throw new Error('Failed to create FontMgr');
        }

        updateStatus('Loading layout_tree.json...');
        const layoutResponse = await fetch('layout_tree.json');
        if (!layoutResponse.ok) {
          throw new Error(`Failed to load layout_tree.json: ${layoutResponse.status}`);
        }
        layoutData = await layoutResponse.json();

        const textNodes = layoutData.layout_tree.filter(n => n.text && n.fragments);
        updateStatus(`Ready! Loaded ${textNodes.length} text nodes. Click "Run Comparison" to start.`);
        document.getElementById('compareBtn').disabled = false;

      } catch (e) {
        updateStatus(`Error: ${e.message}`);
        console.error(e);
      }
    }

    function updateStatus(msg) {
      document.getElementById('status').textContent = msg;
    }

    // Extract text nodes with their styling and glyph data
    function extractTextNodes(layoutTree) {
      const textNodes = [];

      for (const node of layoutTree) {
        if (node.text && node.fragments && node.fragments.length > 0) {
          const style = node.computed_style || {};

          for (const fragment of node.fragments) {
            if (fragment.runs && fragment.runs.length > 0) {
              for (const run of fragment.runs) {
                if (run.glyphs && run.positions) {
                  textNodes.push({
                    id: node.id,
                    name: node.name,
                    text: node.text.substring(fragment.start, fragment.end),
                    fullText: node.text,
                    start: fragment.start,
                    end: fragment.end,
                    style: {
                      fontFamily: style.font_family || 'Arial',
                      fontSize: style.font_size || 16,
                      fontWeight: style.font_weight || 400,
                      fontStyle: style.font_style || 'normal',
                      letterSpacing: style.letter_spacing || 0,
                      wordSpacing: style.word_spacing || 0
                    },
                    chromiumGlyphs: run.glyphs,
                    chromiumPositions: run.positions
                  });
                }
              }
            }
          }
        }
      }

      return textNodes;
    }

    // Shape text using CanvasKit Paragraph API (includes HarfBuzz shaping with kerning)
    function shapeText(text, style) {
      // Build paragraph style
      const paraStyle = new CanvasKit.ParagraphStyle({
        textStyle: {
          color: CanvasKit.BLACK,
          fontFamilies: ['Arial'],
          fontSize: style.fontSize,
          fontStyle: {
            weight: style.fontWeight === 700 ? CanvasKit.FontWeight.Bold : CanvasKit.FontWeight.Normal,
            slant: style.fontStyle === 'italic' ? CanvasKit.FontSlant.Italic : CanvasKit.FontSlant.Upright
          },
          letterSpacing: style.letterSpacing || 0,
          wordSpacing: style.wordSpacing || 0
        }
      });

      const builder = CanvasKit.ParagraphBuilder.Make(paraStyle, fontMgr);
      builder.addText(text);
      const paragraph = builder.build();

      // Layout at a very wide width to avoid line breaks
      paragraph.layout(10000);

      // Get shaped lines with glyph positions
      const shapedLines = paragraph.getShapedLines();

      let glyphs = [];
      let positions = [];

      if (shapedLines && shapedLines.length > 0) {
        for (const line of shapedLines) {
          if (line.runs) {
            for (const run of line.runs) {
              if (run.glyphs && run.positions) {
                // Glyphs are straightforward
                glyphs = glyphs.concat(Array.from(run.glyphs));

                // Positions are [x0, y0, x1, y1, ...] - extract just x values
                for (let i = 0; i < run.glyphs.length; i++) {
                  positions.push(run.positions[i * 2]); // x position
                }
              }
            }
          }
        }
      }

      // Fallback to simple approach if Paragraph API didn't work
      if (glyphs.length === 0) {
        const font = new CanvasKit.Font(arialTypeface, style.fontSize);
        font.setSubpixel(true);
        const glyphIds = font.getGlyphIDs(text);
        const glyphWidths = font.getGlyphWidths(glyphIds);

        let currentX = 0;
        for (let i = 0; i < text.length; i++) {
          positions.push(currentX);
          currentX += (glyphWidths[i] || 0);
          if (style.letterSpacing) currentX += style.letterSpacing;
          if (style.wordSpacing && (text[i] === ' ' || text[i] === '\u00A0')) {
            currentX += style.wordSpacing;
          }
        }
        glyphs = Array.from(glyphIds);
        font.delete();
      }

      paragraph.delete();
      builder.delete();

      return { glyphs, positions };
    }

    // Compare positions with tolerance
    function comparePositions(chromiumPos, canvaskitPos, tolerance = 0.5) {
      if (chromiumPos.length !== canvaskitPos.length) {
        return { match: false, reason: 'length mismatch' };
      }

      const diffs = [];
      let maxDiff = 0;

      for (let i = 0; i < chromiumPos.length; i++) {
        const diff = Math.abs(chromiumPos[i] - canvaskitPos[i]);
        diffs.push(diff);
        maxDiff = Math.max(maxDiff, diff);
      }

      return {
        match: maxDiff <= tolerance,
        maxDiff,
        diffs,
        avgDiff: diffs.reduce((a, b) => a + b, 0) / diffs.length
      };
    }

    // Run the comparison
    async function runComparison() {
      if (!CanvasKit || !layoutData || !arialTypeface) {
        updateStatus('Not ready yet');
        return;
      }

      updateStatus('Running comparison...');

      const textNodes = extractTextNodes(layoutData.layout_tree);
      const results = [];

      let matches = 0;
      let mismatches = 0;

      for (const node of textNodes) {
        const canvaskitResult = shapeText(node.text, node.style);

        const comparison = comparePositions(
          node.chromiumPositions,
          canvaskitResult.positions
        );

        if (comparison.match) {
          matches++;
        } else {
          mismatches++;
        }

        results.push({
          ...node,
          canvaskitGlyphs: canvaskitResult.glyphs,
          canvaskitPositions: canvaskitResult.positions,
          comparison
        });
      }

      // Render results
      renderResults(results, matches, mismatches);
      updateStatus(`Comparison complete: ${matches} matches, ${mismatches} mismatches`);
    }

    function renderResults(results, matches, mismatches) {
      const container = document.getElementById('results');

      // Stats
      const statsHtml = `
        <div class="stats">
          <strong>Results:</strong> ${matches} matches, ${mismatches} mismatches
          (${((matches / results.length) * 100).toFixed(1)}% match rate)
        </div>
      `;

      // Generate pre-shaping JSON (without positions)
      const preShapingData = {
        layout_tree: layoutData.layout_tree.map(node => {
          if (!node.fragments) return node;

          return {
            ...node,
            fragments: node.fragments.map(frag => ({
              ...frag,
              runs: frag.runs?.map(run => ({
                glyphs: null,
                positions: null
              }))
            }))
          };
        })
      };

      // Download buttons
      const downloadHtml = `
        <div style="margin-bottom: 20px;">
          <button id="downloadPreBtn">Download layout_tree_pre_shape.json</button>
          <button id="downloadReconBtn">Download layout_tree_reconstructed.json</button>
        </div>
      `;

      // Store for download
      window._preShapingData = preShapingData;
      window._reconstructedData = reconstructLayoutTree(results);

      // Results table
      let resultsHtml = '<div class="comparison"><div class="panel"><h3>Chromium (Original)</h3>';

      for (const r of results.slice(0, 50)) {
        const matchClass = r.comparison.match ? 'match' : 'mismatch';
        resultsHtml += `
          <div class="text-item ${matchClass}">
            <div class="text-content">"${escapeHtml(r.text)}"</div>
            <div>Font: ${r.style.fontFamily} ${r.style.fontSize}px, weight: ${r.style.fontWeight}</div>
            <div>Letter-spacing: ${r.style.letterSpacing}, Word-spacing: ${r.style.wordSpacing}</div>
            <div class="positions">Glyphs: [${r.chromiumGlyphs.slice(0, 10).join(', ')}${r.chromiumGlyphs.length > 10 ? '...' : ''}]</div>
            <div class="positions">Positions: [${r.chromiumPositions.slice(0, 10).map(p => p.toFixed(2)).join(', ')}${r.chromiumPositions.length > 10 ? '...' : ''}]</div>
          </div>
        `;
      }
      resultsHtml += '</div><div class="panel"><h3>CanvasKit (Reconstructed)</h3>';

      for (const r of results.slice(0, 50)) {
        const matchClass = r.comparison.match ? 'match' : 'mismatch';
        resultsHtml += `
          <div class="text-item ${matchClass}">
            <div class="text-content">"${escapeHtml(r.text)}"</div>
            <div>Max diff: ${r.comparison.maxDiff?.toFixed(2) || 'N/A'}, Avg diff: ${r.comparison.avgDiff?.toFixed(2) || 'N/A'}</div>
            <div class="positions">Glyphs: [${r.canvaskitGlyphs.slice(0, 10).join(', ')}${r.canvaskitGlyphs.length > 10 ? '...' : ''}]</div>
            <div class="positions">Positions: [${r.canvaskitPositions.slice(0, 10).map(p => (p ?? 0).toFixed(2)).join(', ')}${r.canvaskitPositions.length > 10 ? '...' : ''}]</div>
          </div>
        `;
      }
      resultsHtml += '</div></div>';

      if (results.length > 50) {
        resultsHtml += `<p>Showing first 50 of ${results.length} text fragments...</p>`;
      }

      container.innerHTML = statsHtml + downloadHtml + resultsHtml;

      document.getElementById('downloadPreBtn').addEventListener('click', downloadPreShaping);
      document.getElementById('downloadReconBtn').addEventListener('click', downloadReconstructed);
    }

    function reconstructLayoutTree(results) {
      const reconstructedByNode = new Map();
      for (const r of results) {
        if (!reconstructedByNode.has(r.id)) {
          reconstructedByNode.set(r.id, []);
        }
        reconstructedByNode.get(r.id).push({
          start: r.start,
          end: r.end,
          glyphs: r.canvaskitGlyphs,
          positions: r.canvaskitPositions
        });
      }

      return {
        layout_tree: layoutData.layout_tree.map(node => {
          if (!node.fragments) return node;

          const reconstructed = reconstructedByNode.get(node.id) || [];
          let fragIndex = 0;

          return {
            ...node,
            fragments: node.fragments.map(frag => ({
              ...frag,
              runs: frag.runs?.map(run => {
                const recon = reconstructed[fragIndex++];
                return {
                  glyphs: recon?.glyphs || run.glyphs,
                  positions: recon?.positions || run.positions,
                  positioning: run.positioning
                };
              })
            }))
          };
        })
      };
    }

    function downloadPreShaping() {
      downloadJson(window._preShapingData, 'layout_tree_pre_shape.json');
    }

    function downloadReconstructed() {
      downloadJson(window._reconstructedData, 'layout_tree_reconstructed.json');
    }

    function downloadJson(data, filename) {
      const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = filename;
      a.click();
      URL.revokeObjectURL(url);
    }

    function escapeHtml(text) {
      return text.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
    }

    // Set up event listeners and initialize
    document.getElementById('compareBtn').addEventListener('click', runComparison);
    init();
  </script>
</body>
</html>
